/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-appwrite";
exports.ids = ["vendor-chunks/node-appwrite"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-appwrite/index.js":
/*!*********************************************!*\
  !*** ./node_modules/node-appwrite/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Client = __webpack_require__(/*! ./lib/client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Query = __webpack_require__(/*! ./lib/query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\nconst Permission = __webpack_require__(/*! ./lib/permission.js */ \"(rsc)/./node_modules/node-appwrite/lib/permission.js\");\nconst Role = __webpack_require__(/*! ./lib/role.js */ \"(rsc)/./node_modules/node-appwrite/lib/role.js\");\nconst ID = __webpack_require__(/*! ./lib/id.js */ \"(rsc)/./node_modules/node-appwrite/lib/id.js\");\nconst InputFile = __webpack_require__(/*! ./lib/inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst AppwriteException = __webpack_require__(/*! ./lib/exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst Account = __webpack_require__(/*! ./lib/services/account.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/account.js\");\nconst Avatars = __webpack_require__(/*! ./lib/services/avatars.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/avatars.js\");\nconst Databases = __webpack_require__(/*! ./lib/services/databases.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/databases.js\");\nconst Functions = __webpack_require__(/*! ./lib/services/functions.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/functions.js\");\nconst Graphql = __webpack_require__(/*! ./lib/services/graphql.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/graphql.js\");\nconst Health = __webpack_require__(/*! ./lib/services/health.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/health.js\");\nconst Locale = __webpack_require__(/*! ./lib/services/locale.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/locale.js\");\nconst Storage = __webpack_require__(/*! ./lib/services/storage.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/storage.js\");\nconst Teams = __webpack_require__(/*! ./lib/services/teams.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/teams.js\");\nconst Users = __webpack_require__(/*! ./lib/services/users.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/users.js\");\nmodule.exports = {\n    Client,\n    Query,\n    Permission,\n    Role,\n    ID,\n    InputFile,\n    AppwriteException,\n    Account,\n    Avatars,\n    Databases,\n    Functions,\n    Graphql,\n    Health,\n    Locale,\n    Storage,\n    Teams,\n    Users\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUN0QixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQztBQUMzQixNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNSSxLQUFLSixtQkFBT0EsQ0FBQztBQUNuQixNQUFNSyxZQUFZTCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNTSxvQkFBb0JOLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1PLFVBQVVQLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1RLFVBQVVSLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1TLFlBQVlULG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1VLFlBQVlWLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1XLFVBQVVYLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1ZLFNBQVNaLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1hLFNBQVNiLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1jLFVBQVVkLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1lLFFBQVFmLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1nQixRQUFRaEIsbUJBQU9BLENBQUM7QUFFdEJpQixPQUFPQyxPQUFPLEdBQUc7SUFDYm5CO0lBQ0FFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2luZGV4LmpzPzg1YzMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9saWIvY2xpZW50LmpzJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vbGliL3F1ZXJ5LmpzJyk7XG5jb25zdCBQZXJtaXNzaW9uID0gcmVxdWlyZSgnLi9saWIvcGVybWlzc2lvbi5qcycpO1xuY29uc3QgUm9sZSA9IHJlcXVpcmUoJy4vbGliL3JvbGUuanMnKTtcbmNvbnN0IElEID0gcmVxdWlyZSgnLi9saWIvaWQuanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4vbGliL2lucHV0RmlsZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuL2xpYi9leGNlcHRpb24uanMnKTtcbmNvbnN0IEFjY291bnQgPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy9hY2NvdW50LmpzJyk7XG5jb25zdCBBdmF0YXJzID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvYXZhdGFycy5qcycpO1xuY29uc3QgRGF0YWJhc2VzID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvZGF0YWJhc2VzLmpzJyk7XG5jb25zdCBGdW5jdGlvbnMgPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy9mdW5jdGlvbnMuanMnKTtcbmNvbnN0IEdyYXBocWwgPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy9ncmFwaHFsLmpzJyk7XG5jb25zdCBIZWFsdGggPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy9oZWFsdGguanMnKTtcbmNvbnN0IExvY2FsZSA9IHJlcXVpcmUoJy4vbGliL3NlcnZpY2VzL2xvY2FsZS5qcycpO1xuY29uc3QgU3RvcmFnZSA9IHJlcXVpcmUoJy4vbGliL3NlcnZpY2VzL3N0b3JhZ2UuanMnKTtcbmNvbnN0IFRlYW1zID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvdGVhbXMuanMnKTtcbmNvbnN0IFVzZXJzID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvdXNlcnMuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ2xpZW50LFxuICAgIFF1ZXJ5LFxuICAgIFBlcm1pc3Npb24sXG4gICAgUm9sZSxcbiAgICBJRCxcbiAgICBJbnB1dEZpbGUsXG4gICAgQXBwd3JpdGVFeGNlcHRpb24sXG4gICAgQWNjb3VudCxcbiAgICBBdmF0YXJzLFxuICAgIERhdGFiYXNlcyxcbiAgICBGdW5jdGlvbnMsXG4gICAgR3JhcGhxbCxcbiAgICBIZWFsdGgsXG4gICAgTG9jYWxlLFxuICAgIFN0b3JhZ2UsXG4gICAgVGVhbXMsXG4gICAgVXNlcnMsXG59O1xuIl0sIm5hbWVzIjpbIkNsaWVudCIsInJlcXVpcmUiLCJRdWVyeSIsIlBlcm1pc3Npb24iLCJSb2xlIiwiSUQiLCJJbnB1dEZpbGUiLCJBcHB3cml0ZUV4Y2VwdGlvbiIsIkFjY291bnQiLCJBdmF0YXJzIiwiRGF0YWJhc2VzIiwiRnVuY3Rpb25zIiwiR3JhcGhxbCIsIkhlYWx0aCIsIkxvY2FsZSIsIlN0b3JhZ2UiLCJUZWFtcyIsIlVzZXJzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/client.js":
/*!**************************************************!*\
  !*** ./node_modules/node-appwrite/lib/client.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const os = __webpack_require__(/*! os */ \"os\");\nconst URL = (__webpack_require__(/*! url */ \"url\").URL);\nconst https = __webpack_require__(/*! https */ \"https\");\nconst axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nconst FormData = __webpack_require__(/*! form-data */ \"(rsc)/./node_modules/node-appwrite/node_modules/form-data/lib/form_data.js\");\nconst AppwriteException = __webpack_require__(/*! ./exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nclass Client {\n    static{\n        this.CHUNK_SIZE = 5 * 1024 * 1024 // 5MB\n        ;\n    }\n    constructor(){\n        this.endpoint = \"https://HOSTNAME/v1\";\n        this.headers = {\n            \"accept-encoding\": \"*\",\n            \"content-type\": \"\",\n            \"user-agent\": `AppwriteNodeJSSDK/11.1.0 (${os.type()}; ${os.version()}; ${os.arch()})`,\n            \"x-sdk-name\": \"Node.js\",\n            \"x-sdk-platform\": \"server\",\n            \"x-sdk-language\": \"nodejs\",\n            \"x-sdk-version\": \"11.1.0\",\n            \"X-Appwrite-Response-Format\": \"1.4.0\"\n        };\n        this.selfSigned = false;\n    }\n    /**\n     * Set Project\n     *\n     * Your project ID\n     *\n     * @param {string} project\n     *\n     * @return self\n     */ setProject(project) {\n        this.addHeader(\"X-Appwrite-Project\", project);\n        return this;\n    }\n    /**\n     * Set Key\n     *\n     * Your secret API key\n     *\n     * @param {string} key\n     *\n     * @return self\n     */ setKey(key) {\n        this.addHeader(\"X-Appwrite-Key\", key);\n        return this;\n    }\n    /**\n     * Set JWT\n     *\n     * Your secret JSON Web Token\n     *\n     * @param {string} jwt\n     *\n     * @return self\n     */ setJWT(jwt) {\n        this.addHeader(\"X-Appwrite-JWT\", jwt);\n        return this;\n    }\n    /**\n     * Set Locale\n     *\n     * @param {string} locale\n     *\n     * @return self\n     */ setLocale(locale) {\n        this.addHeader(\"X-Appwrite-Locale\", locale);\n        return this;\n    }\n    /**\n     * Set self signed.\n     *\n     * @param {bool} status\n     *\n     * @return this\n     */ setSelfSigned(status = true) {\n        this.selfSigned = status;\n        return this;\n    }\n    /**\n     * Set endpoint.\n     *\n     * @param {string} endpoint\n     *\n     * @return this\n     */ setEndpoint(endpoint) {\n        this.endpoint = endpoint;\n        return this;\n    }\n    /**\n     * @param {string} key\n     * @param {string} value\n     */ addHeader(key, value) {\n        this.headers[key.toLowerCase()] = value;\n        return this;\n    }\n    async call(method, path = \"\", headers = {}, params = {}, responseType = \"json\") {\n        headers = Object.assign({}, this.headers, headers);\n        let contentType = headers[\"content-type\"].toLowerCase();\n        let formData = null;\n        // Compute FormData for axios and appwrite.\n        if (contentType.startsWith(\"multipart/form-data\")) {\n            const form = new FormData();\n            let flatParams = Client.flatten(params);\n            for(const key in flatParams){\n                const value = flatParams[key];\n                if (value && value.type && value.type === \"file\") {\n                    form.append(key, value.file, {\n                        filename: value.filename\n                    });\n                } else {\n                    form.append(key, flatParams[key]);\n                }\n            }\n            headers = {\n                ...headers,\n                ...form.getHeaders()\n            };\n            formData = form;\n        }\n        let options = {\n            method: method.toUpperCase(),\n            url: this.endpoint + path,\n            params: method.toUpperCase() === \"GET\" ? params : {},\n            headers: headers,\n            data: method.toUpperCase() === \"GET\" || contentType.startsWith(\"multipart/form-data\") ? formData : params,\n            json: contentType.startsWith(\"application/json\"),\n            responseType: responseType\n        };\n        if (this.selfSigned) {\n            // Allow self signed requests\n            options.httpsAgent = new https.Agent({\n                rejectUnauthorized: false\n            });\n        }\n        try {\n            let response = await axios(options);\n            return response.data;\n        } catch (error) {\n            if (\"response\" in error && error.response !== undefined) {\n                if (error.response && \"data\" in error.response) {\n                    if (typeof error.response.data === \"string\") {\n                        throw new AppwriteException(error.response.data, error.response.status, \"\", error.response.data);\n                    } else {\n                        throw new AppwriteException(error.response.data.message, error.response.status, error.response.data.type, error.response.data);\n                    }\n                } else {\n                    throw new AppwriteException(error.response.statusText, error.response.status, error.response.data);\n                }\n            } else {\n                throw new AppwriteException(error.message);\n            }\n        }\n    }\n    static flatten(data, prefix = \"\") {\n        let output = {};\n        for(const key in data){\n            let value = data[key];\n            let finalKey = prefix ? prefix + \"[\" + key + \"]\" : key;\n            if (Array.isArray(value)) {\n                output = Object.assign(output, Client.flatten(value, finalKey)); // @todo: handle name collision here if needed\n            } else {\n                output[finalKey] = value;\n            }\n        }\n        return output;\n    }\n}\nmodule.exports = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ25CLE1BQU1DLE1BQU1ELDJDQUFrQjtBQUM5QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNRyxRQUFRSCxtQkFBT0EsQ0FBQztBQUN0QixNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQztBQUN6QixNQUFNSyxvQkFBb0JMLG1CQUFPQSxDQUFDO0FBRWxDLE1BQU1NOzthQUNLQyxhQUFhLElBQUUsT0FBSyxLQUFNLE1BQU07OztJQUV2Q0MsYUFBYztRQUNWLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1lBQ1gsbUJBQW1CO1lBQ25CLGdCQUFnQjtZQUNoQixjQUFlLENBQUMsMEJBQTBCLEVBQUVYLEdBQUdZLElBQUksR0FBRyxFQUFFLEVBQUVaLEdBQUdhLE9BQU8sR0FBRyxFQUFFLEVBQUViLEdBQUdjLElBQUksR0FBRyxDQUFDLENBQUM7WUFDdkYsY0FBYztZQUNkLGtCQUFrQjtZQUNsQixrQkFBa0I7WUFDbEIsaUJBQWlCO1lBQ2pCLDhCQUErQjtRQUNuQztRQUNBLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ3RCO0lBRUE7Ozs7Ozs7O0tBUUMsR0FDREMsV0FBV0MsT0FBTyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxDQUFDLHNCQUFzQkQ7UUFFckMsT0FBTyxJQUFJO0lBQ2Y7SUFFQTs7Ozs7Ozs7S0FRQyxHQUNERSxPQUFPQyxHQUFHLEVBQUU7UUFDUixJQUFJLENBQUNGLFNBQVMsQ0FBQyxrQkFBa0JFO1FBRWpDLE9BQU8sSUFBSTtJQUNmO0lBRUE7Ozs7Ozs7O0tBUUMsR0FDREMsT0FBT0MsR0FBRyxFQUFFO1FBQ1IsSUFBSSxDQUFDSixTQUFTLENBQUMsa0JBQWtCSTtRQUVqQyxPQUFPLElBQUk7SUFDZjtJQUVBOzs7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O3dCQUNILE1BQU0sSUFBSTVDLGtCQUFrQmtELE1BQU1ELFFBQVEsQ0FBQ0wsSUFBSSxDQUFDUSxPQUFPLEVBQUVGLE1BQU1ELFFBQVEsQ0FBQzdCLE1BQU0sRUFBRThCLE1BQU1ELFFBQVEsQ0FBQ0wsSUFBSSxDQUFDdEMsSUFBSSxFQUFFNEMsTUFBTUQsUUFBUSxDQUFDTCxJQUFJO29CQUNqSTtnQkFDSixPQUFPO29CQUNILE1BQU0sSUFBSTVDLGtCQUFrQmtELE1BQU1ELFFBQVEsQ0FBQ0ksVUFBVSxFQUFFSCxNQUFNRCxRQUFRLENBQUM3QixNQUFNLEVBQUU4QixNQUFNRCxRQUFRLENBQUNMLElBQUk7Z0JBQ3JHO1lBQ0osT0FBTztnQkFDSCxNQUFNLElBQUk1QyxrQkFBa0JrRCxNQUFNRSxPQUFPO1lBQzdDO1FBQ0o7SUFDSjtJQUVBLE9BQU9oQixRQUFRUSxJQUFJLEVBQUVVLFNBQVMsRUFBRSxFQUFFO1FBQzlCLElBQUlDLFNBQVMsQ0FBQztRQUVkLElBQUssTUFBTXpDLE9BQU84QixLQUFNO1lBQ3BCLElBQUl0QixRQUFRc0IsSUFBSSxDQUFDOUIsSUFBSTtZQUNyQixJQUFJMEMsV0FBV0YsU0FBU0EsU0FBUyxNQUFNeEMsTUFBSyxNQUFNQTtZQUVsRCxJQUFJMkMsTUFBTUMsT0FBTyxDQUFDcEMsUUFBUTtnQkFDdEJpQyxTQUFTMUIsT0FBT0MsTUFBTSxDQUFDeUIsUUFBUXRELE9BQU9tQyxPQUFPLENBQUNkLE9BQU9rQyxZQUFZLDhDQUE4QztZQUNuSCxPQUFPO2dCQUNIRCxNQUFNLENBQUNDLFNBQVMsR0FBR2xDO1lBQ3ZCO1FBQ0o7UUFFQSxPQUFPaUM7SUFDWDtBQUNKO0FBRUFJLE9BQU9DLE9BQU8sR0FBRzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja25lc3QvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvY2xpZW50LmpzPzY5YjgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgVVJMID0gcmVxdWlyZSgndXJsJykuVVJMO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5jb25zdCBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XG5jb25zdCBGb3JtRGF0YSA9IHJlcXVpcmUoJ2Zvcm0tZGF0YScpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbi5qcycpO1xuXG5jbGFzcyBDbGllbnQge1xuICAgIHN0YXRpYyBDSFVOS19TSVpFID0gNSoxMDI0KjEwMjQ7IC8vIDVNQlxuICAgIFxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gJ2h0dHBzOi8vSE9TVE5BTUUvdjEnO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnYWNjZXB0LWVuY29kaW5nJzogJyonLFxuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICcnLFxuICAgICAgICAgICAgJ3VzZXItYWdlbnQnIDogYEFwcHdyaXRlTm9kZUpTU0RLLzExLjEuMCAoJHtvcy50eXBlKCl9OyAke29zLnZlcnNpb24oKX07ICR7b3MuYXJjaCgpfSlgLFxuICAgICAgICAgICAgJ3gtc2RrLW5hbWUnOiAnTm9kZS5qcycsXG4gICAgICAgICAgICAneC1zZGstcGxhdGZvcm0nOiAnc2VydmVyJyxcbiAgICAgICAgICAgICd4LXNkay1sYW5ndWFnZSc6ICdub2RlanMnLFxuICAgICAgICAgICAgJ3gtc2RrLXZlcnNpb24nOiAnMTEuMS4wJyxcbiAgICAgICAgICAgICdYLUFwcHdyaXRlLVJlc3BvbnNlLUZvcm1hdCcgOiAnMS40LjAnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbGZTaWduZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgUHJvamVjdFxuICAgICAqXG4gICAgICogWW91ciBwcm9qZWN0IElEXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdFxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgc2V0UHJvamVjdChwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMuYWRkSGVhZGVyKCdYLUFwcHdyaXRlLVByb2plY3QnLCBwcm9qZWN0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgS2V5XG4gICAgICpcbiAgICAgKiBZb3VyIHNlY3JldCBBUEkga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBzZXRLZXkoa2V5KSB7XG4gICAgICAgIHRoaXMuYWRkSGVhZGVyKCdYLUFwcHdyaXRlLUtleScsIGtleSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IEpXVFxuICAgICAqXG4gICAgICogWW91ciBzZWNyZXQgSlNPTiBXZWIgVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqd3RcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNldEpXVChqd3QpIHtcbiAgICAgICAgdGhpcy5hZGRIZWFkZXIoJ1gtQXBwd3JpdGUtSldUJywgand0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgTG9jYWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgICAgIHRoaXMuYWRkSGVhZGVyKCdYLUFwcHdyaXRlLUxvY2FsZScsIGxvY2FsZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHNlbGYgc2lnbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sfSBzdGF0dXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHNldFNlbGZTaWduZWQoc3RhdHVzID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGZTaWduZWQgPSBzdGF0dXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGVuZHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBzZXRFbmRwb2ludChlbmRwb2ludClcbiAgICB7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgYWRkSGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgICAgXG4gICAgYXN5bmMgY2FsbChtZXRob2QsIHBhdGggPSAnJywgaGVhZGVycyA9IHt9LCBwYXJhbXMgPSB7fSwgcmVzcG9uc2VUeXBlID0gJ2pzb24nKSB7XG4gICAgICAgIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMsIGhlYWRlcnMpO1xuXG4gICAgICAgIGxldCBjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgbGV0IGZvcm1EYXRhID0gbnVsbDtcblxuICAgICAgICAvLyBDb21wdXRlIEZvcm1EYXRhIGZvciBheGlvcyBhbmQgYXBwd3JpdGUuXG4gICAgICAgIGlmIChjb250ZW50VHlwZS5zdGFydHNXaXRoKCdtdWx0aXBhcnQvZm9ybS1kYXRhJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGZsYXRQYXJhbXMgPSBDbGllbnQuZmxhdHRlbihwYXJhbXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmbGF0UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmbGF0UGFyYW1zW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZih2YWx1ZSAmJiB2YWx1ZS50eXBlICYmIHZhbHVlLnR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChrZXksIHZhbHVlLmZpbGUsIHsgZmlsZW5hbWU6IHZhbHVlLmZpbGVuYW1lIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgZmxhdFBhcmFtc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICAgICAgICAuLi5mb3JtLmdldEhlYWRlcnMoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9ybURhdGEgPSBmb3JtO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgdXJsOiB0aGlzLmVuZHBvaW50ICsgcGF0aCxcbiAgICAgICAgICAgIHBhcmFtczogKG1ldGhvZC50b1VwcGVyQ2FzZSgpID09PSAnR0VUJykgPyBwYXJhbXMgOiB7fSxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiAobWV0aG9kLnRvVXBwZXJDYXNlKCkgPT09ICdHRVQnIHx8IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGFydC9mb3JtLWRhdGEnKSkgPyBmb3JtRGF0YSA6IHBhcmFtcyxcbiAgICAgICAgICAgIGpzb246IChjb250ZW50VHlwZS5zdGFydHNXaXRoKCdhcHBsaWNhdGlvbi9qc29uJykpLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiByZXNwb25zZVR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZlNpZ25lZCkge1xuICAgICAgICAgICAgLy8gQWxsb3cgc2VsZiBzaWduZWQgcmVxdWVzdHNcbiAgICAgICAgICAgIG9wdGlvbnMuaHR0cHNBZ2VudCA9IG5ldyBodHRwcy5BZ2VudCh7IHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGF4aW9zKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGlmKCdyZXNwb25zZScgaW4gZXJyb3IgJiYgZXJyb3IucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmKGVycm9yLnJlc3BvbnNlICYmICdkYXRhJyBpbiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGVycm9yLnJlc3BvbnNlLmRhdGEpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKGVycm9yLnJlc3BvbnNlLmRhdGEsIGVycm9yLnJlc3BvbnNlLnN0YXR1cywgJycsIGVycm9yLnJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKGVycm9yLnJlc3BvbnNlLmRhdGEubWVzc2FnZSwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzLCBlcnJvci5yZXNwb25zZS5kYXRhLnR5cGUsIGVycm9yLnJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKGVycm9yLnJlc3BvbnNlLnN0YXR1c1RleHQsIGVycm9yLnJlc3BvbnNlLnN0YXR1cywgZXJyb3IucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZmxhdHRlbihkYXRhLCBwcmVmaXggPSAnJykge1xuICAgICAgICBsZXQgb3V0cHV0ID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgbGV0IGZpbmFsS2V5ID0gcHJlZml4ID8gcHJlZml4ICsgJ1snICsga2V5ICsnXScgOiBrZXk7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IE9iamVjdC5hc3NpZ24ob3V0cHV0LCBDbGllbnQuZmxhdHRlbih2YWx1ZSwgZmluYWxLZXkpKTsgLy8gQHRvZG86IGhhbmRsZSBuYW1lIGNvbGxpc2lvbiBoZXJlIGlmIG5lZWRlZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbZmluYWxLZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnQ7XG4iXSwibmFtZXMiOlsib3MiLCJyZXF1aXJlIiwiVVJMIiwiaHR0cHMiLCJheGlvcyIsIkZvcm1EYXRhIiwiQXBwd3JpdGVFeGNlcHRpb24iLCJDbGllbnQiLCJDSFVOS19TSVpFIiwiY29uc3RydWN0b3IiLCJlbmRwb2ludCIsImhlYWRlcnMiLCJ0eXBlIiwidmVyc2lvbiIsImFyY2giLCJzZWxmU2lnbmVkIiwic2V0UHJvamVjdCIsInByb2plY3QiLCJhZGRIZWFkZXIiLCJzZXRLZXkiLCJrZXkiLCJzZXRKV1QiLCJqd3QiLCJzZXRMb2NhbGUiLCJsb2NhbGUiLCJzZXRTZWxmU2lnbmVkIiwic3RhdHVzIiwic2V0RW5kcG9pbnQiLCJ2YWx1ZSIsInRvTG93ZXJDYXNlIiwiY2FsbCIsIm1ldGhvZCIsInBhdGgiLCJwYXJhbXMiLCJyZXNwb25zZVR5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJjb250ZW50VHlwZSIsImZvcm1EYXRhIiwic3RhcnRzV2l0aCIsImZvcm0iLCJmbGF0UGFyYW1zIiwiZmxhdHRlbiIsImFwcGVuZCIsImZpbGUiLCJmaWxlbmFtZSIsImdldEhlYWRlcnMiLCJvcHRpb25zIiwidG9VcHBlckNhc2UiLCJ1cmwiLCJkYXRhIiwianNvbiIsImh0dHBzQWdlbnQiLCJBZ2VudCIsInJlamVjdFVuYXV0aG9yaXplZCIsInJlc3BvbnNlIiwiZXJyb3IiLCJ1bmRlZmluZWQiLCJtZXNzYWdlIiwic3RhdHVzVGV4dCIsInByZWZpeCIsIm91dHB1dCIsImZpbmFsS2V5IiwiQXJyYXkiLCJpc0FycmF5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/exception.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-appwrite/lib/exception.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("class AppwriteException extends Error {\n    constructor(message, code, type, response){\n        super(message);\n        this.code = code;\n        this.type = type;\n        this.response = response;\n    }\n}\nmodule.exports = AppwriteException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9leGNlcHRpb24uanM/NjhhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBBcHB3cml0ZUV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgdHlwZSwgcmVzcG9uc2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwd3JpdGVFeGNlcHRpb247Il0sIm5hbWVzIjpbIkFwcHdyaXRlRXhjZXB0aW9uIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJjb2RlIiwidHlwZSIsInJlc3BvbnNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsMEJBQTBCQztJQUM5QkMsWUFBWUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQ3pDLEtBQUssQ0FBQ0g7UUFDTixJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDbEI7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdSIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2V4Y2VwdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/exception.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/id.js":
/*!**********************************************!*\
  !*** ./node_modules/node-appwrite/lib/id.js ***!
  \**********************************************/
/***/ ((module) => {

eval("class ID {\n    static{\n        this.unique = ()=>{\n            return \"unique()\";\n        };\n    }\n    static{\n        this.custom = (id)=>{\n            return id;\n        };\n    }\n}\nmodule.exports = ID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9pZC5qcz83YzZmIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIElEIHtcblxuICAgIHN0YXRpYyB1bmlxdWUgPSAoKSA9PiB7XG4gICAgICAgICByZXR1cm4gJ3VuaXF1ZSgpJ1xuICAgIH1cblxuICAgIHN0YXRpYyBjdXN0b20gPSAoaWQpID0+IHtcbiAgICAgICAgIHJldHVybiBpZFxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJRDtcbiJdLCJuYW1lcyI6WyJJRCIsInVuaXF1ZSIsImN1c3RvbSIsImlkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUE7O2FBRUtDLFNBQVM7WUFDWCxPQUFPO1FBQ1o7OzthQUVPQyxTQUFTLENBQUNDO1lBQ1osT0FBT0E7UUFDWjs7QUFDSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdMIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2lkLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/id.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/inputFile.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-appwrite/lib/inputFile.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass InputFile {\n    static{\n        this.fromPath = (filePath, filename)=>{\n            const stream = fs.createReadStream(filePath);\n            const { size } = fs.statSync(filePath);\n            return new InputFile(stream, filename, size);\n        };\n    }\n    static{\n        this.fromBuffer = (buffer, filename)=>{\n            const stream = Readable.from(buffer);\n            const size = Buffer.byteLength(buffer);\n            return new InputFile(stream, filename, size);\n        };\n    }\n    static{\n        this.fromBlob = async (blob, filename)=>{\n            const arrayBuffer = await blob.arrayBuffer();\n            const buffer = Buffer.from(arrayBuffer);\n            return InputFile.fromBuffer(buffer, filename);\n        };\n    }\n    static{\n        this.fromStream = (stream, filename, size)=>{\n            return new InputFile(stream, filename, size);\n        };\n    }\n    static{\n        this.fromPlainText = (content, filename)=>{\n            const buffer = Buffer.from(content, \"utf-8\");\n            const stream = Readable.from(buffer);\n            const size = Buffer.byteLength(buffer);\n            return new InputFile(stream, filename, size);\n        };\n    }\n    constructor(stream, filename, size){\n        this.stream = stream;\n        this.filename = filename;\n        this.size = size;\n    }\n}\nmodule.exports = InputFile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvaW5wdXRGaWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsUUFBUSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1DLEtBQUtELG1CQUFPQSxDQUFDO0FBRW5CLE1BQU1FOzthQUtHQyxXQUFXLENBQUNDLFVBQVVDO1lBQzNCLE1BQU1DLFNBQVNMLEdBQUdNLGdCQUFnQixDQUFDSDtZQUNuQyxNQUFNLEVBQUVJLElBQUksRUFBRSxHQUFHUCxHQUFHUSxRQUFRLENBQUNMO1lBQzdCLE9BQU8sSUFBSUYsVUFBVUksUUFBUUQsVUFBVUc7UUFDekM7OzthQUVPRSxhQUFhLENBQUNDLFFBQVFOO1lBQzNCLE1BQU1DLFNBQVNQLFNBQVNhLElBQUksQ0FBQ0Q7WUFDN0IsTUFBTUgsT0FBT0ssT0FBT0MsVUFBVSxDQUFDSDtZQUMvQixPQUFPLElBQUlULFVBQVVJLFFBQVFELFVBQVVHO1FBQ3pDOzs7YUFFT08sV0FBVyxPQUFPQyxNQUFNWDtZQUM3QixNQUFNWSxjQUFjLE1BQU1ELEtBQUtDLFdBQVc7WUFDMUMsTUFBTU4sU0FBU0UsT0FBT0QsSUFBSSxDQUFDSztZQUMzQixPQUFPZixVQUFVUSxVQUFVLENBQUNDLFFBQVFOO1FBQ3RDOzs7YUFFT2EsYUFBYSxDQUFDWixRQUFRRCxVQUFVRztZQUNyQyxPQUFPLElBQUlOLFVBQVVJLFFBQVFELFVBQVVHO1FBQ3pDOzs7YUFFT1csZ0JBQWdCLENBQUNDLFNBQVNmO1lBQy9CLE1BQU1NLFNBQVNFLE9BQU9ELElBQUksQ0FBQ1EsU0FBUztZQUNwQyxNQUFNZCxTQUFTUCxTQUFTYSxJQUFJLENBQUNEO1lBQzdCLE1BQU1ILE9BQU9LLE9BQU9DLFVBQVUsQ0FBQ0g7WUFDL0IsT0FBTyxJQUFJVCxVQUFVSSxRQUFRRCxVQUFVRztRQUN6Qzs7SUFFQWEsWUFBWWYsTUFBTSxFQUFFRCxRQUFRLEVBQUVHLElBQUksQ0FBRTtRQUNsQyxJQUFJLENBQUNGLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRyxJQUFJLEdBQUdBO0lBQ2Q7QUFDRjtBQUVBYyxPQUFPQyxPQUFPLEdBQUdyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2tuZXN0Ly4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2lucHV0RmlsZS5qcz80YzE1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5jbGFzcyBJbnB1dEZpbGUge1xuICBzdHJlYW07IC8vIENvbnRlbnQgb2YgZmlsZSwgcmVhZGFibGUgc3RyZWFtXG4gIHNpemU7IC8vIFRvdGFsIGZpbmFsIHNpemUgb2YgdGhlIGZpbGUgY29udGVudFxuICBmaWxlbmFtZTsgLy8gRmlsZSBuYW1lXG5cbiAgc3RhdGljIGZyb21QYXRoID0gKGZpbGVQYXRoLCBmaWxlbmFtZSkgPT4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZVBhdGgpO1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpO1xuICAgIHJldHVybiBuZXcgSW5wdXRGaWxlKHN0cmVhbSwgZmlsZW5hbWUsIHNpemUpO1xuICB9O1xuXG4gIHN0YXRpYyBmcm9tQnVmZmVyID0gKGJ1ZmZlciwgZmlsZW5hbWUpID0+IHtcbiAgICBjb25zdCBzdHJlYW0gPSBSZWFkYWJsZS5mcm9tKGJ1ZmZlcik7XG4gICAgY29uc3Qgc2l6ZSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGJ1ZmZlcik7XG4gICAgcmV0dXJuIG5ldyBJbnB1dEZpbGUoc3RyZWFtLCBmaWxlbmFtZSwgc2l6ZSk7XG4gIH07XG5cbiAgc3RhdGljIGZyb21CbG9iID0gYXN5bmMgKGJsb2IsIGZpbGVuYW1lKSA9PiB7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpO1xuICAgIHJldHVybiBJbnB1dEZpbGUuZnJvbUJ1ZmZlcihidWZmZXIsIGZpbGVuYW1lKTtcbiAgfTtcblxuICBzdGF0aWMgZnJvbVN0cmVhbSA9IChzdHJlYW0sIGZpbGVuYW1lLCBzaXplKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dEZpbGUoc3RyZWFtLCBmaWxlbmFtZSwgc2l6ZSk7XG4gIH07XG5cbiAgc3RhdGljIGZyb21QbGFpblRleHQgPSAoY29udGVudCwgZmlsZW5hbWUpID0+IHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShjb250ZW50LCBcInV0Zi04XCIpO1xuICAgIGNvbnN0IHN0cmVhbSA9IFJlYWRhYmxlLmZyb20oYnVmZmVyKTtcbiAgICBjb25zdCBzaXplID0gQnVmZmVyLmJ5dGVMZW5ndGgoYnVmZmVyKTtcbiAgICByZXR1cm4gbmV3IElucHV0RmlsZShzdHJlYW0sIGZpbGVuYW1lLCBzaXplKTtcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGZpbGVuYW1lLCBzaXplKSB7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dEZpbGU7XG4iXSwibmFtZXMiOlsiUmVhZGFibGUiLCJyZXF1aXJlIiwiZnMiLCJJbnB1dEZpbGUiLCJmcm9tUGF0aCIsImZpbGVQYXRoIiwiZmlsZW5hbWUiLCJzdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwic2l6ZSIsInN0YXRTeW5jIiwiZnJvbUJ1ZmZlciIsImJ1ZmZlciIsImZyb20iLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwiZnJvbUJsb2IiLCJibG9iIiwiYXJyYXlCdWZmZXIiLCJmcm9tU3RyZWFtIiwiZnJvbVBsYWluVGV4dCIsImNvbnRlbnQiLCJjb25zdHJ1Y3RvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/inputFile.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/permission.js":
/*!******************************************************!*\
  !*** ./node_modules/node-appwrite/lib/permission.js ***!
  \******************************************************/
/***/ ((module) => {

eval("class Permission {\n    static{\n        this.read = (role)=>{\n            return `read(\"${role}\")`;\n        };\n    }\n    static{\n        this.write = (role)=>{\n            return `write(\"${role}\")`;\n        };\n    }\n    static{\n        this.create = (role)=>{\n            return `create(\"${role}\")`;\n        };\n    }\n    static{\n        this.update = (role)=>{\n            return `update(\"${role}\")`;\n        };\n    }\n    static{\n        this.delete = (role)=>{\n            return `delete(\"${role}\")`;\n        };\n    }\n}\nmodule.exports = Permission;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9wZXJtaXNzaW9uLmpzPzRmZmEiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUGVybWlzc2lvbiB7XG5cbiAgICBzdGF0aWMgcmVhZCA9IChyb2xlKSA9PiB7XG4gICAgICAgICByZXR1cm4gYHJlYWQoXCIke3JvbGV9XCIpYFxuICAgIH1cblxuICAgIHN0YXRpYyB3cml0ZSA9IChyb2xlKSA9PiB7XG4gICAgICAgICByZXR1cm4gYHdyaXRlKFwiJHtyb2xlfVwiKWBcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlID0gKHJvbGUpID0+IHtcbiAgICAgICAgIHJldHVybiBgY3JlYXRlKFwiJHtyb2xlfVwiKWBcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlID0gKHJvbGUpID0+IHtcbiAgICAgICAgIHJldHVybiBgdXBkYXRlKFwiJHtyb2xlfVwiKWBcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVsZXRlID0gKHJvbGUpID0+IHtcbiAgICAgICAgIHJldHVybiBgZGVsZXRlKFwiJHtyb2xlfVwiKWBcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVybWlzc2lvbjtcbiJdLCJuYW1lcyI6WyJQZXJtaXNzaW9uIiwicmVhZCIsInJvbGUiLCJ3cml0ZSIsImNyZWF0ZSIsInVwZGF0ZSIsImRlbGV0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BOzthQUVLQyxPQUFPLENBQUNDO1lBQ1YsT0FBTyxDQUFDLE1BQU0sRUFBRUEsS0FBSyxFQUFFLENBQUM7UUFDN0I7OzthQUVPQyxRQUFRLENBQUNEO1lBQ1gsT0FBTyxDQUFDLE9BQU8sRUFBRUEsS0FBSyxFQUFFLENBQUM7UUFDOUI7OzthQUVPRSxTQUFTLENBQUNGO1lBQ1osT0FBTyxDQUFDLFFBQVEsRUFBRUEsS0FBSyxFQUFFLENBQUM7UUFDL0I7OzthQUVPRyxTQUFTLENBQUNIO1lBQ1osT0FBTyxDQUFDLFFBQVEsRUFBRUEsS0FBSyxFQUFFLENBQUM7UUFDL0I7OzthQUVPSSxTQUFTLENBQUNKO1lBQ1osT0FBTyxDQUFDLFFBQVEsRUFBRUEsS0FBSyxFQUFFLENBQUM7UUFDL0I7O0FBQ0o7QUFFQUssT0FBT0MsT0FBTyxHQUFHUiIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9wZXJtaXNzaW9uLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/permission.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/query.js":
/*!*************************************************!*\
  !*** ./node_modules/node-appwrite/lib/query.js ***!
  \*************************************************/
/***/ ((module) => {

eval("class Query {\n    static{\n        this.equal = (attribute, value)=>Query.addQuery(attribute, \"equal\", value);\n    }\n    static{\n        this.notEqual = (attribute, value)=>Query.addQuery(attribute, \"notEqual\", value);\n    }\n    static{\n        this.lessThan = (attribute, value)=>Query.addQuery(attribute, \"lessThan\", value);\n    }\n    static{\n        this.lessThanEqual = (attribute, value)=>Query.addQuery(attribute, \"lessThanEqual\", value);\n    }\n    static{\n        this.greaterThan = (attribute, value)=>Query.addQuery(attribute, \"greaterThan\", value);\n    }\n    static{\n        this.greaterThanEqual = (attribute, value)=>Query.addQuery(attribute, \"greaterThanEqual\", value);\n    }\n    static{\n        this.isNull = (attribute)=>`isNull(\"${attribute}\")`;\n    }\n    static{\n        this.isNotNull = (attribute)=>`isNotNull(\"${attribute}\")`;\n    }\n    static{\n        this.between = (attribute, start, end)=>`between(\"${attribute}\", ${Query.parseValues(start)}, ${Query.parseValues(end)})`;\n    }\n    static{\n        this.startsWith = (attribute, value)=>Query.addQuery(attribute, \"startsWith\", value);\n    }\n    static{\n        this.endsWith = (attribute, value)=>Query.addQuery(attribute, \"endsWith\", value);\n    }\n    static{\n        this.select = (attributes)=>`select([${attributes.map((attr)=>`\"${attr}\"`).join(\",\")}])`;\n    }\n    static{\n        this.search = (attribute, value)=>Query.addQuery(attribute, \"search\", value);\n    }\n    static{\n        this.orderDesc = (attribute)=>`orderDesc(\"${attribute}\")`;\n    }\n    static{\n        this.orderAsc = (attribute)=>`orderAsc(\"${attribute}\")`;\n    }\n    static{\n        this.cursorAfter = (documentId)=>`cursorAfter(\"${documentId}\")`;\n    }\n    static{\n        this.cursorBefore = (documentId)=>`cursorBefore(\"${documentId}\")`;\n    }\n    static{\n        this.limit = (limit)=>`limit(${limit})`;\n    }\n    static{\n        this.offset = (offset)=>`offset(${offset})`;\n    }\n    static{\n        this.addQuery = (attribute, method, value)=>value instanceof Array ? `${method}(\"${attribute}\", [${value.map((v)=>Query.parseValues(v)).join(\",\")}])` : `${method}(\"${attribute}\", [${Query.parseValues(value)}])`;\n    }\n    static{\n        this.parseValues = (value)=>typeof value === \"string\" || value instanceof String ? `\"${value}\"` : `${value}`;\n    }\n}\nmodule.exports = Query;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9xdWVyeS5qcz82NTNkIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFF1ZXJ5IHtcbiAgc3RhdGljIGVxdWFsID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+XG4gICAgUXVlcnkuYWRkUXVlcnkoYXR0cmlidXRlLCBcImVxdWFsXCIsIHZhbHVlKTtcblxuICBzdGF0aWMgbm90RXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT5cbiAgICBRdWVyeS5hZGRRdWVyeShhdHRyaWJ1dGUsIFwibm90RXF1YWxcIiwgdmFsdWUpO1xuXG4gIHN0YXRpYyBsZXNzVGhhbiA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIFF1ZXJ5LmFkZFF1ZXJ5KGF0dHJpYnV0ZSwgXCJsZXNzVGhhblwiLCB2YWx1ZSk7XG5cbiAgc3RhdGljIGxlc3NUaGFuRXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT5cbiAgICBRdWVyeS5hZGRRdWVyeShhdHRyaWJ1dGUsIFwibGVzc1RoYW5FcXVhbFwiLCB2YWx1ZSk7XG5cbiAgc3RhdGljIGdyZWF0ZXJUaGFuID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+XG4gICAgUXVlcnkuYWRkUXVlcnkoYXR0cmlidXRlLCBcImdyZWF0ZXJUaGFuXCIsIHZhbHVlKTtcblxuICBzdGF0aWMgZ3JlYXRlclRoYW5FcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIFF1ZXJ5LmFkZFF1ZXJ5KGF0dHJpYnV0ZSwgXCJncmVhdGVyVGhhbkVxdWFsXCIsIHZhbHVlKTtcblxuICBzdGF0aWMgaXNOdWxsID0gKGF0dHJpYnV0ZSkgPT5cbiAgICBgaXNOdWxsKFwiJHthdHRyaWJ1dGV9XCIpYDtcblxuICBzdGF0aWMgaXNOb3ROdWxsID0gKGF0dHJpYnV0ZSkgPT5cbiAgICBgaXNOb3ROdWxsKFwiJHthdHRyaWJ1dGV9XCIpYDtcblxuICBzdGF0aWMgYmV0d2VlbiA9IChhdHRyaWJ1dGUsIHN0YXJ0LCBlbmQpID0+XG4gICAgYGJldHdlZW4oXCIke2F0dHJpYnV0ZX1cIiwgJHtRdWVyeS5wYXJzZVZhbHVlcyhzdGFydCl9LCAke1F1ZXJ5LnBhcnNlVmFsdWVzKGVuZCl9KWBcblxuICBzdGF0aWMgc3RhcnRzV2l0aCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIFF1ZXJ5LmFkZFF1ZXJ5KGF0dHJpYnV0ZSwgXCJzdGFydHNXaXRoXCIsIHZhbHVlKTtcblxuICBzdGF0aWMgZW5kc1dpdGggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT5cbiAgICBRdWVyeS5hZGRRdWVyeShhdHRyaWJ1dGUsIFwiZW5kc1dpdGhcIiwgdmFsdWUpO1xuXG4gIHN0YXRpYyBzZWxlY3QgPSAoYXR0cmlidXRlcykgPT5cbiAgICBgc2VsZWN0KFske2F0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiBgXCIke2F0dHJ9XCJgKS5qb2luKFwiLFwiKX1dKWA7XG5cbiAgc3RhdGljIHNlYXJjaCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIFF1ZXJ5LmFkZFF1ZXJ5KGF0dHJpYnV0ZSwgXCJzZWFyY2hcIiwgdmFsdWUpO1xuXG4gIHN0YXRpYyBvcmRlckRlc2MgPSAoYXR0cmlidXRlKSA9PlxuICAgIGBvcmRlckRlc2MoXCIke2F0dHJpYnV0ZX1cIilgO1xuXG4gIHN0YXRpYyBvcmRlckFzYyA9IChhdHRyaWJ1dGUpID0+XG4gICAgYG9yZGVyQXNjKFwiJHthdHRyaWJ1dGV9XCIpYDtcblxuICBzdGF0aWMgY3Vyc29yQWZ0ZXIgPSAoZG9jdW1lbnRJZCkgPT5cbiAgICBgY3Vyc29yQWZ0ZXIoXCIke2RvY3VtZW50SWR9XCIpYDtcblxuICBzdGF0aWMgY3Vyc29yQmVmb3JlID0gKGRvY3VtZW50SWQpID0+XG4gICAgYGN1cnNvckJlZm9yZShcIiR7ZG9jdW1lbnRJZH1cIilgO1xuXG4gIHN0YXRpYyBsaW1pdCA9IChsaW1pdCkgPT5cbiAgICBgbGltaXQoJHtsaW1pdH0pYDtcblxuICBzdGF0aWMgb2Zmc2V0ID0gKG9mZnNldCkgPT5cbiAgICBgb2Zmc2V0KCR7b2Zmc2V0fSlgO1xuXG4gIHN0YXRpYyBhZGRRdWVyeSA9IChhdHRyaWJ1dGUsIG1ldGhvZCwgdmFsdWUpID0+XG4gICAgdmFsdWUgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgPyBgJHttZXRob2R9KFwiJHthdHRyaWJ1dGV9XCIsIFske3ZhbHVlXG4gICAgICAgICAgLm1hcCgodikgPT4gUXVlcnkucGFyc2VWYWx1ZXModikpXG4gICAgICAgICAgLmpvaW4oXCIsXCIpfV0pYFxuICAgICAgOiBgJHttZXRob2R9KFwiJHthdHRyaWJ1dGV9XCIsIFske1F1ZXJ5LnBhcnNlVmFsdWVzKHZhbHVlKX1dKWA7XG5cbiAgc3RhdGljIHBhcnNlVmFsdWVzID0gKHZhbHVlKSA9PlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZ1xuICAgICAgPyBgXCIke3ZhbHVlfVwiYFxuICAgICAgOiBgJHt2YWx1ZX1gO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuIl0sIm5hbWVzIjpbIlF1ZXJ5IiwiZXF1YWwiLCJhdHRyaWJ1dGUiLCJ2YWx1ZSIsImFkZFF1ZXJ5Iiwibm90RXF1YWwiLCJsZXNzVGhhbiIsImxlc3NUaGFuRXF1YWwiLCJncmVhdGVyVGhhbiIsImdyZWF0ZXJUaGFuRXF1YWwiLCJpc051bGwiLCJpc05vdE51bGwiLCJiZXR3ZWVuIiwic3RhcnQiLCJlbmQiLCJwYXJzZVZhbHVlcyIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNlbGVjdCIsImF0dHJpYnV0ZXMiLCJtYXAiLCJhdHRyIiwiam9pbiIsInNlYXJjaCIsIm9yZGVyRGVzYyIsIm9yZGVyQXNjIiwiY3Vyc29yQWZ0ZXIiLCJkb2N1bWVudElkIiwiY3Vyc29yQmVmb3JlIiwibGltaXQiLCJvZmZzZXQiLCJtZXRob2QiLCJBcnJheSIsInYiLCJTdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxNQUFNQTs7YUFDR0MsUUFBUSxDQUFDQyxXQUFXQyxRQUN6QkgsTUFBTUksUUFBUSxDQUFDRixXQUFXLFNBQVNDOzs7YUFFOUJFLFdBQVcsQ0FBQ0gsV0FBV0MsUUFDNUJILE1BQU1JLFFBQVEsQ0FBQ0YsV0FBVyxZQUFZQzs7O2FBRWpDRyxXQUFXLENBQUNKLFdBQVdDLFFBQzVCSCxNQUFNSSxRQUFRLENBQUNGLFdBQVcsWUFBWUM7OzthQUVqQ0ksZ0JBQWdCLENBQUNMLFdBQVdDLFFBQ2pDSCxNQUFNSSxRQUFRLENBQUNGLFdBQVcsaUJBQWlCQzs7O2FBRXRDSyxjQUFjLENBQUNOLFdBQVdDLFFBQy9CSCxNQUFNSSxRQUFRLENBQUNGLFdBQVcsZUFBZUM7OzthQUVwQ00sbUJBQW1CLENBQUNQLFdBQVdDLFFBQ3BDSCxNQUFNSSxRQUFRLENBQUNGLFdBQVcsb0JBQW9CQzs7O2FBRXpDTyxTQUFTLENBQUNSLFlBQ2YsQ0FBQyxRQUFRLEVBQUVBLFVBQVUsRUFBRSxDQUFDOzs7YUFFbkJTLFlBQVksQ0FBQ1QsWUFDbEIsQ0FBQyxXQUFXLEVBQUVBLFVBQVUsRUFBRSxDQUFDOzs7YUFFdEJVLFVBQVUsQ0FBQ1YsV0FBV1csT0FBT0MsTUFDbEMsQ0FBQyxTQUFTLEVBQUVaLFVBQVUsR0FBRyxFQUFFRixNQUFNZSxXQUFXLENBQUNGLE9BQU8sRUFBRSxFQUFFYixNQUFNZSxXQUFXLENBQUNELEtBQUssQ0FBQyxDQUFDOzs7YUFFNUVFLGFBQWEsQ0FBQ2QsV0FBV0MsUUFDOUJILE1BQU1JLFFBQVEsQ0FBQ0YsV0FBVyxjQUFjQzs7O2FBRW5DYyxXQUFXLENBQUNmLFdBQVdDLFFBQzVCSCxNQUFNSSxRQUFRLENBQUNGLFdBQVcsWUFBWUM7OzthQUVqQ2UsU0FBUyxDQUFDQyxhQUNmLENBQUMsUUFBUSxFQUFFQSxXQUFXQyxHQUFHLENBQUMsQ0FBQ0MsT0FBUyxDQUFDLENBQUMsRUFBRUEsS0FBSyxDQUFDLENBQUMsRUFBRUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDOzs7YUFFekRDLFNBQVMsQ0FBQ3JCLFdBQVdDLFFBQzFCSCxNQUFNSSxRQUFRLENBQUNGLFdBQVcsVUFBVUM7OzthQUUvQnFCLFlBQVksQ0FBQ3RCLFlBQ2xCLENBQUMsV0FBVyxFQUFFQSxVQUFVLEVBQUUsQ0FBQzs7O2FBRXRCdUIsV0FBVyxDQUFDdkIsWUFDakIsQ0FBQyxVQUFVLEVBQUVBLFVBQVUsRUFBRSxDQUFDOzs7YUFFckJ3QixjQUFjLENBQUNDLGFBQ3BCLENBQUMsYUFBYSxFQUFFQSxXQUFXLEVBQUUsQ0FBQzs7O2FBRXpCQyxlQUFlLENBQUNELGFBQ3JCLENBQUMsY0FBYyxFQUFFQSxXQUFXLEVBQUUsQ0FBQzs7O2FBRTFCRSxRQUFRLENBQUNBLFFBQ2QsQ0FBQyxNQUFNLEVBQUVBLE1BQU0sQ0FBQyxDQUFDOzs7YUFFWkMsU0FBUyxDQUFDQSxTQUNmLENBQUMsT0FBTyxFQUFFQSxPQUFPLENBQUMsQ0FBQzs7O2FBRWQxQixXQUFXLENBQUNGLFdBQVc2QixRQUFRNUIsUUFDcENBLGlCQUFpQjZCLFFBQ2IsQ0FBQyxFQUFFRCxPQUFPLEVBQUUsRUFBRTdCLFVBQVUsSUFBSSxFQUFFQyxNQUMzQmlCLEdBQUcsQ0FBQyxDQUFDYSxJQUFNakMsTUFBTWUsV0FBVyxDQUFDa0IsSUFDN0JYLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUNoQixDQUFDLEVBQUVTLE9BQU8sRUFBRSxFQUFFN0IsVUFBVSxJQUFJLEVBQUVGLE1BQU1lLFdBQVcsQ0FBQ1osT0FBTyxFQUFFLENBQUM7OzthQUV6RFksY0FBYyxDQUFDWixRQUNwQixPQUFPQSxVQUFVLFlBQVlBLGlCQUFpQitCLFNBQzFDLENBQUMsQ0FBQyxFQUFFL0IsTUFBTSxDQUFDLENBQUMsR0FDWixDQUFDLEVBQUVBLE1BQU0sQ0FBQzs7QUFDbEI7QUFFQWdDLE9BQU9DLE9BQU8sR0FBR3BDIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3F1ZXJ5LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/role.js":
/*!************************************************!*\
  !*** ./node_modules/node-appwrite/lib/role.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * Helper class to generate role strings for `Permission`.\n */ class Role {\n    static{\n        /**\n     * Grants access to anyone.\n     *\n     * This includes authenticated and unauthenticated users.\n     *\n     * @returns {string}\n     */ this.any = ()=>{\n            return \"any\";\n        };\n    }\n    static{\n        /**\n     * Grants access to a specific user by user ID.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} id \n     * @param {string} status \n     * @returns {string}\n     */ this.user = (id, status = \"\")=>{\n            if (status === \"\") {\n                return `user:${id}`;\n            }\n            return `user:${id}/${status}`;\n        };\n    }\n    static{\n        /**\n     * Grants access to any authenticated or anonymous user.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} status \n     * @returns {string}\n     */ this.users = (status = \"\")=>{\n            if (status === \"\") {\n                return \"users\";\n            }\n            return `users/${status}`;\n        };\n    }\n    static{\n        /**\n     * Grants access to any guest user without a session.\n     *\n     * Authenticated users don't have access to this role.\n     *\n     * @returns {string}\n     */ this.guests = ()=>{\n            return \"guests\";\n        };\n    }\n    static{\n        /**\n     * Grants access to a team by team ID.\n     *\n     * You can optionally pass a role for `role` to target\n     * team members with the specified role.\n     * \n     * @param {string} id \n     * @param {string} role \n     * @returns {string}\n     */ this.team = (id, role = \"\")=>{\n            if (role === \"\") {\n                return \"team:\" + id;\n            }\n            return \"team:\" + id + \"/\" + role;\n        };\n    }\n    static{\n        /**\n     * Grants access to a specific member of a team.\n     *\n     * When the member is removed from the team, they will\n     * no longer have access.\n     * \n     * @param {string} id \n     * @returns {string}\n     */ this.member = (id)=>{\n            return \"member:\" + id;\n        };\n    }\n    static{\n        /**\n     * Grants access to a user with the specified label.\n     *\n     * @param {string} name \n     * @returns  {string}\n     */ this.label = (name)=>{\n            return \"label:\" + name;\n        };\n    }\n}\nmodule.exports = Role;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9yb2xlLmpzPzBkMmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gZ2VuZXJhdGUgcm9sZSBzdHJpbmdzIGZvciBgUGVybWlzc2lvbmAuXG4gKi9cbmNsYXNzIFJvbGUge1xuXG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhbnlvbmUuXG4gICAgICpcbiAgICAgKiBUaGlzIGluY2x1ZGVzIGF1dGhlbnRpY2F0ZWQgYW5kIHVuYXV0aGVudGljYXRlZCB1c2Vycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGFueSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuICdhbnknXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhIHNwZWNpZmljIHVzZXIgYnkgdXNlciBJRC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIHZlcmlmaWVkIG9yIHVudmVyaWZpZWQgZm9yXG4gICAgICogYHN0YXR1c2AgdG8gdGFyZ2V0IHNwZWNpZmljIHR5cGVzIG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdXNlciA9IChpZCwgc3RhdHVzID0gJycpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBgdXNlcjoke2lkfWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHVzZXI6JHtpZH0vJHtzdGF0dXN9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYW55IGF1dGhlbnRpY2F0ZWQgb3IgYW5vbnltb3VzIHVzZXIuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyB2ZXJpZmllZCBvciB1bnZlcmlmaWVkIGZvclxuICAgICAqIGBzdGF0dXNgIHRvIHRhcmdldCBzcGVjaWZpYyB0eXBlcyBvZiB1c2Vycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdXNlcnMgPSAoc3RhdHVzID0gJycpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAndXNlcnMnXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGB1c2Vycy8ke3N0YXR1c31gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhbnkgZ3Vlc3QgdXNlciB3aXRob3V0IGEgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEF1dGhlbnRpY2F0ZWQgdXNlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhpcyByb2xlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ3Vlc3RzID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gJ2d1ZXN0cydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgdGVhbSBieSB0ZWFtIElELlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYSByb2xlIGZvciBgcm9sZWAgdG8gdGFyZ2V0XG4gICAgICogdGVhbSBtZW1iZXJzIHdpdGggdGhlIHNwZWNpZmllZCByb2xlLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZSBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB0ZWFtID0gKGlkLCByb2xlID0gJycpID0+IHtcbiAgICAgICAgaWYgKHJvbGUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RlYW06JyArIGlkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd0ZWFtOicgKyBpZCArICcvJyArIHJvbGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgc3BlY2lmaWMgbWVtYmVyIG9mIGEgdGVhbS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIG1lbWJlciBpcyByZW1vdmVkIGZyb20gdGhlIHRlYW0sIHRoZXkgd2lsbFxuICAgICAqIG5vIGxvbmdlciBoYXZlIGFjY2Vzcy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgbWVtYmVyID0gKGlkKSA9PiB7XG4gICAgICAgIHJldHVybiAnbWVtYmVyOicgKyBpZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICAgICAqIEByZXR1cm5zICB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBsYWJlbCA9IChuYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiAnbGFiZWw6JyArIG5hbWU7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvbGU7Il0sIm5hbWVzIjpbIlJvbGUiLCJhbnkiLCJ1c2VyIiwiaWQiLCJzdGF0dXMiLCJ1c2VycyIsImd1ZXN0cyIsInRlYW0iLCJyb2xlIiwibWVtYmVyIiwibGFiZWwiLCJuYW1lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FDRCxNQUFNQTs7UUFFRjs7Ozs7O0tBTUMsUUFDTUMsTUFBTTtZQUNULE9BQU87UUFDWDs7O1FBRUE7Ozs7Ozs7OztLQVNDLFFBQ01DLE9BQU8sQ0FBQ0MsSUFBSUMsU0FBUyxFQUFFO1lBQzFCLElBQUlBLFdBQVcsSUFBSTtnQkFDZixPQUFPLENBQUMsS0FBSyxFQUFFRCxHQUFHLENBQUM7WUFDdkI7WUFDQSxPQUFPLENBQUMsS0FBSyxFQUFFQSxHQUFHLENBQUMsRUFBRUMsT0FBTyxDQUFDO1FBQ2pDOzs7UUFFQTs7Ozs7Ozs7S0FRQyxRQUNNQyxRQUFRLENBQUNELFNBQVMsRUFBRTtZQUN2QixJQUFJQSxXQUFXLElBQUk7Z0JBQ2YsT0FBTztZQUNYO1lBQ0EsT0FBTyxDQUFDLE1BQU0sRUFBRUEsT0FBTyxDQUFDO1FBQzVCOzs7UUFFQTs7Ozs7O0tBTUMsUUFDTUUsU0FBUztZQUNaLE9BQU87UUFDWDs7O1FBRUE7Ozs7Ozs7OztLQVNDLFFBQ01DLE9BQU8sQ0FBQ0osSUFBSUssT0FBTyxFQUFFO1lBQ3hCLElBQUlBLFNBQVMsSUFBSTtnQkFDYixPQUFPLFVBQVVMO1lBQ3JCO1lBQ0EsT0FBTyxVQUFVQSxLQUFLLE1BQU1LO1FBQ2hDOzs7UUFFQTs7Ozs7Ozs7S0FRQyxRQUNNQyxTQUFTLENBQUNOO1lBQ2IsT0FBTyxZQUFZQTtRQUN2Qjs7O1FBRUE7Ozs7O0tBS0MsUUFDTU8sUUFBUSxDQUFDQztZQUNaLE9BQU8sV0FBV0E7UUFDdEI7O0FBQ0o7QUFFQUMsT0FBT0MsT0FBTyxHQUFHYiIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9yb2xlLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/role.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/service.js":
/*!***************************************************!*\
  !*** ./node_modules/node-appwrite/lib/service.js ***!
  \***************************************************/
/***/ ((module) => {

eval("class Service {\n    /**\n     * @param client\n     */ constructor(client){\n        this.client = client;\n    }\n}\nmodule.exports = Service;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlLmpzP2YxMDEiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNsaWVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTsiXSwibmFtZXMiOlsiU2VydmljZSIsImNvbnN0cnVjdG9yIiwiY2xpZW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUE7SUFDRjs7S0FFQyxHQUNEQyxZQUFZQyxNQUFNLENBQUU7UUFDaEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0lBQ2xCO0FBQ0o7QUFFQUMsT0FBT0MsT0FBTyxHQUFHSiIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/service.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/account.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/account.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Account extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * Get account\n     *\n     * Get the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async get() {\n        const apiPath = \"/account\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update email\n     *\n     * Update currently logged in user account email address. After changing user\n     * address, the user confirmation status will get reset. A new confirmation\n     * email is not sent automatically however you can use the send confirmation\n     * email endpoint again to send the confirmation email. For security measures,\n     * user password is required to complete this request.\n     * This endpoint can also be used to convert an anonymous account to a normal\n     * one, by passing an email address and a new password.\n     * \n     *\n     * @param {string} email\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateEmail(email, password) {\n        const apiPath = \"/account/email\";\n        let payload = {};\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List Identities\n     *\n     * Get the list of identities for the currently logged in user.\n     *\n     * @param {string} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listIdentities(queries) {\n        const apiPath = \"/account/identities\";\n        let payload = {};\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete Identity\n     *\n     * Delete an identity by its unique ID.\n     *\n     * @param {string} identityId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteIdentity(identityId) {\n        const apiPath = \"/account/identities/{identityId}\".replace(\"{identityId}\", identityId);\n        let payload = {};\n        if (typeof identityId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"identityId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List logs\n     *\n     * Get the list of latest security activity logs for the currently logged in\n     * user. Each log returns user IP address, location and date and time of log.\n     *\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listLogs(queries) {\n        const apiPath = \"/account/logs\";\n        let payload = {};\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update name\n     *\n     * Update currently logged in user account name.\n     *\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateName(name) {\n        const apiPath = \"/account/name\";\n        let payload = {};\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update password\n     *\n     * Update currently logged in user password. For validation, user is required\n     * to pass in the new password, and the old password. For users created with\n     * OAuth, Team Invites and Magic URL, oldPassword is optional.\n     *\n     * @param {string} password\n     * @param {string} oldPassword\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updatePassword(password, oldPassword) {\n        const apiPath = \"/account/password\";\n        let payload = {};\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof oldPassword !== \"undefined\") {\n            payload[\"oldPassword\"] = oldPassword;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update phone\n     *\n     * Update the currently logged in user's phone number. After updating the\n     * phone number, the phone verification status will be reset. A confirmation\n     * SMS is not sent automatically, however you can use the [POST\n     * /account/verification/phone](https://appwrite.io/docs/references/cloud/client-web/account#createPhoneVerification)\n     * endpoint to send a confirmation SMS.\n     *\n     * @param {string} phone\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updatePhone(phone, password) {\n        const apiPath = \"/account/phone\";\n        let payload = {};\n        if (typeof phone === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof phone !== \"undefined\") {\n            payload[\"phone\"] = phone;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get account preferences\n     *\n     * Get the preferences as a key-value object for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getPrefs() {\n        const apiPath = \"/account/prefs\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update preferences\n     *\n     * Update currently logged in user account preferences. The object you pass is\n     * stored as is, and replaces any previous value. The maximum allowed prefs\n     * size is 64kB and throws error if exceeded.\n     *\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updatePrefs(prefs) {\n        const apiPath = \"/account/prefs\";\n        let payload = {};\n        if (typeof prefs === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n        if (typeof prefs !== \"undefined\") {\n            payload[\"prefs\"] = prefs;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create password recovery\n     *\n     * Sends the user an email with a temporary secret key for password reset.\n     * When the user clicks the confirmation link he is redirected back to your\n     * app password reset URL with the secret key and email address values\n     * attached to the URL query string. Use the query string params to submit a\n     * request to the [PUT\n     * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#updateRecovery)\n     * endpoint to complete the process. The verification link sent to the user's\n     * email address is valid for 1 hour.\n     *\n     * @param {string} email\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createRecovery(email, url) {\n        const apiPath = \"/account/recovery\";\n        let payload = {};\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof url === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof url !== \"undefined\") {\n            payload[\"url\"] = url;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create password recovery (confirmation)\n     *\n     * Use this endpoint to complete the user account password reset. Both the\n     * **userId** and **secret** arguments will be passed as query parameters to\n     * the redirect URL you have provided when sending your request to the [POST\n     * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#createRecovery)\n     * endpoint.\n     * \n     * Please note that in order to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n     * the only valid redirect URLs are the ones from domains you have set when\n     * adding your platforms in the console interface.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @param {string} password\n     * @param {string} passwordAgain\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateRecovery(userId, secret, password, passwordAgain) {\n        const apiPath = \"/account/recovery\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof passwordAgain === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"passwordAgain\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof secret !== \"undefined\") {\n            payload[\"secret\"] = secret;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof passwordAgain !== \"undefined\") {\n            payload[\"passwordAgain\"] = passwordAgain;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List sessions\n     *\n     * Get the list of active sessions across different devices for the currently\n     * logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listSessions() {\n        const apiPath = \"/account/sessions\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete sessions\n     *\n     * Delete all sessions from the user account and remove any sessions cookies\n     * from the end client.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteSessions() {\n        const apiPath = \"/account/sessions\";\n        let payload = {};\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get session\n     *\n     * Use this endpoint to get a logged in user's session using a Session ID.\n     * Inputting 'current' will return the current session being used.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getSession(sessionId) {\n        const apiPath = \"/account/sessions/{sessionId}\".replace(\"{sessionId}\", sessionId);\n        let payload = {};\n        if (typeof sessionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update OAuth session (refresh tokens)\n     *\n     * Access tokens have limited lifespan and expire to mitigate security risks.\n     * If session was created using an OAuth provider, this route can be used to\n     * \"refresh\" the access token.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateSession(sessionId) {\n        const apiPath = \"/account/sessions/{sessionId}\".replace(\"{sessionId}\", sessionId);\n        let payload = {};\n        if (typeof sessionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete session\n     *\n     * Logout the user. Use 'current' as the session ID to logout on this device,\n     * use a session ID to logout on another device. If you're looking to logout\n     * the user on all devices, use [Delete\n     * Sessions](https://appwrite.io/docs/references/cloud/client-web/account#deleteSessions)\n     * instead.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteSession(sessionId) {\n        const apiPath = \"/account/sessions/{sessionId}\".replace(\"{sessionId}\", sessionId);\n        let payload = {};\n        if (typeof sessionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update status\n     *\n     * Block the currently logged in user account. Behind the scene, the user\n     * record is not deleted but permanently blocked from any access. To\n     * completely delete a user, use the Users API instead.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateStatus() {\n        const apiPath = \"/account/status\";\n        let payload = {};\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create email verification\n     *\n     * Use this endpoint to send a verification message to your user email address\n     * to confirm they are the valid owners of that address. Both the **userId**\n     * and **secret** arguments will be passed as query parameters to the URL you\n     * have provided to be attached to the verification email. The provided URL\n     * should redirect the user back to your app and allow you to complete the\n     * verification process by verifying both the **userId** and **secret**\n     * parameters. Learn more about how to [complete the verification\n     * process](https://appwrite.io/docs/references/cloud/client-web/account#updateVerification).\n     * The verification link sent to the user's email address is valid for 7 days.\n     * \n     * Please note that in order to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md),\n     * the only valid redirect URLs are the ones from domains you have set when\n     * adding your platforms in the console interface.\n     * \n     *\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createVerification(url) {\n        const apiPath = \"/account/verification\";\n        let payload = {};\n        if (typeof url === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        if (typeof url !== \"undefined\") {\n            payload[\"url\"] = url;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create email verification (confirmation)\n     *\n     * Use this endpoint to complete the user email verification process. Use both\n     * the **userId** and **secret** parameters that were attached to your app URL\n     * to verify the user email ownership. If confirmed this route will return a\n     * 200 status code.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateVerification(userId, secret) {\n        const apiPath = \"/account/verification\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof secret !== \"undefined\") {\n            payload[\"secret\"] = secret;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create phone verification\n     *\n     * Use this endpoint to send a verification SMS to the currently logged in\n     * user. This endpoint is meant for use after updating a user's phone number\n     * using the\n     * [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone)\n     * endpoint. Learn more about how to [complete the verification\n     * process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification).\n     * The verification code sent to the user's phone number is valid for 15\n     * minutes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createPhoneVerification() {\n        const apiPath = \"/account/verification/phone\";\n        let payload = {};\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create phone verification (confirmation)\n     *\n     * Use this endpoint to complete the user phone verification process. Use the\n     * **userId** and **secret** that were sent to your user's phone number to\n     * verify the user email ownership. If confirmed this route will return a 200\n     * status code.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updatePhoneVerification(userId, secret) {\n        const apiPath = \"/account/verification/phone\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof secret !== \"undefined\") {\n            payload[\"secret\"] = secret;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n}\nmodule.exports = Account;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvYWNjb3VudC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUN4QixNQUFNQyxvQkFBb0JELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1JLFNBQVNKLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUssU0FBUyxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1NLEtBQUtOLG1CQUFPQSxDQUFDO0FBRW5CLE1BQU1PLGdCQUFnQlI7SUFFakJTLFlBQVlMLE1BQU0sQ0FDbEI7UUFDRyxLQUFLLENBQUNBO0lBQ1Q7SUFHRDs7Ozs7OztLQU9DLEdBQ0QsTUFBTU0sTUFBTTtRQUNSLE1BQU1DLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBRWYsT0FBTyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JDLEdBQ0QsTUFBTUUsWUFBWUMsS0FBSyxFQUFFQyxRQUFRLEVBQUU7UUFDL0IsTUFBTUwsVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLFVBQVUsYUFBYTtZQUM5QixNQUFNLElBQUliLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT2MsYUFBYSxhQUFhO1lBQ2pDLE1BQU0sSUFBSWQsa0JBQWtCO1FBQ2hDO1FBR0EsSUFBSSxPQUFPYSxVQUFVLGFBQWE7WUFDOUJILE9BQU8sQ0FBQyxRQUFRLEdBQUdHO1FBQ3ZCO1FBRUEsSUFBSSxPQUFPQyxhQUFhLGFBQWE7WUFDakNKLE9BQU8sQ0FBQyxXQUFXLEdBQUdJO1FBQzFCO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FB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QUFDaEMsTUFBTSxDQUFDUyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7Ozs7OztLQWNDLEdBQ0QsTUFBTW1DLDBCQUEwQjtRQUM1QixNQUFNcEMsVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFFZixPQUFPLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNTLElBQUksQ0FBQyxRQUFRRixTQUFTO1lBQzNDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0QsTUFBTW9DLHdCQUF3QmIsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDMUMsTUFBTXpCLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPdUIsV0FBVyxhQUFhO1lBQy9CLE1BQU0sSUFBSWpDLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT2tDLFdBQVcsYUFBYTtZQUMvQixNQUFNLElBQUlsQyxrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU9pQyxXQUFXLGFBQWE7WUFDL0J2QixPQUFPLENBQUMsU0FBUyxHQUFHdUI7UUFDeEI7UUFFQSxJQUFJLE9BQU9DLFdBQVcsYUFBYTtZQUMvQnhCLE9BQU8sQ0FBQyxTQUFTLEdBQUd3QjtRQUN4QjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUNoQyxNQUFNLENBQUNTLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0FBQ0o7QUFFQXFDLE9BQU9DLE9BQU8sR0FBRzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja25lc3QvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvYWNjb3VudC5qcz85YWU1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxuY2xhc3MgQWNjb3VudCBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldCBhY2NvdW50XG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldCgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlbWFpbFxuICAgICAqXG4gICAgICogVXBkYXRlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciBhY2NvdW50IGVtYWlsIGFkZHJlc3MuIEFmdGVyIGNoYW5naW5nIHVzZXJcbiAgICAgKiBhZGRyZXNzLCB0aGUgdXNlciBjb25maXJtYXRpb24gc3RhdHVzIHdpbGwgZ2V0IHJlc2V0LiBBIG5ldyBjb25maXJtYXRpb25cbiAgICAgKiBlbWFpbCBpcyBub3Qgc2VudCBhdXRvbWF0aWNhbGx5IGhvd2V2ZXIgeW91IGNhbiB1c2UgdGhlIHNlbmQgY29uZmlybWF0aW9uXG4gICAgICogZW1haWwgZW5kcG9pbnQgYWdhaW4gdG8gc2VuZCB0aGUgY29uZmlybWF0aW9uIGVtYWlsLiBGb3Igc2VjdXJpdHkgbWVhc3VyZXMsXG4gICAgICogdXNlciBwYXNzd29yZCBpcyByZXF1aXJlZCB0byBjb21wbGV0ZSB0aGlzIHJlcXVlc3QuXG4gICAgICogVGhpcyBlbmRwb2ludCBjYW4gYWxzbyBiZSB1c2VkIHRvIGNvbnZlcnQgYW4gYW5vbnltb3VzIGFjY291bnQgdG8gYSBub3JtYWxcbiAgICAgKiBvbmUsIGJ5IHBhc3NpbmcgYW4gZW1haWwgYWRkcmVzcyBhbmQgYSBuZXcgcGFzc3dvcmQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVFbWFpbChlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9lbWFpbCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IElkZW50aXRpZXNcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBpZGVudGl0aWVzIGZvciB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0SWRlbnRpdGllcyhxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvaWRlbnRpdGllcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgSWRlbnRpdHlcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhbiBpZGVudGl0eSBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aXR5SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVJZGVudGl0eShpZGVudGl0eUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvaWRlbnRpdGllcy97aWRlbnRpdHlJZH0nLnJlcGxhY2UoJ3tpZGVudGl0eUlkfScsIGlkZW50aXR5SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGlkZW50aXR5SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImlkZW50aXR5SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBsb2dzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgbGF0ZXN0IHNlY3VyaXR5IGFjdGl2aXR5IGxvZ3MgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluXG4gICAgICogdXNlci4gRWFjaCBsb2cgcmV0dXJucyB1c2VyIElQIGFkZHJlc3MsIGxvY2F0aW9uIGFuZCBkYXRlIGFuZCB0aW1lIG9mIGxvZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0TG9ncyhxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbG9ncyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbmFtZVxuICAgICAqXG4gICAgICogVXBkYXRlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciBhY2NvdW50IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L25hbWUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBVcGRhdGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIHBhc3N3b3JkLiBGb3IgdmFsaWRhdGlvbiwgdXNlciBpcyByZXF1aXJlZFxuICAgICAqIHRvIHBhc3MgaW4gdGhlIG5ldyBwYXNzd29yZCwgYW5kIHRoZSBvbGQgcGFzc3dvcmQuIEZvciB1c2VycyBjcmVhdGVkIHdpdGhcbiAgICAgKiBPQXV0aCwgVGVhbSBJbnZpdGVzIGFuZCBNYWdpYyBVUkwsIG9sZFBhc3N3b3JkIGlzIG9wdGlvbmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUGFzc3dvcmQocGFzc3dvcmQsIG9sZFBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcGFzc3dvcmQnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9sZFBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb2xkUGFzc3dvcmQnXSA9IG9sZFBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBob25lXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlcidzIHBob25lIG51bWJlci4gQWZ0ZXIgdXBkYXRpbmcgdGhlXG4gICAgICogcGhvbmUgbnVtYmVyLCB0aGUgcGhvbmUgdmVyaWZpY2F0aW9uIHN0YXR1cyB3aWxsIGJlIHJlc2V0LiBBIGNvbmZpcm1hdGlvblxuICAgICAqIFNNUyBpcyBub3Qgc2VudCBhdXRvbWF0aWNhbGx5LCBob3dldmVyIHlvdSBjYW4gdXNlIHRoZSBbUE9TVFxuICAgICAqIC9hY2NvdW50L3ZlcmlmaWNhdGlvbi9waG9uZV0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZVBob25lVmVyaWZpY2F0aW9uKVxuICAgICAqIGVuZHBvaW50IHRvIHNlbmQgYSBjb25maXJtYXRpb24gU01TLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBob25lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUGhvbmUocGhvbmUsIHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcGhvbmUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHBob25lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwaG9uZVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaG9uZSddID0gcGhvbmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFjY291bnQgcHJlZmVyZW5jZXNcbiAgICAgKlxuICAgICAqIEdldCB0aGUgcHJlZmVyZW5jZXMgYXMgYSBrZXktdmFsdWUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJlZnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcHJlZnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcHJlZmVyZW5jZXNcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgYWNjb3VudCBwcmVmZXJlbmNlcy4gVGhlIG9iamVjdCB5b3UgcGFzcyBpc1xuICAgICAqIHN0b3JlZCBhcyBpcywgYW5kIHJlcGxhY2VzIGFueSBwcmV2aW91cyB2YWx1ZS4gVGhlIG1heGltdW0gYWxsb3dlZCBwcmVmc1xuICAgICAqIHNpemUgaXMgNjRrQiBhbmQgdGhyb3dzIGVycm9yIGlmIGV4Y2VlZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZWZzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUHJlZnMocHJlZnMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9wcmVmcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByZWZzXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3ByZWZzJ10gPSBwcmVmcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwYXNzd29yZCByZWNvdmVyeVxuICAgICAqXG4gICAgICogU2VuZHMgdGhlIHVzZXIgYW4gZW1haWwgd2l0aCBhIHRlbXBvcmFyeSBzZWNyZXQga2V5IGZvciBwYXNzd29yZCByZXNldC5cbiAgICAgKiBXaGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgY29uZmlybWF0aW9uIGxpbmsgaGUgaXMgcmVkaXJlY3RlZCBiYWNrIHRvIHlvdXJcbiAgICAgKiBhcHAgcGFzc3dvcmQgcmVzZXQgVVJMIHdpdGggdGhlIHNlY3JldCBrZXkgYW5kIGVtYWlsIGFkZHJlc3MgdmFsdWVzXG4gICAgICogYXR0YWNoZWQgdG8gdGhlIFVSTCBxdWVyeSBzdHJpbmcuIFVzZSB0aGUgcXVlcnkgc3RyaW5nIHBhcmFtcyB0byBzdWJtaXQgYVxuICAgICAqIHJlcXVlc3QgdG8gdGhlIFtQVVRcbiAgICAgKiAvYWNjb3VudC9yZWNvdmVyeV0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I3VwZGF0ZVJlY292ZXJ5KVxuICAgICAqIGVuZHBvaW50IHRvIGNvbXBsZXRlIHRoZSBwcm9jZXNzLiBUaGUgdmVyaWZpY2F0aW9uIGxpbmsgc2VudCB0byB0aGUgdXNlcidzXG4gICAgICogZW1haWwgYWRkcmVzcyBpcyB2YWxpZCBmb3IgMSBob3VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVJlY292ZXJ5KGVtYWlsLCB1cmwpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9yZWNvdmVyeSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhc3N3b3JkIHJlY292ZXJ5IChjb25maXJtYXRpb24pXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgdXNlciBhY2NvdW50IHBhc3N3b3JkIHJlc2V0LiBCb3RoIHRoZVxuICAgICAqICoqdXNlcklkKiogYW5kICoqc2VjcmV0KiogYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIHF1ZXJ5IHBhcmFtZXRlcnMgdG9cbiAgICAgKiB0aGUgcmVkaXJlY3QgVVJMIHlvdSBoYXZlIHByb3ZpZGVkIHdoZW4gc2VuZGluZyB5b3VyIHJlcXVlc3QgdG8gdGhlIFtQT1NUXG4gICAgICogL2FjY291bnQvcmVjb3ZlcnldKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVSZWNvdmVyeSlcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKiBcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGluIG9yZGVyIHRvIGF2b2lkIGEgW1JlZGlyZWN0XG4gICAgICogQXR0YWNrXShodHRwczovL2dpdGh1Yi5jb20vT1dBU1AvQ2hlYXRTaGVldFNlcmllcy9ibG9iL21hc3Rlci9jaGVhdHNoZWV0cy9VbnZhbGlkYXRlZF9SZWRpcmVjdHNfYW5kX0ZvcndhcmRzX0NoZWF0X1NoZWV0Lm1kKVxuICAgICAqIHRoZSBvbmx5IHZhbGlkIHJlZGlyZWN0IFVSTHMgYXJlIHRoZSBvbmVzIGZyb20gZG9tYWlucyB5b3UgaGF2ZSBzZXQgd2hlblxuICAgICAqIGFkZGluZyB5b3VyIHBsYXRmb3JtcyBpbiB0aGUgY29uc29sZSBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZEFnYWluXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUmVjb3ZlcnkodXNlcklkLCBzZWNyZXQsIHBhc3N3b3JkLCBwYXNzd29yZEFnYWluKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcmVjb3ZlcnknO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZEFnYWluID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZEFnYWluXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZEFnYWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmRBZ2FpbiddID0gcGFzc3dvcmRBZ2FpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHNlc3Npb25zXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWN0aXZlIHNlc3Npb25zIGFjcm9zcyBkaWZmZXJlbnQgZGV2aWNlcyBmb3IgdGhlIGN1cnJlbnRseVxuICAgICAqIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdFNlc3Npb25zKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHNlc3Npb25zXG4gICAgICpcbiAgICAgKiBEZWxldGUgYWxsIHNlc3Npb25zIGZyb20gdGhlIHVzZXIgYWNjb3VudCBhbmQgcmVtb3ZlIGFueSBzZXNzaW9ucyBjb29raWVzXG4gICAgICogZnJvbSB0aGUgZW5kIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVNlc3Npb25zKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlc3Npb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGdldCBhIGxvZ2dlZCBpbiB1c2VyJ3Mgc2Vzc2lvbiB1c2luZyBhIFNlc3Npb24gSUQuXG4gICAgICogSW5wdXR0aW5nICdjdXJyZW50JyB3aWxsIHJldHVybiB0aGUgY3VycmVudCBzZXNzaW9uIGJlaW5nIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2Vzc2lvbihzZXNzaW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2Vzc2lvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBPQXV0aCBzZXNzaW9uIChyZWZyZXNoIHRva2VucylcbiAgICAgKlxuICAgICAqIEFjY2VzcyB0b2tlbnMgaGF2ZSBsaW1pdGVkIGxpZmVzcGFuIGFuZCBleHBpcmUgdG8gbWl0aWdhdGUgc2VjdXJpdHkgcmlza3MuXG4gICAgICogSWYgc2Vzc2lvbiB3YXMgY3JlYXRlZCB1c2luZyBhbiBPQXV0aCBwcm92aWRlciwgdGhpcyByb3V0ZSBjYW4gYmUgdXNlZCB0b1xuICAgICAqIFwicmVmcmVzaFwiIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU2Vzc2lvbihzZXNzaW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2Vzc2lvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHNlc3Npb25cbiAgICAgKlxuICAgICAqIExvZ291dCB0aGUgdXNlci4gVXNlICdjdXJyZW50JyBhcyB0aGUgc2Vzc2lvbiBJRCB0byBsb2dvdXQgb24gdGhpcyBkZXZpY2UsXG4gICAgICogdXNlIGEgc2Vzc2lvbiBJRCB0byBsb2dvdXQgb24gYW5vdGhlciBkZXZpY2UuIElmIHlvdSdyZSBsb29raW5nIHRvIGxvZ291dFxuICAgICAqIHRoZSB1c2VyIG9uIGFsbCBkZXZpY2VzLCB1c2UgW0RlbGV0ZVxuICAgICAqIFNlc3Npb25zXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjZGVsZXRlU2Vzc2lvbnMpXG4gICAgICogaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVTZXNzaW9uKHNlc3Npb25JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3tzZXNzaW9uSWR9Jy5yZXBsYWNlKCd7c2Vzc2lvbklkfScsIHNlc3Npb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZXNzaW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN0YXR1c1xuICAgICAqXG4gICAgICogQmxvY2sgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciBhY2NvdW50LiBCZWhpbmQgdGhlIHNjZW5lLCB0aGUgdXNlclxuICAgICAqIHJlY29yZCBpcyBub3QgZGVsZXRlZCBidXQgcGVybWFuZW50bHkgYmxvY2tlZCBmcm9tIGFueSBhY2Nlc3MuIFRvXG4gICAgICogY29tcGxldGVseSBkZWxldGUgYSB1c2VyLCB1c2UgdGhlIFVzZXJzIEFQSSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU3RhdHVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3N0YXR1cyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVtYWlsIHZlcmlmaWNhdGlvblxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gc2VuZCBhIHZlcmlmaWNhdGlvbiBtZXNzYWdlIHRvIHlvdXIgdXNlciBlbWFpbCBhZGRyZXNzXG4gICAgICogdG8gY29uZmlybSB0aGV5IGFyZSB0aGUgdmFsaWQgb3duZXJzIG9mIHRoYXQgYWRkcmVzcy4gQm90aCB0aGUgKip1c2VySWQqKlxuICAgICAqIGFuZCAqKnNlY3JldCoqIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCBhcyBxdWVyeSBwYXJhbWV0ZXJzIHRvIHRoZSBVUkwgeW91XG4gICAgICogaGF2ZSBwcm92aWRlZCB0byBiZSBhdHRhY2hlZCB0byB0aGUgdmVyaWZpY2F0aW9uIGVtYWlsLiBUaGUgcHJvdmlkZWQgVVJMXG4gICAgICogc2hvdWxkIHJlZGlyZWN0IHRoZSB1c2VyIGJhY2sgdG8geW91ciBhcHAgYW5kIGFsbG93IHlvdSB0byBjb21wbGV0ZSB0aGVcbiAgICAgKiB2ZXJpZmljYXRpb24gcHJvY2VzcyBieSB2ZXJpZnlpbmcgYm90aCB0aGUgKip1c2VySWQqKiBhbmQgKipzZWNyZXQqKlxuICAgICAqIHBhcmFtZXRlcnMuIExlYXJuIG1vcmUgYWJvdXQgaG93IHRvIFtjb21wbGV0ZSB0aGUgdmVyaWZpY2F0aW9uXG4gICAgICogcHJvY2Vzc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I3VwZGF0ZVZlcmlmaWNhdGlvbikuXG4gICAgICogVGhlIHZlcmlmaWNhdGlvbiBsaW5rIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzIGlzIHZhbGlkIGZvciA3IGRheXMuXG4gICAgICogXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCBpbiBvcmRlciB0byBhdm9pZCBhIFtSZWRpcmVjdFxuICAgICAqIEF0dGFja10oaHR0cHM6Ly9naXRodWIuY29tL09XQVNQL0NoZWF0U2hlZXRTZXJpZXMvYmxvYi9tYXN0ZXIvY2hlYXRzaGVldHMvVW52YWxpZGF0ZWRfUmVkaXJlY3RzX2FuZF9Gb3J3YXJkc19DaGVhdF9TaGVldC5tZCksXG4gICAgICogdGhlIG9ubHkgdmFsaWQgcmVkaXJlY3QgVVJMcyBhcmUgdGhlIG9uZXMgZnJvbSBkb21haW5zIHlvdSBoYXZlIHNldCB3aGVuXG4gICAgICogYWRkaW5nIHlvdXIgcGxhdGZvcm1zIGluIHRoZSBjb25zb2xlIGludGVyZmFjZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVWZXJpZmljYXRpb24odXJsKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9uJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVybFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbWFpbCB2ZXJpZmljYXRpb24gKGNvbmZpcm1hdGlvbilcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGNvbXBsZXRlIHRoZSB1c2VyIGVtYWlsIHZlcmlmaWNhdGlvbiBwcm9jZXNzLiBVc2UgYm90aFxuICAgICAqIHRoZSAqKnVzZXJJZCoqIGFuZCAqKnNlY3JldCoqIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIGF0dGFjaGVkIHRvIHlvdXIgYXBwIFVSTFxuICAgICAqIHRvIHZlcmlmeSB0aGUgdXNlciBlbWFpbCBvd25lcnNoaXAuIElmIGNvbmZpcm1lZCB0aGlzIHJvdXRlIHdpbGwgcmV0dXJuIGFcbiAgICAgKiAyMDAgc3RhdHVzIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVZlcmlmaWNhdGlvbih1c2VySWQsIHNlY3JldCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ZlcmlmaWNhdGlvbic7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwaG9uZSB2ZXJpZmljYXRpb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIHNlbmQgYSB2ZXJpZmljYXRpb24gU01TIHRvIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluXG4gICAgICogdXNlci4gVGhpcyBlbmRwb2ludCBpcyBtZWFudCBmb3IgdXNlIGFmdGVyIHVwZGF0aW5nIGEgdXNlcidzIHBob25lIG51bWJlclxuICAgICAqIHVzaW5nIHRoZVxuICAgICAqIFthY2NvdW50VXBkYXRlUGhvbmVdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVQaG9uZSlcbiAgICAgKiBlbmRwb2ludC4gTGVhcm4gbW9yZSBhYm91dCBob3cgdG8gW2NvbXBsZXRlIHRoZSB2ZXJpZmljYXRpb25cbiAgICAgKiBwcm9jZXNzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlUGhvbmVWZXJpZmljYXRpb24pLlxuICAgICAqIFRoZSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyIGlzIHZhbGlkIGZvciAxNVxuICAgICAqIG1pbnV0ZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQaG9uZVZlcmlmaWNhdGlvbigpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb24vcGhvbmUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBob25lIHZlcmlmaWNhdGlvbiAoY29uZmlybWF0aW9uKVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY29tcGxldGUgdGhlIHVzZXIgcGhvbmUgdmVyaWZpY2F0aW9uIHByb2Nlc3MuIFVzZSB0aGVcbiAgICAgKiAqKnVzZXJJZCoqIGFuZCAqKnNlY3JldCoqIHRoYXQgd2VyZSBzZW50IHRvIHlvdXIgdXNlcidzIHBob25lIG51bWJlciB0b1xuICAgICAqIHZlcmlmeSB0aGUgdXNlciBlbWFpbCBvd25lcnNoaXAuIElmIGNvbmZpcm1lZCB0aGlzIHJvdXRlIHdpbGwgcmV0dXJuIGEgMjAwXG4gICAgICogc3RhdHVzIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVBob25lVmVyaWZpY2F0aW9uKHVzZXJJZCwgc2VjcmV0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9uL3Bob25lJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFjY291bnQ7XG4iXSwibmFtZXMiOlsiU2VydmljZSIsInJlcXVpcmUiLCJBcHB3cml0ZUV4Y2VwdGlvbiIsIklucHV0RmlsZSIsImNsaWVudCIsIlN0cmVhbSIsInByb21pc2lmeSIsImZzIiwiQWNjb3VudCIsImNvbnN0cnVjdG9yIiwiZ2V0IiwiYXBpUGF0aCIsInBheWxvYWQiLCJjYWxsIiwidXBkYXRlRW1haWwiLCJlbWFpbCIsInBhc3N3b3JkIiwibGlzdElkZW50aXRpZXMiLCJxdWVyaWVzIiwiZGVsZXRlSWRlbnRpdHkiLCJpZGVudGl0eUlkIiwicmVwbGFjZSIsImxpc3RMb2dzIiwidXBkYXRlTmFtZSIsIm5hbWUiLCJ1cGRhdGVQYXNzd29yZCIsIm9sZFBhc3N3b3JkIiwidXBkYXRlUGhvbmUiLCJwaG9uZSIsImdldFByZWZzIiwidXBkYXRlUHJlZnMiLCJwcmVmcyIsImNyZWF0ZVJlY292ZXJ5IiwidXJsIiwidXBkYXRlUmVjb3ZlcnkiLCJ1c2VySWQiLCJzZWNyZXQiLCJwYXNzd29yZEFnYWluIiwibGlzdFNlc3Npb25zIiwiZGVsZXRlU2Vzc2lvbnMiLCJnZXRTZXNzaW9uIiwic2Vzc2lvbklkIiwidXBkYXRlU2Vzc2lvbiIsImRlbGV0ZVNlc3Npb24iLCJ1cGRhdGVTdGF0dXMiLCJjcmVhdGVWZXJpZmljYXRpb24iLCJ1cGRhdGVWZXJpZmljYXRpb24iLCJjcmVhdGVQaG9uZVZlcmlmaWNhdGlvbiIsInVwZGF0ZVBob25lVmVyaWZpY2F0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/account.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/avatars.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/avatars.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Avatars extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * Get browser icon\n     *\n     * You can use this endpoint to show different browser icons to your users.\n     * The code argument receives the browser code as it appears in your user [GET\n     * /account/sessions](https://appwrite.io/docs/references/cloud/client-web/account#getSessions)\n     * endpoint. Use width, height and quality arguments to change the output\n     * settings.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     *\n     * @param {string} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getBrowser(code, width, height, quality) {\n        const apiPath = \"/avatars/browsers/{code}\".replace(\"{code}\", code);\n        let payload = {};\n        if (typeof code === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        if (typeof width !== \"undefined\") {\n            payload[\"width\"] = width;\n        }\n        if (typeof height !== \"undefined\") {\n            payload[\"height\"] = height;\n        }\n        if (typeof quality !== \"undefined\") {\n            payload[\"quality\"] = quality;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n    /**\n     * Get credit card icon\n     *\n     * The credit card endpoint will return you the icon of the credit card\n     * provider you need. Use width, height and quality arguments to change the\n     * output settings.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     * \n     *\n     * @param {string} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getCreditCard(code, width, height, quality) {\n        const apiPath = \"/avatars/credit-cards/{code}\".replace(\"{code}\", code);\n        let payload = {};\n        if (typeof code === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        if (typeof width !== \"undefined\") {\n            payload[\"width\"] = width;\n        }\n        if (typeof height !== \"undefined\") {\n            payload[\"height\"] = height;\n        }\n        if (typeof quality !== \"undefined\") {\n            payload[\"quality\"] = quality;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n    /**\n     * Get favicon\n     *\n     * Use this endpoint to fetch the favorite icon (AKA favicon) of any remote\n     * website URL.\n     * \n     *\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getFavicon(url) {\n        const apiPath = \"/avatars/favicon\";\n        let payload = {};\n        if (typeof url === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        if (typeof url !== \"undefined\") {\n            payload[\"url\"] = url;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n    /**\n     * Get country flag\n     *\n     * You can use this endpoint to show different country flags icons to your\n     * users. The code argument receives the 2 letter country code. Use width,\n     * height and quality arguments to change the output settings. Country codes\n     * follow the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) standard.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     * \n     *\n     * @param {string} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getFlag(code, width, height, quality) {\n        const apiPath = \"/avatars/flags/{code}\".replace(\"{code}\", code);\n        let payload = {};\n        if (typeof code === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        if (typeof width !== \"undefined\") {\n            payload[\"width\"] = width;\n        }\n        if (typeof height !== \"undefined\") {\n            payload[\"height\"] = height;\n        }\n        if (typeof quality !== \"undefined\") {\n            payload[\"quality\"] = quality;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n    /**\n     * Get image from URL\n     *\n     * Use this endpoint to fetch a remote image URL and crop it to any image size\n     * you want. This endpoint is very useful if you need to crop and display\n     * remote images in your app or in case you want to make sure a 3rd party\n     * image is properly served using a TLS protocol.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 400x400px.\n     * \n     *\n     * @param {string} url\n     * @param {number} width\n     * @param {number} height\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getImage(url, width, height) {\n        const apiPath = \"/avatars/image\";\n        let payload = {};\n        if (typeof url === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        if (typeof url !== \"undefined\") {\n            payload[\"url\"] = url;\n        }\n        if (typeof width !== \"undefined\") {\n            payload[\"width\"] = width;\n        }\n        if (typeof height !== \"undefined\") {\n            payload[\"height\"] = height;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n    /**\n     * Get user initials\n     *\n     * Use this endpoint to show your user initials avatar icon on your website or\n     * app. By default, this route will try to print your logged-in user name or\n     * email initials. You can also overwrite the user name if you pass the 'name'\n     * parameter. If no name is given and no user is logged, an empty avatar will\n     * be returned.\n     * \n     * You can use the color and background params to change the avatar colors. By\n     * default, a random theme will be selected. The random theme will persist for\n     * the user's initials when reloading the same theme will always return for\n     * the same initials.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     * \n     *\n     * @param {string} name\n     * @param {number} width\n     * @param {number} height\n     * @param {string} background\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getInitials(name, width, height, background) {\n        const apiPath = \"/avatars/initials\";\n        let payload = {};\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof width !== \"undefined\") {\n            payload[\"width\"] = width;\n        }\n        if (typeof height !== \"undefined\") {\n            payload[\"height\"] = height;\n        }\n        if (typeof background !== \"undefined\") {\n            payload[\"background\"] = background;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n    /**\n     * Get QR code\n     *\n     * Converts a given plain text to a QR code image. You can use the query\n     * parameters to change the size and style of the resulting image.\n     * \n     *\n     * @param {string} text\n     * @param {number} size\n     * @param {number} margin\n     * @param {boolean} download\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQR(text, size, margin, download) {\n        const apiPath = \"/avatars/qr\";\n        let payload = {};\n        if (typeof text === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"text\"');\n        }\n        if (typeof text !== \"undefined\") {\n            payload[\"text\"] = text;\n        }\n        if (typeof size !== \"undefined\") {\n            payload[\"size\"] = size;\n        }\n        if (typeof margin !== \"undefined\") {\n            payload[\"margin\"] = margin;\n        }\n        if (typeof download !== \"undefined\") {\n            payload[\"download\"] = download;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n}\nmodule.exports = Avatars;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvYXZhdGFycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUN4QixNQUFNQyxvQkFBb0JELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1JLFNBQVNKLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUssU0FBUyxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1NLEtBQUtOLG1CQUFPQSxDQUFDO0FBRW5CLE1BQU1PLGdCQUFnQlI7SUFFakJTLFlBQVlMLE1BQU0sQ0FDbEI7UUFDRyxLQUFLLENBQUNBO0lBQ1Q7SUFHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDRCxNQUFNTSxXQUFXQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUU7UUFDM0MsTUFBTUMsVUFBVSwyQkFBMkJDLE9BQU8sQ0FBQyxVQUFVTDtRQUM3RCxJQUFJTSxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9OLFNBQVMsYUFBYTtZQUM3QixNQUFNLElBQUlULGtCQUFrQjtRQUNoQztRQUdBLElBQUksT0FBT1UsVUFBVSxhQUFhO1lBQzlCSyxPQUFPLENBQUMsUUFBUSxHQUFHTDtRQUN2QjtRQUVBLElBQUksT0FBT0MsV0FBVyxhQUFhO1lBQy9CSSxPQUFPLENBQUMsU0FBUyxHQUFHSjtRQUN4QjtRQUVBLElBQUksT0FBT0MsWUFBWSxhQUFhO1lBQ2hDRyxPQUFPLENBQUMsVUFBVSxHQUFHSDtRQUN6QjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUNWLE1BQU0sQ0FBQ2MsSUFBSSxDQUFDLE9BQU9ILFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdFLFNBQVM7SUFDaEI7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQW1CQyxHQUNE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ZXMiOlsid2VicGFjazovL2hhY2tuZXN0Ly4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL2F2YXRhcnMuanM/YWQ5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmNsYXNzIEF2YXRhcnMgZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYnJvd3NlciBpY29uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGlzIGVuZHBvaW50IHRvIHNob3cgZGlmZmVyZW50IGJyb3dzZXIgaWNvbnMgdG8geW91ciB1c2Vycy5cbiAgICAgKiBUaGUgY29kZSBhcmd1bWVudCByZWNlaXZlcyB0aGUgYnJvd3NlciBjb2RlIGFzIGl0IGFwcGVhcnMgaW4geW91ciB1c2VyIFtHRVRcbiAgICAgKiAvYWNjb3VudC9zZXNzaW9uc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2dldFNlc3Npb25zKVxuICAgICAqIGVuZHBvaW50LiBVc2Ugd2lkdGgsIGhlaWdodCBhbmQgcXVhbGl0eSBhcmd1bWVudHMgdG8gY2hhbmdlIHRoZSBvdXRwdXRcbiAgICAgKiBzZXR0aW5ncy5cbiAgICAgKiBcbiAgICAgKiBXaGVuIG9uZSBkaW1lbnNpb24gaXMgc3BlY2lmaWVkIGFuZCB0aGUgb3RoZXIgaXMgMCwgdGhlIGltYWdlIGlzIHNjYWxlZFxuICAgICAqIHdpdGggcHJlc2VydmVkIGFzcGVjdCByYXRpby4gSWYgYm90aCBkaW1lbnNpb25zIGFyZSAwLCB0aGUgQVBJIHByb3ZpZGVzIGFuXG4gICAgICogaW1hZ2UgYXQgc291cmNlIHF1YWxpdHkuIElmIGRpbWVuc2lvbnMgYXJlIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IHNpemVcbiAgICAgKiBvZiBpbWFnZSByZXR1cm5lZCBpcyAxMDB4MTAwcHguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJyb3dzZXIoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2Jyb3dzZXJzL3tjb2RlfScucmVwbGFjZSgne2NvZGV9JywgY29kZSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29kZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVhbGl0eSddID0gcXVhbGl0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3JlZGl0IGNhcmQgaWNvblxuICAgICAqXG4gICAgICogVGhlIGNyZWRpdCBjYXJkIGVuZHBvaW50IHdpbGwgcmV0dXJuIHlvdSB0aGUgaWNvbiBvZiB0aGUgY3JlZGl0IGNhcmRcbiAgICAgKiBwcm92aWRlciB5b3UgbmVlZC4gVXNlIHdpZHRoLCBoZWlnaHQgYW5kIHF1YWxpdHkgYXJndW1lbnRzIHRvIGNoYW5nZSB0aGVcbiAgICAgKiBvdXRwdXQgc2V0dGluZ3MuXG4gICAgICogXG4gICAgICogV2hlbiBvbmUgZGltZW5zaW9uIGlzIHNwZWNpZmllZCBhbmQgdGhlIG90aGVyIGlzIDAsIHRoZSBpbWFnZSBpcyBzY2FsZWRcbiAgICAgKiB3aXRoIHByZXNlcnZlZCBhc3BlY3QgcmF0aW8uIElmIGJvdGggZGltZW5zaW9ucyBhcmUgMCwgdGhlIEFQSSBwcm92aWRlcyBhblxuICAgICAqIGltYWdlIGF0IHNvdXJjZSBxdWFsaXR5LiBJZiBkaW1lbnNpb25zIGFyZSBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBzaXplXG4gICAgICogb2YgaW1hZ2UgcmV0dXJuZWQgaXMgMTAweDEwMHB4LlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDcmVkaXRDYXJkKGNvZGUsIHdpZHRoLCBoZWlnaHQsIHF1YWxpdHkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9jcmVkaXQtY2FyZHMve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2RlXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmYXZpY29uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBmZXRjaCB0aGUgZmF2b3JpdGUgaWNvbiAoQUtBIGZhdmljb24pIG9mIGFueSByZW1vdGVcbiAgICAgKiB3ZWJzaXRlIFVSTC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGYXZpY29uKHVybCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2Zhdmljb24nO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY291bnRyeSBmbGFnXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGlzIGVuZHBvaW50IHRvIHNob3cgZGlmZmVyZW50IGNvdW50cnkgZmxhZ3MgaWNvbnMgdG8geW91clxuICAgICAqIHVzZXJzLiBUaGUgY29kZSBhcmd1bWVudCByZWNlaXZlcyB0aGUgMiBsZXR0ZXIgY291bnRyeSBjb2RlLiBVc2Ugd2lkdGgsXG4gICAgICogaGVpZ2h0IGFuZCBxdWFsaXR5IGFyZ3VtZW50cyB0byBjaGFuZ2UgdGhlIG91dHB1dCBzZXR0aW5ncy4gQ291bnRyeSBjb2Rlc1xuICAgICAqIGZvbGxvdyB0aGUgW0lTTyAzMTY2LTFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT18zMTY2LTEpIHN0YW5kYXJkLlxuICAgICAqIFxuICAgICAqIFdoZW4gb25lIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQgYW5kIHRoZSBvdGhlciBpcyAwLCB0aGUgaW1hZ2UgaXMgc2NhbGVkXG4gICAgICogd2l0aCBwcmVzZXJ2ZWQgYXNwZWN0IHJhdGlvLiBJZiBib3RoIGRpbWVuc2lvbnMgYXJlIDAsIHRoZSBBUEkgcHJvdmlkZXMgYW5cbiAgICAgKiBpbWFnZSBhdCBzb3VyY2UgcXVhbGl0eS4gSWYgZGltZW5zaW9ucyBhcmUgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAqIG9mIGltYWdlIHJldHVybmVkIGlzIDEwMHgxMDBweC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmxhZyhjb2RlLCB3aWR0aCwgaGVpZ2h0LCBxdWFsaXR5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvZmxhZ3Mve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2RlXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbWFnZSBmcm9tIFVSTFxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gZmV0Y2ggYSByZW1vdGUgaW1hZ2UgVVJMIGFuZCBjcm9wIGl0IHRvIGFueSBpbWFnZSBzaXplXG4gICAgICogeW91IHdhbnQuIFRoaXMgZW5kcG9pbnQgaXMgdmVyeSB1c2VmdWwgaWYgeW91IG5lZWQgdG8gY3JvcCBhbmQgZGlzcGxheVxuICAgICAqIHJlbW90ZSBpbWFnZXMgaW4geW91ciBhcHAgb3IgaW4gY2FzZSB5b3Ugd2FudCB0byBtYWtlIHN1cmUgYSAzcmQgcGFydHlcbiAgICAgKiBpbWFnZSBpcyBwcm9wZXJseSBzZXJ2ZWQgdXNpbmcgYSBUTFMgcHJvdG9jb2wuXG4gICAgICogXG4gICAgICogV2hlbiBvbmUgZGltZW5zaW9uIGlzIHNwZWNpZmllZCBhbmQgdGhlIG90aGVyIGlzIDAsIHRoZSBpbWFnZSBpcyBzY2FsZWRcbiAgICAgKiB3aXRoIHByZXNlcnZlZCBhc3BlY3QgcmF0aW8uIElmIGJvdGggZGltZW5zaW9ucyBhcmUgMCwgdGhlIEFQSSBwcm92aWRlcyBhblxuICAgICAqIGltYWdlIGF0IHNvdXJjZSBxdWFsaXR5LiBJZiBkaW1lbnNpb25zIGFyZSBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBzaXplXG4gICAgICogb2YgaW1hZ2UgcmV0dXJuZWQgaXMgNDAweDQwMHB4LlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRJbWFnZSh1cmwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9pbWFnZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2FycmF5YnVmZmVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgaW5pdGlhbHNcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIHNob3cgeW91ciB1c2VyIGluaXRpYWxzIGF2YXRhciBpY29uIG9uIHlvdXIgd2Vic2l0ZSBvclxuICAgICAqIGFwcC4gQnkgZGVmYXVsdCwgdGhpcyByb3V0ZSB3aWxsIHRyeSB0byBwcmludCB5b3VyIGxvZ2dlZC1pbiB1c2VyIG5hbWUgb3JcbiAgICAgKiBlbWFpbCBpbml0aWFscy4gWW91IGNhbiBhbHNvIG92ZXJ3cml0ZSB0aGUgdXNlciBuYW1lIGlmIHlvdSBwYXNzIHRoZSAnbmFtZSdcbiAgICAgKiBwYXJhbWV0ZXIuIElmIG5vIG5hbWUgaXMgZ2l2ZW4gYW5kIG5vIHVzZXIgaXMgbG9nZ2VkLCBhbiBlbXB0eSBhdmF0YXIgd2lsbFxuICAgICAqIGJlIHJldHVybmVkLlxuICAgICAqIFxuICAgICAqIFlvdSBjYW4gdXNlIHRoZSBjb2xvciBhbmQgYmFja2dyb3VuZCBwYXJhbXMgdG8gY2hhbmdlIHRoZSBhdmF0YXIgY29sb3JzLiBCeVxuICAgICAqIGRlZmF1bHQsIGEgcmFuZG9tIHRoZW1lIHdpbGwgYmUgc2VsZWN0ZWQuIFRoZSByYW5kb20gdGhlbWUgd2lsbCBwZXJzaXN0IGZvclxuICAgICAqIHRoZSB1c2VyJ3MgaW5pdGlhbHMgd2hlbiByZWxvYWRpbmcgdGhlIHNhbWUgdGhlbWUgd2lsbCBhbHdheXMgcmV0dXJuIGZvclxuICAgICAqIHRoZSBzYW1lIGluaXRpYWxzLlxuICAgICAqIFxuICAgICAqIFdoZW4gb25lIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQgYW5kIHRoZSBvdGhlciBpcyAwLCB0aGUgaW1hZ2UgaXMgc2NhbGVkXG4gICAgICogd2l0aCBwcmVzZXJ2ZWQgYXNwZWN0IHJhdGlvLiBJZiBib3RoIGRpbWVuc2lvbnMgYXJlIDAsIHRoZSBBUEkgcHJvdmlkZXMgYW5cbiAgICAgKiBpbWFnZSBhdCBzb3VyY2UgcXVhbGl0eS4gSWYgZGltZW5zaW9ucyBhcmUgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAqIG9mIGltYWdlIHJldHVybmVkIGlzIDEwMHgxMDBweC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrZ3JvdW5kXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW5pdGlhbHMobmFtZSwgd2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2luaXRpYWxzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJhY2tncm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiYWNrZ3JvdW5kJ10gPSBiYWNrZ3JvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBRUiBjb2RlXG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyBhIGdpdmVuIHBsYWluIHRleHQgdG8gYSBRUiBjb2RlIGltYWdlLiBZb3UgY2FuIHVzZSB0aGUgcXVlcnlcbiAgICAgKiBwYXJhbWV0ZXJzIHRvIGNoYW5nZSB0aGUgc2l6ZSBhbmQgc3R5bGUgb2YgdGhlIHJlc3VsdGluZyBpbWFnZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkb3dubG9hZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFFSKHRleHQsIHNpemUsIG1hcmdpbiwgZG93bmxvYWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9xcic7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGV4dFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RleHQnXSA9IHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzaXplJ10gPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXJnaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXJnaW4nXSA9IG1hcmdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZG93bmxvYWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkb3dubG9hZCddID0gZG93bmxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2FycmF5YnVmZmVyJyk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF2YXRhcnM7XG4iXSwibmFtZXMiOlsiU2VydmljZSIsInJlcXVpcmUiLCJBcHB3cml0ZUV4Y2VwdGlvbiIsIklucHV0RmlsZSIsImNsaWVudCIsIlN0cmVhbSIsInByb21pc2lmeSIsImZzIiwiQXZhdGFycyIsImNvbnN0cnVjdG9yIiwiZ2V0QnJvd3NlciIsImNvZGUiLCJ3aWR0aCIsImhlaWdodCIsInF1YWxpdHkiLCJhcGlQYXRoIiwicmVwbGFjZSIsInBheWxvYWQiLCJjYWxsIiwiZ2V0Q3JlZGl0Q2FyZCIsImdldEZhdmljb24iLCJ1cmwiLCJnZXRGbGFnIiwiZ2V0SW1hZ2UiLCJnZXRJbml0aWFscyIsIm5hbWUiLCJiYWNrZ3JvdW5kIiwiZ2V0UVIiLCJ0ZXh0Iiwic2l6ZSIsIm1hcmdpbiIsImRvd25sb2FkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/avatars.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/databases.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/databases.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Databases extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * List databases\n     *\n     * Get a list of all databases from the current Appwrite project. You can use\n     * the search parameter to filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async list(queries, search) {\n        const apiPath = \"/databases\";\n        let payload = {};\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create database\n     *\n     * Create a new Database.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async create(databaseId, name, enabled) {\n        const apiPath = \"/databases\";\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof databaseId !== \"undefined\") {\n            payload[\"databaseId\"] = databaseId;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof enabled !== \"undefined\") {\n            payload[\"enabled\"] = enabled;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get database\n     *\n     * Get a database by its unique ID. This endpoint response returns a JSON\n     * object with the database metadata.\n     *\n     * @param {string} databaseId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async get(databaseId) {\n        const apiPath = \"/databases/{databaseId}\".replace(\"{databaseId}\", databaseId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update database\n     *\n     * Update a database by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async update(databaseId, name, enabled) {\n        const apiPath = \"/databases/{databaseId}\".replace(\"{databaseId}\", databaseId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof enabled !== \"undefined\") {\n            payload[\"enabled\"] = enabled;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete database\n     *\n     * Delete a database by its unique ID. Only API keys with with databases.write\n     * scope can delete a database.\n     *\n     * @param {string} databaseId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async delete(databaseId) {\n        const apiPath = \"/databases/{databaseId}\".replace(\"{databaseId}\", databaseId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List collections\n     *\n     * Get a list of all collections that belong to the provided databaseId. You\n     * can use the search parameter to filter your results.\n     *\n     * @param {string} databaseId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listCollections(databaseId, queries, search) {\n        const apiPath = \"/databases/{databaseId}/collections\".replace(\"{databaseId}\", databaseId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create collection\n     *\n     * Create a new Collection. Before using this route, you should create a new\n     * database resource using either a [server\n     * integration](https://appwrite.io/docs/server/databases#databasesCreateCollection)\n     * API or directly from your database console.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} documentSecurity\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createCollection(databaseId, collectionId, name, permissions, documentSecurity, enabled) {\n        const apiPath = \"/databases/{databaseId}/collections\".replace(\"{databaseId}\", databaseId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof collectionId !== \"undefined\") {\n            payload[\"collectionId\"] = collectionId;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof permissions !== \"undefined\") {\n            payload[\"permissions\"] = permissions;\n        }\n        if (typeof documentSecurity !== \"undefined\") {\n            payload[\"documentSecurity\"] = documentSecurity;\n        }\n        if (typeof enabled !== \"undefined\") {\n            payload[\"enabled\"] = enabled;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get collection\n     *\n     * Get a collection by its unique ID. This endpoint response returns a JSON\n     * object with the collection metadata.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getCollection(databaseId, collectionId) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update collection\n     *\n     * Update a collection by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} documentSecurity\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateCollection(databaseId, collectionId, name, permissions, documentSecurity, enabled) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof permissions !== \"undefined\") {\n            payload[\"permissions\"] = permissions;\n        }\n        if (typeof documentSecurity !== \"undefined\") {\n            payload[\"documentSecurity\"] = documentSecurity;\n        }\n        if (typeof enabled !== \"undefined\") {\n            payload[\"enabled\"] = enabled;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete collection\n     *\n     * Delete a collection by its unique ID. Only users with write permissions\n     * have access to delete this resource.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteCollection(databaseId, collectionId) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List attributes\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listAttributes(databaseId, collectionId, queries) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create boolean attribute\n     *\n     * Create a boolean attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {boolean} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createBooleanAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/boolean\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        if (typeof array !== \"undefined\") {\n            payload[\"array\"] = array;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update boolean attribute\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {boolean} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateBooleanAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/boolean/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof xdefault === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create datetime attribute\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createDatetimeAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/datetime\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        if (typeof array !== \"undefined\") {\n            payload[\"array\"] = array;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update dateTime attribute\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateDatetimeAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/datetime/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof xdefault === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create email attribute\n     *\n     * Create an email attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createEmailAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/email\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        if (typeof array !== \"undefined\") {\n            payload[\"array\"] = array;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update email attribute\n     *\n     * Update an email attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateEmailAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/email/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof xdefault === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create enum attribute\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {string[]} elements\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createEnumAttribute(databaseId, collectionId, key, elements, required, xdefault, array) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/enum\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof elements === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"elements\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof elements !== \"undefined\") {\n            payload[\"elements\"] = elements;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        if (typeof array !== \"undefined\") {\n            payload[\"array\"] = array;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update enum attribute\n     *\n     * Update an enum attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {string[]} elements\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateEnumAttribute(databaseId, collectionId, key, elements, required, xdefault) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/enum/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof elements === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"elements\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof xdefault === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n        if (typeof elements !== \"undefined\") {\n            payload[\"elements\"] = elements;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create float attribute\n     *\n     * Create a float attribute. Optionally, minimum and maximum values can be\n     * provided.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createFloatAttribute(databaseId, collectionId, key, required, min, max, xdefault, array) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/float\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof min !== \"undefined\") {\n            payload[\"min\"] = min;\n        }\n        if (typeof max !== \"undefined\") {\n            payload[\"max\"] = max;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        if (typeof array !== \"undefined\") {\n            payload[\"array\"] = array;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update float attribute\n     *\n     * Update a float attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateFloatAttribute(databaseId, collectionId, key, required, min, max, xdefault) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/float/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof min === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"min\"');\n        }\n        if (typeof max === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"max\"');\n        }\n        if (typeof xdefault === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof min !== \"undefined\") {\n            payload[\"min\"] = min;\n        }\n        if (typeof max !== \"undefined\") {\n            payload[\"max\"] = max;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create integer attribute\n     *\n     * Create an integer attribute. Optionally, minimum and maximum values can be\n     * provided.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createIntegerAttribute(databaseId, collectionId, key, required, min, max, xdefault, array) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/integer\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof min !== \"undefined\") {\n            payload[\"min\"] = min;\n        }\n        if (typeof max !== \"undefined\") {\n            payload[\"max\"] = max;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        if (typeof array !== \"undefined\") {\n            payload[\"array\"] = array;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update integer attribute\n     *\n     * Update an integer attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateIntegerAttribute(databaseId, collectionId, key, required, min, max, xdefault) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/integer/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof min === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"min\"');\n        }\n        if (typeof max === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"max\"');\n        }\n        if (typeof xdefault === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof min !== \"undefined\") {\n            payload[\"min\"] = min;\n        }\n        if (typeof max !== \"undefined\") {\n            payload[\"max\"] = max;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create IP address attribute\n     *\n     * Create IP address attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createIpAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/ip\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        if (typeof array !== \"undefined\") {\n            payload[\"array\"] = array;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update IP address attribute\n     *\n     * Update an ip attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateIpAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/ip/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof xdefault === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create relationship attribute\n     *\n     * Create relationship attribute. [Learn more about relationship\n     * attributes](https://appwrite.io/docs/databases-relationships#relationship-attributes).\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} relatedCollectionId\n     * @param {string} type\n     * @param {boolean} twoWay\n     * @param {string} key\n     * @param {string} twoWayKey\n     * @param {string} onDelete\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createRelationshipAttribute(databaseId, collectionId, relatedCollectionId, type, twoWay, key, twoWayKey, onDelete) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/relationship\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof relatedCollectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"relatedCollectionId\"');\n        }\n        if (typeof type === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        if (typeof relatedCollectionId !== \"undefined\") {\n            payload[\"relatedCollectionId\"] = relatedCollectionId;\n        }\n        if (typeof type !== \"undefined\") {\n            payload[\"type\"] = type;\n        }\n        if (typeof twoWay !== \"undefined\") {\n            payload[\"twoWay\"] = twoWay;\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof twoWayKey !== \"undefined\") {\n            payload[\"twoWayKey\"] = twoWayKey;\n        }\n        if (typeof onDelete !== \"undefined\") {\n            payload[\"onDelete\"] = onDelete;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create string attribute\n     *\n     * Create a string attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {number} size\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @param {boolean} encrypt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createStringAttribute(databaseId, collectionId, key, size, required, xdefault, array, encrypt) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/string\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof size === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"size\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof size !== \"undefined\") {\n            payload[\"size\"] = size;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        if (typeof array !== \"undefined\") {\n            payload[\"array\"] = array;\n        }\n        if (typeof encrypt !== \"undefined\") {\n            payload[\"encrypt\"] = encrypt;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update string attribute\n     *\n     * Update a string attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateStringAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/string/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof xdefault === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create URL attribute\n     *\n     * Create a URL attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createUrlAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/url\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        if (typeof array !== \"undefined\") {\n            payload[\"array\"] = array;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update URL attribute\n     *\n     * Update an url attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateUrlAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/url/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof required === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n        if (typeof xdefault === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n        if (typeof required !== \"undefined\") {\n            payload[\"required\"] = required;\n        }\n        if (typeof xdefault !== \"undefined\") {\n            payload[\"default\"] = xdefault;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get attribute\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getAttribute(databaseId, collectionId, key) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete attribute\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteAttribute(databaseId, collectionId, key) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update relationship attribute\n     *\n     * Update relationship attribute. [Learn more about relationship\n     * attributes](https://appwrite.io/docs/databases-relationships#relationship-attributes).\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {string} onDelete\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateRelationshipAttribute(databaseId, collectionId, key, onDelete) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/attributes/{key}/relationship\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof onDelete !== \"undefined\") {\n            payload[\"onDelete\"] = onDelete;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List documents\n     *\n     * Get a list of all the user's documents in a given collection. You can use\n     * the query params to filter your results.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listDocuments(databaseId, collectionId, queries) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/documents\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create document\n     *\n     * Create a new Document. Before using this route, you should create a new\n     * collection resource using either a [server\n     * integration](https://appwrite.io/docs/server/databases#databasesCreateCollection)\n     * API or directly from your database console.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {object} data\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createDocument(databaseId, collectionId, documentId, data, permissions) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/documents\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof data === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        if (typeof documentId !== \"undefined\") {\n            payload[\"documentId\"] = documentId;\n        }\n        if (typeof data !== \"undefined\") {\n            payload[\"data\"] = data;\n        }\n        if (typeof permissions !== \"undefined\") {\n            payload[\"permissions\"] = permissions;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get document\n     *\n     * Get a document by its unique ID. This endpoint response returns a JSON\n     * object with the document data.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getDocument(databaseId, collectionId, documentId, queries) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/documents/{documentId}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{documentId}\", documentId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update document\n     *\n     * Update a document by its unique ID. Using the patch method you can pass\n     * only specific fields that will get updated.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {object} data\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateDocument(databaseId, collectionId, documentId, data, permissions) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/documents/{documentId}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{documentId}\", documentId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof data !== \"undefined\") {\n            payload[\"data\"] = data;\n        }\n        if (typeof permissions !== \"undefined\") {\n            payload[\"permissions\"] = permissions;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete document\n     *\n     * Delete a document by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteDocument(databaseId, collectionId, documentId) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/documents/{documentId}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{documentId}\", documentId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List indexes\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listIndexes(databaseId, collectionId, queries) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/indexes\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create index\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {string} type\n     * @param {string[]} attributes\n     * @param {string[]} orders\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createIndex(databaseId, collectionId, key, type, attributes, orders) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/indexes\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof type === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        if (typeof attributes === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"attributes\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof type !== \"undefined\") {\n            payload[\"type\"] = type;\n        }\n        if (typeof attributes !== \"undefined\") {\n            payload[\"attributes\"] = attributes;\n        }\n        if (typeof orders !== \"undefined\") {\n            payload[\"orders\"] = orders;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get index\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getIndex(databaseId, collectionId, key) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/indexes/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete index\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteIndex(databaseId, collectionId, key) {\n        const apiPath = \"/databases/{databaseId}/collections/{collectionId}/indexes/{key}\".replace(\"{databaseId}\", databaseId).replace(\"{collectionId}\", collectionId).replace(\"{key}\", key);\n        let payload = {};\n        if (typeof databaseId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n}\nmodule.exports = Databases;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvZGF0YWJhc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUM7QUFDbEMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUM7QUFDMUIsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUksU0FBU0osbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFSyxTQUFTLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDOUIsTUFBTU0sS0FBS04sbUJBQU9BLENBQUM7QUFFbkIsTUFBTU8sa0JBQWtCUjtJQUVuQlMsWUFBWUwsTUFBTSxDQUNsQjtRQUNHLEtBQUssQ0FBQ0E7SUFDVDtJQUdEOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNTSxLQUFLQyxPQUFPLEVBQUVDLE1BQU0sRUFBRTtRQUN4QixNQUFNQyxVQUFVO1FBQ2hCLElBQUlDLFVBQVUsQ0FBQztRQUVmLElBQUksT0FBT0gsWUFBWSxhQUFhO1lBQ2hDRyxPQUFPLENBQUMsVUFBVSxHQUFHSDtRQUN6QjtRQUVBLElBQUksT0FBT0MsV0FBVyxhQUFhO1lBQy9CRSxPQUFPLENBQUMsU0FBUyxHQUFHRjtRQUN4QjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNELE1BQU1FLE9BQU9DLFVBQVUsRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUU7UUFDcEMsTUFBTU4sVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGVBQWUsYUFBYTtZQUNuQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT2dCLFNBQVMsYUFBYTtZQUM3QixNQUFNLElBQUloQixr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bmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9kYXRhYmFzZXMuanM/ZDE0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmNsYXNzIERhdGFiYXNlcyBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExpc3QgZGF0YWJhc2VzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBkYXRhYmFzZXMgZnJvbSB0aGUgY3VycmVudCBBcHB3cml0ZSBwcm9qZWN0LiBZb3UgY2FuIHVzZVxuICAgICAqIHRoZSBzZWFyY2ggcGFyYW1ldGVyIHRvIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QocXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGRhdGFiYXNlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgRGF0YWJhc2UuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKGRhdGFiYXNlSWQsIG5hbWUsIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGFiYXNlSWQnXSA9IGRhdGFiYXNlSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRhdGFiYXNlXG4gICAgICpcbiAgICAgKiBHZXQgYSBkYXRhYmFzZSBieSBpdHMgdW5pcXVlIElELiBUaGlzIGVuZHBvaW50IHJlc3BvbnNlIHJldHVybnMgYSBKU09OXG4gICAgICogb2JqZWN0IHdpdGggdGhlIGRhdGFiYXNlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXQoZGF0YWJhc2VJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkYXRhYmFzZVxuICAgICAqXG4gICAgICogVXBkYXRlIGEgZGF0YWJhc2UgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoZGF0YWJhc2VJZCwgbmFtZSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBkYXRhYmFzZVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgZGF0YWJhc2UgYnkgaXRzIHVuaXF1ZSBJRC4gT25seSBBUEkga2V5cyB3aXRoIHdpdGggZGF0YWJhc2VzLndyaXRlXG4gICAgICogc2NvcGUgY2FuIGRlbGV0ZSBhIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoZGF0YWJhc2VJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgY29sbGVjdGlvbnNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIGNvbGxlY3Rpb25zIHRoYXQgYmVsb25nIHRvIHRoZSBwcm92aWRlZCBkYXRhYmFzZUlkLiBZb3VcbiAgICAgKiBjYW4gdXNlIHRoZSBzZWFyY2ggcGFyYW1ldGVyIHRvIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdENvbGxlY3Rpb25zKGRhdGFiYXNlSWQsIHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBDb2xsZWN0aW9uLiBCZWZvcmUgdXNpbmcgdGhpcyByb3V0ZSwgeW91IHNob3VsZCBjcmVhdGUgYSBuZXdcbiAgICAgKiBkYXRhYmFzZSByZXNvdXJjZSB1c2luZyBlaXRoZXIgYSBbc2VydmVyXG4gICAgICogaW50ZWdyYXRpb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvZGF0YWJhc2VzI2RhdGFiYXNlc0NyZWF0ZUNvbGxlY3Rpb24pXG4gICAgICogQVBJIG9yIGRpcmVjdGx5IGZyb20geW91ciBkYXRhYmFzZSBjb25zb2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJtaXNzaW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9jdW1lbnRTZWN1cml0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUNvbGxlY3Rpb24oZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBuYW1lLCBwZXJtaXNzaW9ucywgZG9jdW1lbnRTZWN1cml0eSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjb2xsZWN0aW9uSWQnXSA9IGNvbGxlY3Rpb25JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudFNlY3VyaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9jdW1lbnRTZWN1cml0eSddID0gZG9jdW1lbnRTZWN1cml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjb2xsZWN0aW9uXG4gICAgICpcbiAgICAgKiBHZXQgYSBjb2xsZWN0aW9uIGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgcmVzcG9uc2UgcmV0dXJucyBhIEpTT05cbiAgICAgKiBvYmplY3Qgd2l0aCB0aGUgY29sbGVjdGlvbiBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbGxlY3Rpb24oZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIGNvbGxlY3Rpb24gYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvY3VtZW50U2VjdXJpdHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVDb2xsZWN0aW9uKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgbmFtZSwgcGVybWlzc2lvbnMsIGRvY3VtZW50U2VjdXJpdHksIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRTZWN1cml0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RvY3VtZW50U2VjdXJpdHknXSA9IGRvY3VtZW50U2VjdXJpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBjb2xsZWN0aW9uXG4gICAgICpcbiAgICAgKiBEZWxldGUgYSBjb2xsZWN0aW9uIGJ5IGl0cyB1bmlxdWUgSUQuIE9ubHkgdXNlcnMgd2l0aCB3cml0ZSBwZXJtaXNzaW9uc1xuICAgICAqIGhhdmUgYWNjZXNzIHRvIGRlbGV0ZSB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQ29sbGVjdGlvbihkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0QXR0cmlidXRlcyhkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYm9vbGVhbiBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIGJvb2xlYW4gYXR0cmlidXRlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUJvb2xlYW5BdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2Jvb2xlYW4nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FycmF5J10gPSBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGJvb2xlYW4gYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0geGRlZmF1bHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVCb29sZWFuQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2Jvb2xlYW4ve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGRhdGV0aW1lIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRGF0ZXRpbWVBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2RhdGV0aW1lJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkYXRlVGltZSBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRGF0ZXRpbWVBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvZGF0ZXRpbWUve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVtYWlsIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGFuIGVtYWlsIGF0dHJpYnV0ZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVtYWlsQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQsIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9lbWFpbCcucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW1haWwgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYW4gZW1haWwgYXR0cmlidXRlLiBDaGFuZ2luZyB0aGUgYGRlZmF1bHRgIHZhbHVlIHdpbGwgbm90IHVwZGF0ZVxuICAgICAqIGFscmVhZHkgZXhpc3RpbmcgZG9jdW1lbnRzLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVFbWFpbEF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9lbWFpbC97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZW51bSBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRW51bUF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgZWxlbWVudHMsIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2VudW0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbGVtZW50c1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZWxlbWVudHMnXSA9IGVsZW1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlbnVtIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIGFuIGVudW0gYXR0cmlidXRlLiBDaGFuZ2luZyB0aGUgYGRlZmF1bHRgIHZhbHVlIHdpbGwgbm90IHVwZGF0ZVxuICAgICAqIGFscmVhZHkgZXhpc3RpbmcgZG9jdW1lbnRzLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUVudW1BdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIGVsZW1lbnRzLCByZXF1aXJlZCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2VudW0ve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZWxlbWVudHNcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZWxlbWVudHMnXSA9IGVsZW1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBmbG9hdCBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIGZsb2F0IGF0dHJpYnV0ZS4gT3B0aW9uYWxseSwgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMgY2FuIGJlXG4gICAgICogcHJvdmlkZWQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUZsb2F0QXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgbWluLCBtYXgsIHhkZWZhdWx0LCBhcnJheSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvZmxvYXQnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtaW4nXSA9IG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4J10gPSBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZmxvYXQgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBmbG9hdCBhdHRyaWJ1dGUuIENoYW5naW5nIHRoZSBgZGVmYXVsdGAgdmFsdWUgd2lsbCBub3QgdXBkYXRlXG4gICAgICogYWxyZWFkeSBleGlzdGluZyBkb2N1bWVudHMuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRmxvYXRBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCBtaW4sIG1heCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2Zsb2F0L3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWluID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtaW5cIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1heFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1pbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21pbiddID0gbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXgnXSA9IG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBpbnRlZ2VyIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGFuIGludGVnZXIgYXR0cmlidXRlLiBPcHRpb25hbGx5LCBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBjYW4gYmVcbiAgICAgKiBwcm92aWRlZC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSW50ZWdlckF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIG1pbiwgbWF4LCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2ludGVnZXInLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtaW4nXSA9IG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4J10gPSBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgaW50ZWdlciBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhbiBpbnRlZ2VyIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geGRlZmF1bHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVJbnRlZ2VyQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgbWluLCBtYXgsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9pbnRlZ2VyL3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWluID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtaW5cIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1heFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1pbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21pbiddID0gbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXgnXSA9IG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBJUCBhZGRyZXNzIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIElQIGFkZHJlc3MgYXR0cmlidXRlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSXBBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2lwJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBJUCBhZGRyZXNzIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIGFuIGlwIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlSXBBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvaXAve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHJlbGF0aW9uc2hpcCBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSByZWxhdGlvbnNoaXAgYXR0cmlidXRlLiBbTGVhcm4gbW9yZSBhYm91dCByZWxhdGlvbnNoaXBcbiAgICAgKiBhdHRyaWJ1dGVzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvZGF0YWJhc2VzLXJlbGF0aW9uc2hpcHMjcmVsYXRpb25zaGlwLWF0dHJpYnV0ZXMpLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0ZWRDb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHdvV2F5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0d29XYXlLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb25EZWxldGVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVSZWxhdGlvbnNoaXBBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCByZWxhdGVkQ29sbGVjdGlvbklkLCB0eXBlLCB0d29XYXksIGtleSwgdHdvV2F5S2V5LCBvbkRlbGV0ZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvcmVsYXRpb25zaGlwJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVsYXRlZENvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVsYXRlZENvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlbGF0ZWRDb2xsZWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZWxhdGVkQ29sbGVjdGlvbklkJ10gPSByZWxhdGVkQ29sbGVjdGlvbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHlwZSddID0gdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdHdvV2F5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHdvV2F5J10gPSB0d29XYXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0d29XYXlLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0d29XYXlLZXknXSA9IHR3b1dheUtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb25EZWxldGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvbkRlbGV0ZSddID0gb25EZWxldGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzdHJpbmcgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBzdHJpbmcgYXR0cmlidXRlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJyYXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuY3J5cHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTdHJpbmdBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHNpemUsIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXksIGVuY3J5cHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL3N0cmluZycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2l6ZVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzaXplJ10gPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuY3J5cHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmNyeXB0J10gPSBlbmNyeXB0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc3RyaW5nIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIGEgc3RyaW5nIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU3RyaW5nQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL3N0cmluZy97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgVVJMIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgVVJMIGF0dHJpYnV0ZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVVybEF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0LCBhcnJheSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvdXJsJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBVUkwgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYW4gdXJsIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVXJsQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL3VybC97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcmVsYXRpb25zaGlwIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIHJlbGF0aW9uc2hpcCBhdHRyaWJ1dGUuIFtMZWFybiBtb3JlIGFib3V0IHJlbGF0aW9uc2hpcFxuICAgICAqIGF0dHJpYnV0ZXNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9kYXRhYmFzZXMtcmVsYXRpb25zaGlwcyNyZWxhdGlvbnNoaXAtYXR0cmlidXRlcykuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9uRGVsZXRlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUmVsYXRpb25zaGlwQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCBvbkRlbGV0ZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMve2tleX0vcmVsYXRpb25zaGlwJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvbkRlbGV0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ29uRGVsZXRlJ10gPSBvbkRlbGV0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgZG9jdW1lbnRzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgdXNlcidzIGRvY3VtZW50cyBpbiBhIGdpdmVuIGNvbGxlY3Rpb24uIFlvdSBjYW4gdXNlXG4gICAgICogdGhlIHF1ZXJ5IHBhcmFtcyB0byBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3REb2N1bWVudHMoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBEb2N1bWVudC4gQmVmb3JlIHVzaW5nIHRoaXMgcm91dGUsIHlvdSBzaG91bGQgY3JlYXRlIGEgbmV3XG4gICAgICogY29sbGVjdGlvbiByZXNvdXJjZSB1c2luZyBlaXRoZXIgYSBbc2VydmVyXG4gICAgICogaW50ZWdyYXRpb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvZGF0YWJhc2VzI2RhdGFiYXNlc0NyZWF0ZUNvbGxlY3Rpb24pXG4gICAgICogQVBJIG9yIGRpcmVjdGx5IGZyb20geW91ciBkYXRhYmFzZSBjb25zb2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50SWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRG9jdW1lbnQoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBkb2N1bWVudElkLCBkYXRhLCBwZXJtaXNzaW9ucykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9jdW1lbnRJZCddID0gZG9jdW1lbnRJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGEnXSA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIEdldCBhIGRvY3VtZW50IGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgcmVzcG9uc2UgcmV0dXJucyBhIEpTT05cbiAgICAgKiBvYmplY3Qgd2l0aCB0aGUgZG9jdW1lbnQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldERvY3VtZW50KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgZG9jdW1lbnRJZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIGRvY3VtZW50IGJ5IGl0cyB1bmlxdWUgSUQuIFVzaW5nIHRoZSBwYXRjaCBtZXRob2QgeW91IGNhbiBwYXNzXG4gICAgICogb25seSBzcGVjaWZpYyBmaWVsZHMgdGhhdCB3aWxsIGdldCB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50SWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRG9jdW1lbnQoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBkb2N1bWVudElkLCBkYXRhLCBwZXJtaXNzaW9ucykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIGRvY3VtZW50IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9jdW1lbnRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZURvY3VtZW50KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgZG9jdW1lbnRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgaW5kZXhlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RJbmRleGVzKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2luZGV4ZXMnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBpbmRleFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYXR0cmlidXRlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVyc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUluZGV4KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCB0eXBlLCBhdHRyaWJ1dGVzLCBvcmRlcnMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9pbmRleGVzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYXR0cmlidXRlc1wiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0eXBlJ10gPSB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXR0cmlidXRlcyddID0gYXR0cmlidXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3JkZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3JkZXJzJ10gPSBvcmRlcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbmRleFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEluZGV4KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vaW5kZXhlcy97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgaW5kZXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVJbmRleChkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2luZGV4ZXMve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFiYXNlcztcbiJdLCJuYW1lcyI6WyJTZXJ2aWNlIiwicmVxdWlyZSIsIkFwcHdyaXRlRXhjZXB0aW9uIiwiSW5wdXRGaWxlIiwiY2xpZW50IiwiU3RyZWFtIiwicHJvbWlzaWZ5IiwiZnMiLCJEYXRhYmFzZXMiLCJjb25zdHJ1Y3RvciIsImxpc3QiLCJxdWVyaWVzIiwic2VhcmNoIiwiYXBpUGF0aCIsInBheWxvYWQiLCJjYWxsIiwiY3JlYXRlIiwiZGF0YWJhc2VJZCIsIm5hbWUiLCJlbmFibGVkIiwiZ2V0IiwicmVwbGFjZSIsInVwZGF0ZSIsImRlbGV0ZSIsImxpc3RDb2xsZWN0aW9ucyIsImNyZWF0ZUNvbGxlY3Rpb24iLCJjb2xsZWN0aW9uSWQiLCJwZXJtaXNzaW9ucyIsImRvY3VtZW50U2VjdXJpdHkiLCJnZXRDb2xsZWN0aW9uIiwidXBkYXRlQ29sbGVjdGlvbiIsImRlbGV0ZUNvbGxlY3Rpb24iLCJsaXN0QXR0cmlidXRlcyIsImNyZWF0ZUJvb2xlYW5BdHRyaWJ1dGUiLCJrZXkiLCJyZXF1aXJlZCIsInhkZWZhdWx0IiwiYXJyYXkiLCJ1cGRhdGVCb29sZWFuQXR0cmlidXRlIiwiY3JlYXRlRGF0ZXRpbWVBdHRyaWJ1dGUiLCJ1cGRhdGVEYXRldGltZUF0dHJpYnV0ZSIsImNyZWF0ZUVtYWlsQXR0cmlidXRlIiwidXBkYXRlRW1haWxBdHRyaWJ1dGUiLCJjcmVhdGVFbnVtQXR0cmlidXRlIiwiZWxlbWVudHMiLCJ1cGRhdGVFbnVtQXR0cmlidXRlIiwiY3JlYXRlRmxvYXRBdHRyaWJ1dGUiLCJtaW4iLCJtYXgiLCJ1cGRhdGVGbG9hdEF0dHJpYnV0ZSIsImNyZWF0ZUludGVnZXJBdHRyaWJ1dGUiLCJ1cGRhdGVJbnRlZ2VyQXR0cmlidXRlIiwiY3JlYXRlSXBBdHRyaWJ1dGUiLCJ1cGRhdGVJcEF0dHJpYnV0ZSIsImNyZWF0ZVJlbGF0aW9uc2hpcEF0dHJpYnV0ZSIsInJlbGF0ZWRDb2xsZWN0aW9uSWQiLCJ0eXBlIiwidHdvV2F5IiwidHdvV2F5S2V5Iiwib25EZWxldGUiLCJjcmVhdGVTdHJpbmdBdHRyaWJ1dGUiLCJzaXplIiwiZW5jcnlwdCIsInVwZGF0ZVN0cmluZ0F0dHJpYnV0ZSIsImNyZWF0ZVVybEF0dHJpYnV0ZSIsInVwZGF0ZVVybEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImRlbGV0ZUF0dHJpYnV0ZSIsInVwZGF0ZVJlbGF0aW9uc2hpcEF0dHJpYnV0ZSIsImxpc3REb2N1bWVudHMiLCJjcmVhdGVEb2N1bWVudCIsImRvY3VtZW50SWQiLCJkYXRhIiwiZ2V0RG9jdW1lbnQiLCJ1cGRhdGVEb2N1bWVudCIsImRlbGV0ZURvY3VtZW50IiwibGlzdEluZGV4ZXMiLCJjcmVhdGVJbmRleCIsImF0dHJpYnV0ZXMiLCJvcmRlcnMiLCJnZXRJbmRleCIsImRlbGV0ZUluZGV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/databases.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/functions.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/functions.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Functions extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * List functions\n     *\n     * Get a list of all the project's functions. You can use the query params to\n     * filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async list(queries, search) {\n        const apiPath = \"/functions\";\n        let payload = {};\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create function\n     *\n     * Create a new function. You can pass a list of\n     * [permissions](https://appwrite.io/docs/permissions) to allow different\n     * project users or team with access to execute the function using the client\n     * API.\n     *\n     * @param {string} functionId\n     * @param {string} name\n     * @param {string} runtime\n     * @param {string[]} execute\n     * @param {string[]} events\n     * @param {string} schedule\n     * @param {number} timeout\n     * @param {boolean} enabled\n     * @param {boolean} logging\n     * @param {string} entrypoint\n     * @param {string} commands\n     * @param {string} installationId\n     * @param {string} providerRepositoryId\n     * @param {string} providerBranch\n     * @param {boolean} providerSilentMode\n     * @param {string} providerRootDirectory\n     * @param {string} templateRepository\n     * @param {string} templateOwner\n     * @param {string} templateRootDirectory\n     * @param {string} templateBranch\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async create(functionId, name, runtime, execute, events, schedule, timeout, enabled, logging, entrypoint, commands, installationId, providerRepositoryId, providerBranch, providerSilentMode, providerRootDirectory, templateRepository, templateOwner, templateRootDirectory, templateBranch) {\n        const apiPath = \"/functions\";\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof runtime === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"runtime\"');\n        }\n        if (typeof functionId !== \"undefined\") {\n            payload[\"functionId\"] = functionId;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof runtime !== \"undefined\") {\n            payload[\"runtime\"] = runtime;\n        }\n        if (typeof execute !== \"undefined\") {\n            payload[\"execute\"] = execute;\n        }\n        if (typeof events !== \"undefined\") {\n            payload[\"events\"] = events;\n        }\n        if (typeof schedule !== \"undefined\") {\n            payload[\"schedule\"] = schedule;\n        }\n        if (typeof timeout !== \"undefined\") {\n            payload[\"timeout\"] = timeout;\n        }\n        if (typeof enabled !== \"undefined\") {\n            payload[\"enabled\"] = enabled;\n        }\n        if (typeof logging !== \"undefined\") {\n            payload[\"logging\"] = logging;\n        }\n        if (typeof entrypoint !== \"undefined\") {\n            payload[\"entrypoint\"] = entrypoint;\n        }\n        if (typeof commands !== \"undefined\") {\n            payload[\"commands\"] = commands;\n        }\n        if (typeof installationId !== \"undefined\") {\n            payload[\"installationId\"] = installationId;\n        }\n        if (typeof providerRepositoryId !== \"undefined\") {\n            payload[\"providerRepositoryId\"] = providerRepositoryId;\n        }\n        if (typeof providerBranch !== \"undefined\") {\n            payload[\"providerBranch\"] = providerBranch;\n        }\n        if (typeof providerSilentMode !== \"undefined\") {\n            payload[\"providerSilentMode\"] = providerSilentMode;\n        }\n        if (typeof providerRootDirectory !== \"undefined\") {\n            payload[\"providerRootDirectory\"] = providerRootDirectory;\n        }\n        if (typeof templateRepository !== \"undefined\") {\n            payload[\"templateRepository\"] = templateRepository;\n        }\n        if (typeof templateOwner !== \"undefined\") {\n            payload[\"templateOwner\"] = templateOwner;\n        }\n        if (typeof templateRootDirectory !== \"undefined\") {\n            payload[\"templateRootDirectory\"] = templateRootDirectory;\n        }\n        if (typeof templateBranch !== \"undefined\") {\n            payload[\"templateBranch\"] = templateBranch;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List runtimes\n     *\n     * Get a list of all runtimes that are currently active on your instance.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listRuntimes() {\n        const apiPath = \"/functions/runtimes\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get function\n     *\n     * Get a function by its unique ID.\n     *\n     * @param {string} functionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async get(functionId) {\n        const apiPath = \"/functions/{functionId}\".replace(\"{functionId}\", functionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update function\n     *\n     * Update function by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} name\n     * @param {string} runtime\n     * @param {string[]} execute\n     * @param {string[]} events\n     * @param {string} schedule\n     * @param {number} timeout\n     * @param {boolean} enabled\n     * @param {boolean} logging\n     * @param {string} entrypoint\n     * @param {string} commands\n     * @param {string} installationId\n     * @param {string} providerRepositoryId\n     * @param {string} providerBranch\n     * @param {boolean} providerSilentMode\n     * @param {string} providerRootDirectory\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async update(functionId, name, runtime, execute, events, schedule, timeout, enabled, logging, entrypoint, commands, installationId, providerRepositoryId, providerBranch, providerSilentMode, providerRootDirectory) {\n        const apiPath = \"/functions/{functionId}\".replace(\"{functionId}\", functionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof runtime !== \"undefined\") {\n            payload[\"runtime\"] = runtime;\n        }\n        if (typeof execute !== \"undefined\") {\n            payload[\"execute\"] = execute;\n        }\n        if (typeof events !== \"undefined\") {\n            payload[\"events\"] = events;\n        }\n        if (typeof schedule !== \"undefined\") {\n            payload[\"schedule\"] = schedule;\n        }\n        if (typeof timeout !== \"undefined\") {\n            payload[\"timeout\"] = timeout;\n        }\n        if (typeof enabled !== \"undefined\") {\n            payload[\"enabled\"] = enabled;\n        }\n        if (typeof logging !== \"undefined\") {\n            payload[\"logging\"] = logging;\n        }\n        if (typeof entrypoint !== \"undefined\") {\n            payload[\"entrypoint\"] = entrypoint;\n        }\n        if (typeof commands !== \"undefined\") {\n            payload[\"commands\"] = commands;\n        }\n        if (typeof installationId !== \"undefined\") {\n            payload[\"installationId\"] = installationId;\n        }\n        if (typeof providerRepositoryId !== \"undefined\") {\n            payload[\"providerRepositoryId\"] = providerRepositoryId;\n        }\n        if (typeof providerBranch !== \"undefined\") {\n            payload[\"providerBranch\"] = providerBranch;\n        }\n        if (typeof providerSilentMode !== \"undefined\") {\n            payload[\"providerSilentMode\"] = providerSilentMode;\n        }\n        if (typeof providerRootDirectory !== \"undefined\") {\n            payload[\"providerRootDirectory\"] = providerRootDirectory;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete function\n     *\n     * Delete a function by its unique ID.\n     *\n     * @param {string} functionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async delete(functionId) {\n        const apiPath = \"/functions/{functionId}\".replace(\"{functionId}\", functionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List deployments\n     *\n     * Get a list of all the project's code deployments. You can use the query\n     * params to filter your results.\n     *\n     * @param {string} functionId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listDeployments(functionId, queries, search) {\n        const apiPath = \"/functions/{functionId}/deployments\".replace(\"{functionId}\", functionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create deployment\n     *\n     * Create a new function code deployment. Use this endpoint to upload a new\n     * version of your code function. To execute your newly uploaded code, you'll\n     * need to update the function's deployment to use your new deployment UID.\n     * \n     * This endpoint accepts a tar.gz file compressed with your code. Make sure to\n     * include any dependencies your code has within the compressed file. You can\n     * learn more about code packaging in the [Appwrite Cloud Functions\n     * tutorial](https://appwrite.io/docs/functions).\n     * \n     * Use the \"command\" param to set the entrypoint used to execute your code.\n     *\n     * @param {string} functionId\n     * @param {InputFile} code\n     * @param {boolean} activate\n     * @param {string} entrypoint\n     * @param {string} commands\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createDeployment(functionId, code, activate, entrypoint, commands, onProgress = ()=>{}) {\n        const apiPath = \"/functions/{functionId}/deployments\".replace(\"{functionId}\", functionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof code === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        if (typeof activate === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"activate\"');\n        }\n        if (typeof entrypoint !== \"undefined\") {\n            payload[\"entrypoint\"] = entrypoint;\n        }\n        if (typeof commands !== \"undefined\") {\n            payload[\"commands\"] = commands;\n        }\n        if (typeof code !== \"undefined\") {\n            payload[\"code\"] = code;\n        }\n        if (typeof activate !== \"undefined\") {\n            payload[\"activate\"] = activate.toString();\n        }\n        const size = code.size;\n        const apiHeaders = {\n            \"content-type\": \"multipart/form-data\"\n        };\n        let id = undefined;\n        let response = undefined;\n        let chunksUploaded = 0;\n        let currentChunk = Buffer.from(\"\");\n        let currentChunkSize = 0;\n        let currentChunkStart = 0;\n        const selfClient = this.client;\n        async function uploadChunk(lastUpload = false) {\n            if (chunksUploaded - 1 >= currentChunkStart / client.CHUNK_SIZE) {\n                return;\n            }\n            const start = currentChunkStart;\n            const end = currentChunkStart + currentChunkSize - 1;\n            if (!lastUpload || currentChunkStart !== 0) {\n                apiHeaders[\"content-range\"] = \"bytes \" + start + \"-\" + end + \"/\" + size;\n            }\n            if (id) {\n                apiHeaders[\"x-appwrite-id\"] = id;\n            }\n            payload[\"code\"] = {\n                type: \"file\",\n                file: currentChunk,\n                filename: code.filename,\n                size: currentChunkSize\n            };\n            response = await selfClient.call(\"post\", apiPath, apiHeaders, payload);\n            if (!id) {\n                id = response[\"$id\"];\n            }\n            if (onProgress !== null) {\n                onProgress({\n                    $id: response[\"$id\"],\n                    progress: Math.min((start + client.CHUNK_SIZE) * client.CHUNK_SIZE, size) / size * 100,\n                    sizeUploaded: end + 1,\n                    chunksTotal: response[\"chunksTotal\"],\n                    chunksUploaded: response[\"chunksUploaded\"]\n                });\n            }\n            currentChunkStart += client.CHUNK_SIZE;\n        }\n        return await new Promise((resolve, reject)=>{\n            const writeStream = new Stream.Writable();\n            writeStream._write = async (mainChunk, encoding, callback)=>{\n                try {\n                    // Segment incoming chunk into up to 5MB chunks\n                    const mainChunkSize = Buffer.byteLength(mainChunk);\n                    const chunksCount = Math.ceil(mainChunkSize / client.CHUNK_SIZE);\n                    const chunks = [];\n                    for(let i = 0; i < chunksCount; i++){\n                        const chunk = mainChunk.slice(i * client.CHUNK_SIZE, (i + 1) * client.CHUNK_SIZE);\n                        chunks.push(chunk);\n                    }\n                    for (const chunk of chunks){\n                        const chunkSize = Buffer.byteLength(chunk);\n                        if (chunkSize + currentChunkSize == client.CHUNK_SIZE) {\n                            // Upload chunk\n                            currentChunk = Buffer.concat([\n                                currentChunk,\n                                chunk\n                            ]);\n                            currentChunkSize = Buffer.byteLength(currentChunk);\n                            await uploadChunk();\n                            currentChunk = Buffer.from(\"\");\n                            currentChunkSize = 0;\n                        } else if (chunkSize + currentChunkSize > client.CHUNK_SIZE) {\n                            // Upload chunk, put rest into next chunk\n                            const bytesToUpload = client.CHUNK_SIZE - currentChunkSize;\n                            const newChunkSection = chunk.slice(0, bytesToUpload);\n                            currentChunk = Buffer.concat([\n                                currentChunk,\n                                newChunkSection\n                            ]);\n                            currentChunkSize = Buffer.byteLength(currentChunk);\n                            await uploadChunk();\n                            currentChunk = chunk.slice(bytesToUpload, undefined);\n                            currentChunkSize = chunkSize - bytesToUpload;\n                        } else {\n                            // Append into current chunk\n                            currentChunk = Buffer.concat([\n                                currentChunk,\n                                chunk\n                            ]);\n                            currentChunkSize = chunkSize + currentChunkSize;\n                        }\n                    }\n                    callback();\n                } catch (e) {\n                    callback(e);\n                }\n            };\n            writeStream.on(\"finish\", async ()=>{\n                if (currentChunkSize > 0) {\n                    try {\n                        await uploadChunk(true);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                resolve(response);\n            });\n            writeStream.on(\"error\", (err)=>{\n                reject(err);\n            });\n            code.stream.pipe(writeStream);\n        });\n    }\n    /**\n     * Get deployment\n     *\n     * Get a code deployment by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getDeployment(functionId, deploymentId) {\n        const apiPath = \"/functions/{functionId}/deployments/{deploymentId}\".replace(\"{functionId}\", functionId).replace(\"{deploymentId}\", deploymentId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof deploymentId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update function deployment\n     *\n     * Update the function code deployment ID using the unique function ID. Use\n     * this endpoint to switch the code deployment that should be executed by the\n     * execution endpoint.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateDeployment(functionId, deploymentId) {\n        const apiPath = \"/functions/{functionId}/deployments/{deploymentId}\".replace(\"{functionId}\", functionId).replace(\"{deploymentId}\", deploymentId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof deploymentId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete deployment\n     *\n     * Delete a code deployment by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteDeployment(functionId, deploymentId) {\n        const apiPath = \"/functions/{functionId}/deployments/{deploymentId}\".replace(\"{functionId}\", functionId).replace(\"{deploymentId}\", deploymentId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof deploymentId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create build\n     *\n     * Create a new build for an Appwrite Function deployment. This endpoint can\n     * be used to retry a failed build.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @param {string} buildId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createBuild(functionId, deploymentId, buildId) {\n        const apiPath = \"/functions/{functionId}/deployments/{deploymentId}/builds/{buildId}\".replace(\"{functionId}\", functionId).replace(\"{deploymentId}\", deploymentId).replace(\"{buildId}\", buildId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof deploymentId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n        if (typeof buildId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"buildId\"');\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Download Deployment\n     *\n     * Get a Deployment's contents by its unique ID. This endpoint supports range\n     * requests for partial or streaming file download.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async downloadDeployment(functionId, deploymentId) {\n        const apiPath = \"/functions/{functionId}/deployments/{deploymentId}/download\".replace(\"{functionId}\", functionId).replace(\"{deploymentId}\", deploymentId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof deploymentId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n    /**\n     * List executions\n     *\n     * Get a list of all the current user function execution logs. You can use the\n     * query params to filter your results.\n     *\n     * @param {string} functionId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listExecutions(functionId, queries, search) {\n        const apiPath = \"/functions/{functionId}/executions\".replace(\"{functionId}\", functionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create execution\n     *\n     * Trigger a function execution. The returned object will return you the\n     * current execution status. You can ping the `Get Execution` endpoint to get\n     * updates on the current execution status. Once this endpoint is called, your\n     * function execution process will start asynchronously.\n     *\n     * @param {string} functionId\n     * @param {string} body\n     * @param {boolean} async\n     * @param {string} xpath\n     * @param {string} method\n     * @param {object} headers\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createExecution(functionId, body, async, xpath, method, headers) {\n        const apiPath = \"/functions/{functionId}/executions\".replace(\"{functionId}\", functionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof body !== \"undefined\") {\n            payload[\"body\"] = body;\n        }\n        if (typeof async !== \"undefined\") {\n            payload[\"async\"] = async;\n        }\n        if (typeof xpath !== \"undefined\") {\n            payload[\"path\"] = xpath;\n        }\n        if (typeof method !== \"undefined\") {\n            payload[\"method\"] = method;\n        }\n        if (typeof headers !== \"undefined\") {\n            payload[\"headers\"] = headers;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get execution\n     *\n     * Get a function execution log by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} executionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getExecution(functionId, executionId) {\n        const apiPath = \"/functions/{functionId}/executions/{executionId}\".replace(\"{functionId}\", functionId).replace(\"{executionId}\", executionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof executionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"executionId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List variables\n     *\n     * Get a list of all variables of a specific function.\n     *\n     * @param {string} functionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listVariables(functionId) {\n        const apiPath = \"/functions/{functionId}/variables\".replace(\"{functionId}\", functionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create variable\n     *\n     * Create a new function environment variable. These variables can be accessed\n     * in the function at runtime as environment variables.\n     *\n     * @param {string} functionId\n     * @param {string} key\n     * @param {string} value\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createVariable(functionId, key, value) {\n        const apiPath = \"/functions/{functionId}/variables\".replace(\"{functionId}\", functionId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof value === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"value\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof value !== \"undefined\") {\n            payload[\"value\"] = value;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get variable\n     *\n     * Get a variable by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} variableId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getVariable(functionId, variableId) {\n        const apiPath = \"/functions/{functionId}/variables/{variableId}\".replace(\"{functionId}\", functionId).replace(\"{variableId}\", variableId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof variableId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"variableId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update variable\n     *\n     * Update variable by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} variableId\n     * @param {string} key\n     * @param {string} value\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateVariable(functionId, variableId, key, value) {\n        const apiPath = \"/functions/{functionId}/variables/{variableId}\".replace(\"{functionId}\", functionId).replace(\"{variableId}\", variableId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof variableId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"variableId\"');\n        }\n        if (typeof key === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n        if (typeof key !== \"undefined\") {\n            payload[\"key\"] = key;\n        }\n        if (typeof value !== \"undefined\") {\n            payload[\"value\"] = value;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete variable\n     *\n     * Delete a variable by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} variableId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteVariable(functionId, variableId) {\n        const apiPath = \"/functions/{functionId}/variables/{variableId}\".replace(\"{functionId}\", functionId).replace(\"{variableId}\", variableId);\n        let payload = {};\n        if (typeof functionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof variableId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"variableId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n}\nmodule.exports = Functions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvZnVuY3Rpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUM7QUFDbEMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUM7QUFDMUIsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUksU0FBU0osbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFSyxTQUFTLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDOUIsTUFBTU0sS0FBS04sbUJBQU9BLENBQUM7QUFFbkIsTUFBTU8sa0JBQWtCUjtJQUVuQlMsWUFBWUwsTUFBTSxDQUNsQjtRQUNHLEtBQUssQ0FBQ0E7SUFDVDtJQUdEOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNTSxLQUFLQyxPQUFPLEVBQUVDLE1BQU0sRUFBRTtRQUN4QixNQUFNQyxVQUFVO1FBQ2hCLElBQUlDLFVBQVUsQ0FBQztRQUVmLElBQUksT0FBT0gsWUFBWSxhQUFhO1lBQ2hDRyxPQUFPLENBQUMsVUFBVSxHQUFHSDtRQUN6QjtRQUVBLElBQUksT0FBT0MsV0FBVyxhQUFhO1lBQy9CRSxPQUFPLENBQUMsU0FBUyxHQUFHRjtRQUN4QjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBOEJDLEdBQ0QsTUFBTUUsT0FBT0MsVUFBVSxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLGNBQWMsRUFBRUMsb0JBQW9CLEVBQUVDLGNBQWMsRUFBRUMsa0JBQWtCLEVBQUVDLHFCQUFxQixFQUFFQyxrQkFBa0IsRUFBRUMsYUFBYSxFQUFFQyxxQkFBcUIsRUFBRUMsY0FBYyxFQUFFO1FBQzNSLE1BQU12QixVQUFVO1FBQ2hCLElBQUlDLFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csZUFBZSxhQUFhO1lBQ25DLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBRUEsSUFBSSxPQUFPZ0IsU0FBUyxhQUFhO1lBQzdCLE1BQU0sSUFBSWhCLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT2lCLFlBQVksYUFBYTtZQUNoQyxNQUFNLElBQUlqQixrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU9lLGVBQWUsYUFBYTtZQUNuQ0gsT0FBTyxDQUFDLGFBQWEsR0FBR0c7UUFDNUI7UUFFQSxJQUFJLE9BQU9DLFNBQVMsYUFBYTtZQUM3QkosT0FBTyxDQUFDLE9BQU8sR0FBR0k7UUFDdEI7UUFFQSxJQUFJLE9BQU9DLFlBQVksYUFBYTtZQUNoQ0wsT0FBTyxDQUFDLFVBQVUsR0FBR0s7UUFDekI7UUFFQSxJQUFJLE9BQU9DLFlBQVksYUFBYTtZQUNoQ04sT0FBTyxDQUFDLFVBQVUsR0FBR007UUFDekI7UUFFQSxJQUFJLE9BQU9DLFdBQVcsYUFBYTtZQUMvQlAsT0FBTyxDQUFDLFNBQVMsR0FBR087UUFDeEI7UUFFQSxJQUFJLE9BQU9DLGFBQWEsYUFBYTtZQUNqQ1IsT0FBTyxDQUFDLFdBQVcsR0FBR1E7UUFDMUI7UUFFQSxJQUFJLE9BQU9DLFlBQVksYUFBYTtZQUNoQ1QsT0FBTyxDQUFDLFVBQVUsR0FBR1M7UUFDekI7UUFFQSxJQUFJLE9BQU9DLFlBQVksYUFBYTtZQUNoQ1YsT0FBTyxDQUFDLFVBQVUsR0FBR1U7UUFDekI7UUFFQSxJQUFJLE9BQU9DLFlBQVksYUFBYTtZQUNoQ1gsT0FBTyxDQUFDLFVBQVUsR0FBR1c7UUFDekI7UUFFQSxJQUFJLE9BQU9DLGVBQWUsYUFBYTtZQUNuQ1osT0FBTyxDQUFDLGFBQWEsR0FBR1k7UUFDNUI7UUFFQSxJQUFJLE9BQU9DLGFBQWEsYUFBYTtZQUNqQ2IsT0FBTyxDQUFDLFdBQVcsR0FBR2E7UUFDMUI7UUFFQSxJQUFJLE9BQU9DLG1CQUFtQixhQUFhO1lBQ3ZDZCxPQUFPLENBQUMsaUJBQWlCLEdBQUdjO1FBQ2hDO1FBRUEsSUFBSSxPQUFPQyx5QkFBeUIsYUFBYTtZQUM3Q2YsT0FBTyxDQUFDLHVCQUF1QixHQUFHZTtRQUN0QztRQUVBLElBQUksT0FBT0MsbUJBQW1CLGFBQWE7WUFDdkNoQixPQUFPLENBQUMsaUJBQWlCLEdBQUdnQjtRQUNoQztRQUVBLElBQUksT0FBT0MsdUJBQXVCLGFBQWE7WUFDM0NqQixPQUFPLENBQUMscUJBQXFCLEdBQUdpQjtRQUNwQztRQUVBLElBQUksT0FBT0MsMEJBQTBCLGFBQWE7WUFDOUNsQixPQUFPLENBQUMsd0JBQXdCLEdBQUdrQjtRQUN2QztRQUVBLElBQUksT0FBT0MsdUJBQXVCLGFBQWE7WUFDM0NuQixPQUFPLENBQUMscUJBQXFCLEdBQUdtQjtRQUNwQztRQUVBLElBQUksT0FBT0Msa0JBQWtCLGFBQWE7WUFDdENwQixPQUFPLENBQUMsZ0JBQWdCLEdBQUdvQjtRQUMvQjtRQUVBLElBQUksT0FBT0MsMEJBQTBCLGFBQWE7WUFDOUNyQixPQUFPLENBQUMsd0JBQXdCLEdBQUdxQjtRQUN2QztRQUVBLElBQUksT0FBT0MsbUJBQW1CLGFBQWE7WUFDdkN0QixPQUFPLENBQUMsaUJBQWlCLEdBQUdzQjtRQUNoQztRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUNoQyxNQUFNLENBQUNXLElBQUksQ0FBQyxRQUFRRixTQUFTO1lBQzNDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7S0FPQyxHQUNELE1BQU11QixlQUFlO1FBQ2pCLE1BQU14QixVQUFVO1FBQ2hCLElBQUlDLFVBQVUsQ0FBQztRQUVmLE9BQU8sTUFBTSxJQUFJLENBQUNWLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7S0FRQyxHQUNELE1BQU13QixJQUFJckIsVUFBVSxFQUFFO1FBQ2xCLE1BQU1KLFVBQVUsMEJBQTBCMEIsT0FBTyxDQUFDLGdCQUFnQnRCO1FBQ2xFLElBQUlILFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csZUFBZSxhQUFhO1lBQ25DLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBR0EsT0FBTyxNQUFNLElBQUksQ0FBQ0UsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXVCQyxHQUNELE1BQU0wQixPQUFPdkIsVUFBVSxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLGNBQWMsRUFBRUMsb0JBQW9CLEVBQUVDLGNBQWMsRUFBRUMsa0JBQWtCLEVBQUVDLHFCQUFxQixFQUFFO1FBQ2pOLE1BQU1uQixVQUFVLDBCQUEwQjBCLE9BQU8sQ0FBQyxnQkFBZ0J0QjtRQUNsRSxJQUFJSCxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGVBQWUsYUFBYTtZQUNuQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT2dCLFNBQVMsYUFBYTtZQUM3QixNQUFNLElBQUloQixrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU9nQixTQUFTLGFBQWE7WUFDN0JKLE9BQU8sQ0FBQyxPQUFPLEdBQUdJO1FBQ3RCO1FBRUEsSUFBSSxPQUFPQyxZQUFZLGFBQWE7WUFDaENMLE9BQU8sQ0FBQyxVQUFVLEdBQUdLO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxZQUFZLGFBQWE7WUFDaENOLE9BQU8sQ0FBQyxVQUFVLEdBQUdNO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxXQUFXLGFBQWE7WUFDL0JQLE9BQU8sQ0FBQyxTQUFTLEdBQUdPO1FBQ3hCO1FBRUEsSUFBSSxPQUFPQyxhQUFhLGFBQWE7WUFDakNSLE9BQU8sQ0FBQyxXQUFXLEdBQUdRO1FBQzFCO1FBRUEsSUFBSSxPQUFPQyxZQUFZLGFBQWE7WUFDaENULE9BQU8sQ0FBQyxVQUFVLEdBQUdTO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxZQUFZLGFBQWE7WUFDaENWLE9BQU8sQ0FBQyxVQUFVLEdBQUdVO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxZQUFZLGFBQWE7WUFDaENYLE9BQU8sQ0FBQyxVQUFVLEdBQUdXO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxlQUFlLGFBQWE7WUFDbkNaLE9BQU8sQ0FBQyxhQUFhLEdBQUdZO1FBQzVCO1FBRUEsSUFBSSxPQUFPQyxhQUFhLGFBQWE7WUFDakNiLE9BQU8sQ0FBQyxXQUFXLEdBQUdhO1FBQzFCO1FBRUEsSUFBSSxPQUFPQyxtQkFBbUIsYUFBYTtZQUN2Q2QsT0FBTyxDQUFDLGlCQUFpQixHQUFHYztRQUNoQztRQUVBLElBQUksT0FBT0MseUJBQXlCLGFBQWE7WUFDN0NmLE9BQU8sQ0FBQyx1QkFBdUIsR0FBR2U7UUFDdEM7UUFFQSxJQUFJLE9BQU9DLG1CQUFtQixhQUFhO1lBQ3ZDaEIsT0FBTyxDQUFDLGlCQUFpQixHQUFHZ0I7UUFDaEM7UUFFQSxJQUFJLE9BQU9DLHVCQUF1QixhQUFhO1lBQzNDakIsT0FBTyxDQUFDLHFCQUFxQixHQUFHaUI7UUFDcEM7UUFFQSxJQUFJLE9BQU9DLDBCQUEwQixhQUFhO1lBQzlDbEIsT0FBTyxDQUFDLHdCQUF3QixHQUFHa0I7UUFDdkM7UUFFQSxPQUFPLE1BQU0sSUFBSSxDQUFDNUIsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTTJCLE9BQU94QixVQUFVLEVBQUU7UUFDckIsTUFBTUosVUFBVSwwQkFBMEIwQixPQUFPLENBQUMsZ0JBQWdCdEI7UUFDbEUsSUFBSUgsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxlQUFlLGFBQWE7WUFDbkMsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFHQSxPQUFPLE1BQU0sSUFBSSxDQUFDRSxNQUFNLENBQUNXLElBQUksQ0FBQyxVQUFVRixTQUFTO1lBQzdDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7Ozs7O0tBV0MsR0FDRCxNQUFNNEIsZ0JBQWdCekIsVUFBVSxFQUFFTixPQUFPLEVBQUVDLE1BQU0sRUFBRTtRQUMvQyxNQUFNQyxVQUFVLHNDQUFzQzBCLE9BQU8sQ0FBQyxnQkFBZ0J0QjtRQUM5RSxJQUFJSCxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGVBQWUsYUFBYTtZQUNuQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUdBLElBQUksT0FBT1MsWUFBWSxhQUFhO1lBQ2hDRyxPQUFPLENBQUMsVUFBVSxHQUFHSDtRQUN6QjtRQUVBLElBQUksT0FBT0MsV0FBVyxhQUFhO1lBQy9CRSxPQUFPLENBQUMsU0FBUyxHQUFHRjtRQUN4QjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBcUJDLEdBQ0QsTUFBTTZCLGlCQUFpQjFCLFVBQVUsRUFBRTJCLElBQUksRUFBRUMsUUFBUSxFQUFFbkIsVUFBVSxFQUFFQyxRQUFRLEVBQUVtQixhQUFhLEtBQU8sQ0FBQyxFQUFFO1FBQzVGLE1BQU1qQyxVQUFVLHNDQUFzQzBCLE9BQU8sQ0FBQyxnQkFBZ0J0QjtRQUM5RSxJQUFJSCxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGVBQWUsYUFBYTtZQUNuQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBTzBDLFNBQVMsYUFBYTtZQUM3QixNQUFNLElBQUkxQyxrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU8yQyxhQUFhLGFBQWE7WUFDakMsTUFBTSxJQUFJM0Msa0JBQWtCO1FBQ2hDO1FBR0EsSUFBSSxPQUFPd0IsZUFBZSxhQUFhO1lBQ25DWixPQUFPLENBQUMsYUFBYSxHQUFHWTtRQUM1QjtRQUVBLElBQUksT0FBT0MsYUFBYSxhQUFhO1lBQ2pDYixPQUFPLENBQUMsV0FBVyxHQUFHYTtRQUMxQjtRQUVBLElBQUksT0FBT2lCLFNBQVMsYUFBYTtZQUM3QjlCLE9BQU8sQ0FBQyxPQUFPLEdBQUc4QjtRQUN0QjtRQUVBLElBQUksT0FBT0MsYUFBYSxhQUFhO1lBQ2pDL0IsT0FBTyxDQUFDLFdBQVcsR0FBRytCLFNBQVNFLFFBQVE7UUFDM0M7UUFFQSxNQUFNQyxPQUFPSixLQUFLSSxJQUFJO1FBRXRCLE1BQU1DLGFBQWE7WUFDZixnQkFBZ0I7UUFDcEI7UUFFQSxJQUFJQyxLQUFLQztRQUNULElBQUlDLFdBQVdEO1FBRWYsSUFBSUUsaUJBQWlCO1FBR3JCLElBQUlDLGVBQWVDLE9BQU9DLElBQUksQ0FBQztRQUMvQixJQUFJQyxtQkFBbUI7UUFDdkIsSUFBSUMsb0JBQW9CO1FBRXhCLE1BQU1DLGFBQWEsSUFBSSxDQUFDdkQsTUFBTTtRQUU5QixlQUFld0QsWUFBWUMsYUFBYSxLQUFLO1lBQ3pDLElBQUdSLGlCQUFpQixLQUFLSyxvQkFBb0J0RCxPQUFPMEQsVUFBVSxFQUFFO2dCQUM1RDtZQUNKO1lBRUEsTUFBTUMsUUFBUUw7WUFDZCxNQUFNTSxNQUFNTixvQkFBb0JELG1CQUFtQjtZQUVuRCxJQUFHLENBQUNJLGNBQWNILHNCQUFzQixHQUFHO2dCQUN2Q1QsVUFBVSxDQUFDLGdCQUFnQixHQUFHLFdBQVdjLFFBQVEsTUFBTUMsTUFBTSxNQUFNaEI7WUFDdkU7WUFFQSxJQUFJRSxJQUFJO2dCQUNKRCxVQUFVLENBQUMsZ0JBQWdCLEdBQUdDO1lBQ2xDO1lBRUFwQyxPQUFPLENBQUMsT0FBTyxHQUFHO2dCQUNkbUQsTUFBTTtnQkFDTkMsTUFBTVo7Z0JBQ05hLFVBQVV2QixLQUFLdUIsUUFBUTtnQkFDdkJuQixNQUFNUztZQUNWO1lBRUFMLFdBQVcsTUFBTU8sV0FBVzVDLElBQUksQ0FBQyxRQUFRRixTQUFTb0MsWUFBWW5DO1lBRTlELElBQUksQ0FBQ29DLElBQUk7Z0JBQ0xBLEtBQUtFLFFBQVEsQ0FBQyxNQUFNO1lBQ3hCO1lBRUEsSUFBSU4sZUFBZSxNQUFNO2dCQUNyQkEsV0FBVztvQkFDUHNCLEtBQUtoQixRQUFRLENBQUMsTUFBTTtvQkFDcEJpQixVQUFVQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ1IsUUFBTTNELE9BQU8wRCxVQUFVLElBQUkxRCxPQUFPMEQsVUFBVSxFQUFFZCxRQUFRQSxPQUFPO29CQUNqRndCLGNBQWNSLE1BQUk7b0JBQ2xCUyxhQUFhckIsUUFBUSxDQUFDLGNBQWM7b0JBQ3BDQyxnQkFBZ0JELFFBQVEsQ0FBQyxpQkFBaUI7Z0JBQzlDO1lBQ0o7WUFFQU0scUJBQXFCdEQsT0FBTzBELFVBQVU7UUFDMUM7UUFFQSxPQUFPLE1BQU0sSUFBSVksUUFBUSxDQUFDQyxTQUFTQztZQUMvQixNQUFNQyxjQUFjLElBQUl4RSxPQUFPeUUsUUFBUTtZQUN2Q0QsWUFBWUUsTUFBTSxHQUFHLE9BQU9DLFdBQVdDLFVBQVVDO2dCQUM3QyxJQUFJO29CQUNBLCtDQUErQztvQkFDL0MsTUFBTUMsZ0JBQWdCNUIsT0FBTzZCLFVBQVUsQ0FBQ0o7b0JBQ3hDLE1BQU1LLGNBQWNmLEtBQUtnQixJQUFJLENBQUNILGdCQUFnQi9FLE9BQU8wRCxVQUFVO29CQUMvRCxNQUFNeUIsU0FBUyxFQUFFO29CQUVqQixJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSUgsYUFBYUcsSUFBSzt3QkFDakMsTUFBTUMsUUFBUVQsVUFBVVUsS0FBSyxDQUFDRixJQUFJcEYsT0FBTzBELFVBQVUsRUFBRSxDQUFDMEIsSUFBSSxLQUFLcEYsT0FBTzBELFVBQVU7d0JBQ2hGeUIsT0FBT0ksSUFBSSxDQUFDRjtvQkFDaEI7b0JBRUEsS0FBSyxNQUFNQSxTQUFTRixPQUFRO3dCQUN4QixNQUFNSyxZQUFZckMsT0FBTzZCLFVBQVUsQ0FBQ0s7d0JBRXBDLElBQUdHLFlBQVluQyxvQkFBb0JyRCxPQUFPMEQsVUFBVSxFQUFFOzRCQUNsRCxlQUFlOzRCQUNmUixlQUFlQyxPQUFPc0MsTUFBTSxDQUFDO2dDQUFDdkM7Z0NBQWNtQzs2QkFBTTs0QkFDbERoQyxtQkFBbUJGLE9BQU82QixVQUFVLENBQUM5Qjs0QkFDckMsTUFBTU07NEJBQ05OLGVBQWVDLE9BQU9DLElBQUksQ0FBQzs0QkFDM0JDLG1CQUFtQjt3QkFDdkIsT0FBTyxJQUFHbUMsWUFBWW5DLG1CQUFtQnJELE9BQU8wRCxVQUFVLEVBQUU7NEJBQ3hELHlDQUF5Qzs0QkFDekMsTUFBTWdDLGdCQUFnQjFGLE9BQU8wRCxVQUFVLEdBQUdMOzRCQUMxQyxNQUFNc0Msa0JBQWtCTixNQUFNQyxLQUFLLENBQUMsR0FBR0k7NEJBQ3ZDeEMsZUFBZUMsT0FBT3NDLE1BQU0sQ0FBQztnQ0FBQ3ZDO2dDQUFjeUM7NkJBQWdCOzRCQUM1RHRDLG1CQUFtQkYsT0FBTzZCLFVBQVUsQ0FBQzlCOzRCQUNyQyxNQUFNTTs0QkFDTk4sZUFBZW1DLE1BQU1DLEtBQUssQ0FBQ0ksZUFBZTNDOzRCQUMxQ00sbUJBQW1CbUMsWUFBWUU7d0JBQ25DLE9BQU87NEJBQ0gsNEJBQTRCOzRCQUM1QnhDLGVBQWVDLE9BQU9zQyxNQUFNLENBQUM7Z0NBQUN2QztnQ0FBY21DOzZCQUFNOzRCQUNsRGhDLG1CQUFtQm1DLFlBQVluQzt3QkFDbkM7b0JBQ0o7b0JBRUF5QjtnQkFDSixFQUFFLE9BQU9jLEdBQUc7b0JBQ1JkLFNBQVNjO2dCQUNiO1lBQ0o7WUFFQW5CLFlBQVlvQixFQUFFLENBQUMsVUFBVTtnQkFDckIsSUFBR3hDLG1CQUFtQixHQUFHO29CQUNyQixJQUFJO3dCQUNBLE1BQU1HLFlBQVk7b0JBQ3RCLEVBQUUsT0FBT29DLEdBQUc7d0JBQ1JwQixPQUFPb0I7b0JBQ1g7Z0JBQ0o7Z0JBRUFyQixRQUFRdkI7WUFDWjtZQUVBeUIsWUFBWW9CLEVBQUUsQ0FBQyxTQUFTLENBQUNDO2dCQUNyQnRCLE9BQU9zQjtZQUNYO1lBRUF0RCxLQUFLdUQsTUFBTSxDQUFDQyxJQUFJLENBQUN2QjtRQUNyQjtJQUVKO0lBRUE7Ozs7Ozs7OztLQVNDLEdBQ0QsTUFBTXdCLGNBQWNwRixVQUFVLEVBQUVxRixZQUFZLEVBQUU7UUFDMUMsTUFBTXpGLFVBQVUscURBQXFEMEIsT0FBTyxDQUFDLGdCQUFnQnRCLFlBQVlzQixPQUFPLENBQUMsa0JBQWtCK0Q7UUFDbkksSUFBSXhGLFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csZUFBZSxhQUFhO1lBQ25DLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBRUEsSUFBSSxPQUFPb0csaUJBQWlCLGFBQWE7WUFDckMsTUFBTSxJQUFJcEcsa0JBQWtCO1FBQ2hDO1FBR0EsT0FBTyxNQUFNLElBQUksQ0FBQ0UsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7OztLQVdDLEdBQ0QsTUFBTXlGLGlCQUFpQnRGLFVBQVUsRUFBRXFGLFlBQVksRUFBRTtRQUM3QyxNQUFNekYsVUFBVSxxREFBcUQwQixPQUFPLENBQUMsZ0JBQWdCdEIsWUFBWXNCLE9BQU8sQ0FBQyxrQkFBa0IrRDtRQUNuSSxJQUFJeEYsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxlQUFlLGFBQWE7WUFDbkMsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU9vRyxpQkFBaUIsYUFBYTtZQUNyQyxNQUFNLElBQUlwRyxrQkFBa0I7UUFDaEM7UUFHQSxPQUFPLE1BQU0sSUFBSSxDQUFDRSxNQUFNLENBQUNXLElBQUksQ0FBQyxTQUFTRixTQUFTO1lBQzVDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7OztLQVNDLEdBQ0QsTUFBTTBGLGlCQUFpQnZGLFVBQVUsRUFBRXFGLFlBQVksRUFBRTtRQUM3QyxNQUFNekYsVUFBVSxxREFBcUQwQixPQUFPLENBQUMsZ0JBQWdCdEIsWUFBWXNCLE9BQU8sQ0FBQyxrQkFBa0IrRDtRQUNuSSxJQUFJeEYsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxlQUFlLGFBQWE7WUFDbkMsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU9vRyxpQkFBaUIsYUFBYTtZQUNyQyxNQUFNLElBQUlwRyxrQkFBa0I7UUFDaEM7UUFHQSxPQUFPLE1BQU0sSUFBSSxDQUFDRSxNQUFNLENBQUNXLElBQUksQ0FBQyxVQUFVRixTQUFTO1lBQzdDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7Ozs7O0tBV0MsR0FDRCxNQUFNMkYsWUFBWXhGLFVBQVUsRUFBRXFGLFlBQVksRUFBRUksT0FBTyxFQUFFO1FBQ2pELE1BQU03RixVQUFVLHNFQUFzRTBCLE9BQU8sQ0FBQyxnQkFBZ0J0QixZQUFZc0IsT0FBTyxDQUFDLGtCQUFrQitELGNBQWMvRCxPQUFPLENBQUMsYUFBYW1FO1FBQ3ZMLElBQUk1RixVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGVBQWUsYUFBYTtZQUNuQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT29HLGlCQUFpQixhQUFhO1lBQ3JDLE1BQU0sSUFBSXBHLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT3dHLFlBQVksYUFBYTtZQUNoQyxNQUFNLElBQUl4RyxrQkFBa0I7UUFDaEM7UUFHQSxPQUFPLE1BQU0sSUFBSSxDQUFDRSxNQUFNLENBQUNXLElBQUksQ0FBQyxRQUFRRixTQUFTO1lBQzNDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU02RixtQkFBbUIxRixVQUFVLEVBQUVxRixZQUFZLEVBQUU7UUFDL0MsTUFBTXpGLFVBQVUsOERBQThEMEIsT0FBTyxDQUFDLGdCQUFnQnRCLFlBQVlzQixPQUFPLENBQUMsa0JBQWtCK0Q7UUFDNUksSUFBSXhGLFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csZUFBZSxhQUFhO1lBQ25DLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBRUEsSUFBSSxPQUFPb0csaUJBQWlCLGFBQWE7WUFDckMsTUFBTSxJQUFJcEcsa0JBQWtCO1FBQ2hDO1FBR0EsT0FBTyxNQUFNLElBQUksQ0FBQ0UsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0MsU0FBUztJQUNoQjtJQUVBOzs7Ozs7Ozs7OztLQVdDLEdBQ0QsTUFBTThGLGVBQWUzRixVQUFVLEVBQUVOLE9BQU8sRUFBRUMsTUFBTSxFQUFFO1FBQzlDLE1BQU1DLFVBQVUscUNBQXFDMEIsT0FBTyxDQUFDLGdCQUFnQnRCO1FBQzdFLElBQUlILFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csZUFBZSxhQUFhO1lBQ25DLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBR0EsSUFBSSxPQUFPUyxZQUFZLGFBQWE7WUFDaENHLE9BQU8sQ0FBQyxVQUFVLEdBQUdIO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxXQUFXLGFBQWE7WUFDL0JFLE9BQU8sQ0FBQyxTQUFTLEdBQUdGO1FBQ3hCO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JDLEdBQ0QsTUFBTStGLGdCQUFnQjVGLFVBQVUsRUFBRTZGLElBQUksRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFO1FBQ25FLE1BQU1yRyxVQUFVLHFDQUFxQzBCLE9BQU8sQ0FBQyxnQkFBZ0J0QjtRQUM3RSxJQUFJSCxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGVBQWUsYUFBYTtZQUNuQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUdBLElBQUksT0FBTzRHLFNBQVMsYUFBYTtZQUM3QmhHLE9BQU8sQ0FBQyxPQUFPLEdBQUdnRztRQUN0QjtRQUVBLElBQUksT0FBT0MsVUFBVSxhQUFhO1lBQzlCakcsT0FBTyxDQUFDLFFBQVEsR0FBR2lHO1FBQ3ZCO1FBRUEsSUFBSSxPQUFPQyxVQUFVLGFBQWE7WUFDOUJsRyxPQUFPLENBQUMsT0FBTyxHQUFHa0c7UUFDdEI7UUFFQSxJQUFJLE9BQU9DLFdBQVcsYUFBYTtZQUMvQm5HLE9BQU8sQ0FBQyxTQUFTLEdBQUdtRztRQUN4QjtRQUVBLElBQUksT0FBT0MsWUFBWSxhQUFhO1lBQ2hDcEcsT0FBTyxDQUFDLFVBQVUsR0FBR29HO1FBQ3pCO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FBQzlHLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLFFBQVFGLFNBQVM7WUFDM0MsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7O0tBU0MsR0FDRCxNQUFNcUcsYUFBYWxHLFVBQVUsRUFBRW1HLFdBQVcsRUFBRTtRQUN4QyxNQUFNdkcsVUFBVSxtREFBbUQwQixPQUFPLENBQUMsZ0JBQWdCdEIsWUFBWXNCLE9BQU8sQ0FBQyxpQkFBaUI2RTtRQUNoSSxJQUFJdEcsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxlQUFlLGFBQWE7WUFDbkMsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU9rSCxnQkFBZ0IsYUFBYTtZQUNwQyxNQUFNLElBQUlsSCxrQkFBa0I7UUFDaEM7UUFHQSxPQUFPLE1BQU0sSUFBSSxDQUFDRSxNQUFNLENBQUNXLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNdUcsY0FBY3BHLFVBQVUsRUFBRTtRQUM1QixNQUFNSixVQUFVLG9DQUFvQzBCLE9BQU8sQ0FBQyxnQkFBZ0J0QjtRQUM1RSxJQUFJSCxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGVBQWUsYUFBYTtZQUNuQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUdBLE9BQU8sTUFBTSxJQUFJLENBQUNFLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNELE1BQU13RyxlQUFlckcsVUFBVSxFQUFFc0csR0FBRyxFQUFFQyxLQUFLLEVBQUU7UUFDekMsTUFBTTNHLFVBQVUsb0NBQW9DMEIsT0FBTyxDQUFDLGdCQUFnQnRCO1FBQzVFLElBQUlILFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csZUFBZSxhQUFhO1lBQ25DLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBRUEsSUFBSSxPQUFPcUgsUUFBUSxhQUFhO1lBQzVCLE1BQU0sSUFBSXJILGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT3NILFVBQVUsYUFBYTtZQUM5QixNQUFNLElBQUl0SCxrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU9xSCxRQUFRLGFBQWE7WUFDNUJ6RyxPQUFPLENBQUMsTUFBTSxHQUFHeUc7UUFDckI7UUFFQSxJQUFJLE9BQU9DLFVBQVUsYUFBYTtZQUM5QjFHLE9BQU8sQ0FBQyxRQUFRLEdBQUcwRztRQUN2QjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUNwSCxNQUFNLENBQUNXLElBQUksQ0FBQyxRQUFRRixTQUFTO1lBQzNDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7OztLQVNDLEdBQ0QsTUFBTTJHLFlBQVl4RyxVQUFVLEVBQUV5RyxVQUFVLEVBQUU7UUFDdEMsTUFBTTdHLFVBQVUsaURBQWlEMEIsT0FBTyxDQUFDLGdCQUFnQnRCLFlBQVlzQixPQUFPLENBQUMsZ0JBQWdCbUY7UUFDN0gsSUFBSTVHLFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csZUFBZSxhQUFhO1lBQ25DLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBRUEsSUFBSSxPQUFPd0gsZUFBZSxhQUFhO1lBQ25DLE1BQU0sSUFBSXhILGtCQUFrQjtRQUNoQztRQUdBLE9BQU8sTUFBTSxJQUFJLENBQUNFLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNELE1BQU02RyxlQUFlMUcsVUFBVSxFQUFFeUcsVUFBVSxFQUFFSCxHQUFHLEVBQUVDLEtBQUssRUFBRTtRQUNyRCxNQUFNM0csVUFBVSxpREFBaUQwQixPQUFPLENBQUMsZ0JBQWdCdEIsWUFBWXNCLE9BQU8sQ0FBQyxnQkFBZ0JtRjtRQUM3SCxJQUFJNUcsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxlQUFlLGFBQWE7WUFDbkMsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU93SCxlQUFlLGFBQWE7WUFDbkMsTUFBTSxJQUFJeEgsa0JBQWtCO1FBQ2hDO1FBRUEsSUFBSSxPQUFPcUgsUUFBUSxhQUFhO1lBQzVCLE1BQU0sSUFBSXJILGtCQUFrQjtRQUNoQztRQUdBLElBQUksT0FBT3FILFFBQVEsYUFBYTtZQUM1QnpHLE9BQU8sQ0FBQyxNQUFNLEdBQUd5RztRQUNyQjtRQUVBLElBQUksT0FBT0MsVUFBVSxhQUFhO1lBQzlCMUcsT0FBTyxDQUFDLFFBQVEsR0FBRzBHO1FBQ3ZCO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FBQ3BILE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7O0tBU0MsR0FDRCxNQUFNOEcsZUFBZTNHLFVBQVUsRUFBRXlHLFVBQVUsRUFBRTtRQUN6QyxNQUFNN0csVUFBVSxpREFBaUQwQixPQUFPLENBQUMsZ0JBQWdCdEIsWUFBWXNCLE9BQU8sQ0FBQyxnQkFBZ0JtRjtRQUM3SCxJQUFJNUcsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxlQUFlLGFBQWE7WUFDbkMsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU93SCxlQUFlLGFBQWE7WUFDbkMsTUFBTSxJQUFJeEgsa0JBQWtCO1FBQ2hDO1FBR0EsT0FBTyxNQUFNLElBQUksQ0FBQ0UsTUFBTSxDQUFDVyxJQUFJLENBQUMsVUFBVUYsU0FBUztZQUM3QyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtBQUNKO0FBRUErRyxPQUFPQyxPQUFPLEdBQUd0SCIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2tuZXN0Ly4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL2Z1bmN0aW9ucy5qcz8yMWQxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxuY2xhc3MgRnVuY3Rpb25zIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGlzdCBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9qZWN0J3MgZnVuY3Rpb25zLiBZb3UgY2FuIHVzZSB0aGUgcXVlcnkgcGFyYW1zIHRvXG4gICAgICogZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdChxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmdW5jdGlvbi4gWW91IGNhbiBwYXNzIGEgbGlzdCBvZlxuICAgICAqIFtwZXJtaXNzaW9uc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3Blcm1pc3Npb25zKSB0byBhbGxvdyBkaWZmZXJlbnRcbiAgICAgKiBwcm9qZWN0IHVzZXJzIG9yIHRlYW0gd2l0aCBhY2Nlc3MgdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24gdXNpbmcgdGhlIGNsaWVudFxuICAgICAqIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVudGltZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZWR1bGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9nZ2luZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeXBvaW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbGxhdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyUmVwb3NpdG9yeUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyQnJhbmNoXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcm92aWRlclNpbGVudE1vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJSb290RGlyZWN0b3J5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlUmVwb3NpdG9yeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZU93bmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlUm9vdERpcmVjdG9yeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZUJyYW5jaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShmdW5jdGlvbklkLCBuYW1lLCBydW50aW1lLCBleGVjdXRlLCBldmVudHMsIHNjaGVkdWxlLCB0aW1lb3V0LCBlbmFibGVkLCBsb2dnaW5nLCBlbnRyeXBvaW50LCBjb21tYW5kcywgaW5zdGFsbGF0aW9uSWQsIHByb3ZpZGVyUmVwb3NpdG9yeUlkLCBwcm92aWRlckJyYW5jaCwgcHJvdmlkZXJTaWxlbnRNb2RlLCBwcm92aWRlclJvb3REaXJlY3RvcnksIHRlbXBsYXRlUmVwb3NpdG9yeSwgdGVtcGxhdGVPd25lciwgdGVtcGxhdGVSb290RGlyZWN0b3J5LCB0ZW1wbGF0ZUJyYW5jaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcnVudGltZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicnVudGltZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Z1bmN0aW9uSWQnXSA9IGZ1bmN0aW9uSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBydW50aW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncnVudGltZSddID0gcnVudGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZXhlY3V0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2V4ZWN1dGUnXSA9IGV4ZWN1dGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2V2ZW50cyddID0gZXZlbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NjaGVkdWxlJ10gPSBzY2hlZHVsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RpbWVvdXQnXSA9IHRpbWVvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsb2dnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbG9nZ2luZyddID0gbG9nZ2luZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnlwb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VudHJ5cG9pbnQnXSA9IGVudHJ5cG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29tbWFuZHMnXSA9IGNvbW1hbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YWxsYXRpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2luc3RhbGxhdGlvbklkJ10gPSBpbnN0YWxsYXRpb25JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJSZXBvc2l0b3J5SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlclJlcG9zaXRvcnlJZCddID0gcHJvdmlkZXJSZXBvc2l0b3J5SWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyQnJhbmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJCcmFuY2gnXSA9IHByb3ZpZGVyQnJhbmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlclNpbGVudE1vZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlclNpbGVudE1vZGUnXSA9IHByb3ZpZGVyU2lsZW50TW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJSb290RGlyZWN0b3J5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJSb290RGlyZWN0b3J5J10gPSBwcm92aWRlclJvb3REaXJlY3Rvcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlUmVwb3NpdG9yeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RlbXBsYXRlUmVwb3NpdG9yeSddID0gdGVtcGxhdGVSZXBvc2l0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZU93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVtcGxhdGVPd25lciddID0gdGVtcGxhdGVPd25lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVSb290RGlyZWN0b3J5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVtcGxhdGVSb290RGlyZWN0b3J5J10gPSB0ZW1wbGF0ZVJvb3REaXJlY3Rvcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlQnJhbmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVtcGxhdGVCcmFuY2gnXSA9IHRlbXBsYXRlQnJhbmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHJ1bnRpbWVzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBydW50aW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlIG9uIHlvdXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0UnVudGltZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy9ydW50aW1lcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmdW5jdGlvblxuICAgICAqXG4gICAgICogR2V0IGEgZnVuY3Rpb24gYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KGZ1bmN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIFVwZGF0ZSBmdW5jdGlvbiBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydW50aW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXhlY3V0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlZHVsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsb2dnaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5cG9pbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFsbGF0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJSZXBvc2l0b3J5SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJCcmFuY2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3ZpZGVyU2lsZW50TW9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlclJvb3REaXJlY3RvcnlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoZnVuY3Rpb25JZCwgbmFtZSwgcnVudGltZSwgZXhlY3V0ZSwgZXZlbnRzLCBzY2hlZHVsZSwgdGltZW91dCwgZW5hYmxlZCwgbG9nZ2luZywgZW50cnlwb2ludCwgY29tbWFuZHMsIGluc3RhbGxhdGlvbklkLCBwcm92aWRlclJlcG9zaXRvcnlJZCwgcHJvdmlkZXJCcmFuY2gsIHByb3ZpZGVyU2lsZW50TW9kZSwgcHJvdmlkZXJSb290RGlyZWN0b3J5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcnVudGltZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3J1bnRpbWUnXSA9IHJ1bnRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydleGVjdXRlJ10gPSBleGVjdXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydldmVudHMnXSA9IGV2ZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZWR1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY2hlZHVsZSddID0gc2NoZWR1bGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aW1lb3V0J10gPSB0aW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbG9nZ2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2xvZ2dpbmcnXSA9IGxvZ2dpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5cG9pbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbnRyeXBvaW50J10gPSBlbnRyeXBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbW1hbmRzJ10gPSBjb21tYW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFsbGF0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydpbnN0YWxsYXRpb25JZCddID0gaW5zdGFsbGF0aW9uSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyUmVwb3NpdG9yeUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJSZXBvc2l0b3J5SWQnXSA9IHByb3ZpZGVyUmVwb3NpdG9yeUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlckJyYW5jaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVyQnJhbmNoJ10gPSBwcm92aWRlckJyYW5jaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJTaWxlbnRNb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJTaWxlbnRNb2RlJ10gPSBwcm92aWRlclNpbGVudE1vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyUm9vdERpcmVjdG9yeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVyUm9vdERpcmVjdG9yeSddID0gcHJvdmlkZXJSb290RGlyZWN0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBmdW5jdGlvblxuICAgICAqXG4gICAgICogRGVsZXRlIGEgZnVuY3Rpb24gYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGZ1bmN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGRlcGxveW1lbnRzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgcHJvamVjdCdzIGNvZGUgZGVwbG95bWVudHMuIFlvdSBjYW4gdXNlIHRoZSBxdWVyeVxuICAgICAqIHBhcmFtcyB0byBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3REZXBsb3ltZW50cyhmdW5jdGlvbklkLCBxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9kZXBsb3ltZW50cycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBkZXBsb3ltZW50XG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgZnVuY3Rpb24gY29kZSBkZXBsb3ltZW50LiBVc2UgdGhpcyBlbmRwb2ludCB0byB1cGxvYWQgYSBuZXdcbiAgICAgKiB2ZXJzaW9uIG9mIHlvdXIgY29kZSBmdW5jdGlvbi4gVG8gZXhlY3V0ZSB5b3VyIG5ld2x5IHVwbG9hZGVkIGNvZGUsIHlvdSdsbFxuICAgICAqIG5lZWQgdG8gdXBkYXRlIHRoZSBmdW5jdGlvbidzIGRlcGxveW1lbnQgdG8gdXNlIHlvdXIgbmV3IGRlcGxveW1lbnQgVUlELlxuICAgICAqIFxuICAgICAqIFRoaXMgZW5kcG9pbnQgYWNjZXB0cyBhIHRhci5neiBmaWxlIGNvbXByZXNzZWQgd2l0aCB5b3VyIGNvZGUuIE1ha2Ugc3VyZSB0b1xuICAgICAqIGluY2x1ZGUgYW55IGRlcGVuZGVuY2llcyB5b3VyIGNvZGUgaGFzIHdpdGhpbiB0aGUgY29tcHJlc3NlZCBmaWxlLiBZb3UgY2FuXG4gICAgICogbGVhcm4gbW9yZSBhYm91dCBjb2RlIHBhY2thZ2luZyBpbiB0aGUgW0FwcHdyaXRlIENsb3VkIEZ1bmN0aW9uc1xuICAgICAqIHR1dG9yaWFsXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvZnVuY3Rpb25zKS5cbiAgICAgKiBcbiAgICAgKiBVc2UgdGhlIFwiY29tbWFuZFwiIHBhcmFtIHRvIHNldCB0aGUgZW50cnlwb2ludCB1c2VkIHRvIGV4ZWN1dGUgeW91ciBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge0lucHV0RmlsZX0gY29kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlwb2ludFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZURlcGxveW1lbnQoZnVuY3Rpb25JZCwgY29kZSwgYWN0aXZhdGUsIGVudHJ5cG9pbnQsIGNvbW1hbmRzLCBvblByb2dyZXNzID0gKCkgPT4ge30pIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9kZXBsb3ltZW50cycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvZGVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhY3RpdmF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYWN0aXZhdGVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5cG9pbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbnRyeXBvaW50J10gPSBlbnRyeXBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbW1hbmRzJ10gPSBjb21tYW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvZGUnXSA9IGNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFjdGl2YXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYWN0aXZhdGUnXSA9IGFjdGl2YXRlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaXplID0gY29kZS5zaXplO1xuXG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGxldCBjaHVua3NVcGxvYWRlZCA9IDA7XG5cblxuICAgICAgICBsZXQgY3VycmVudENodW5rID0gQnVmZmVyLmZyb20oJycpO1xuICAgICAgICBsZXQgY3VycmVudENodW5rU2l6ZSA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50Q2h1bmtTdGFydCA9IDA7XG5cbiAgICAgICAgY29uc3Qgc2VsZkNsaWVudCA9IHRoaXMuY2xpZW50O1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZENodW5rKGxhc3RVcGxvYWQgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYoY2h1bmtzVXBsb2FkZWQgLSAxID49IGN1cnJlbnRDaHVua1N0YXJ0IC8gY2xpZW50LkNIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY3VycmVudENodW5rU3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBjdXJyZW50Q2h1bmtTdGFydCArIGN1cnJlbnRDaHVua1NpemUgLSAxO1xuXG4gICAgICAgICAgICBpZighbGFzdFVwbG9hZCB8fCBjdXJyZW50Q2h1bmtTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGFwaUhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXSA9ICdieXRlcyAnICsgc3RhcnQgKyAnLScgKyBlbmQgKyAnLycgKyBzaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBhcGlIZWFkZXJzWyd4LWFwcHdyaXRlLWlkJ10gPSBpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF5bG9hZFsnY29kZSddID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICAgICAgICBmaWxlOiBjdXJyZW50Q2h1bmssXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGNvZGUuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgc2l6ZTogY3VycmVudENodW5rU2l6ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBzZWxmQ2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgIGlkID0gcmVzcG9uc2VbJyRpZCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICAkaWQ6IHJlc3BvbnNlWyckaWQnXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IE1hdGgubWluKChzdGFydCtjbGllbnQuQ0hVTktfU0laRSkgKiBjbGllbnQuQ0hVTktfU0laRSwgc2l6ZSkgLyBzaXplICogMTAwLFxuICAgICAgICAgICAgICAgICAgICBzaXplVXBsb2FkZWQ6IGVuZCsxLFxuICAgICAgICAgICAgICAgICAgICBjaHVua3NUb3RhbDogcmVzcG9uc2VbJ2NodW5rc1RvdGFsJ10sXG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1VwbG9hZGVkOiByZXNwb25zZVsnY2h1bmtzVXBsb2FkZWQnXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50Q2h1bmtTdGFydCArPSBjbGllbnQuQ0hVTktfU0laRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZVN0cmVhbSA9IG5ldyBTdHJlYW0uV3JpdGFibGUoKTtcbiAgICAgICAgICAgIHdyaXRlU3RyZWFtLl93cml0ZSA9IGFzeW5jIChtYWluQ2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZ21lbnQgaW5jb21pbmcgY2h1bmsgaW50byB1cCB0byA1TUIgY2h1bmtzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1haW5DaHVua1NpemUgPSBCdWZmZXIuYnl0ZUxlbmd0aChtYWluQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua3NDb3VudCA9IE1hdGguY2VpbChtYWluQ2h1bmtTaXplIC8gY2xpZW50LkNIVU5LX1NJWkUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgY2h1bmtzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBtYWluQ2h1bmsuc2xpY2UoaSAqIGNsaWVudC5DSFVOS19TSVpFLCAoaSArIDEpICogY2xpZW50LkNIVU5LX1NJWkUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2h1bmtTaXplICsgY3VycmVudENodW5rU2l6ZSA9PSBjbGllbnQuQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwbG9hZCBjaHVua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuayA9IEJ1ZmZlci5jb25jYXQoW2N1cnJlbnRDaHVuaywgY2h1bmtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtTaXplID0gQnVmZmVyLmJ5dGVMZW5ndGgoY3VycmVudENodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB1cGxvYWRDaHVuaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuayA9IEJ1ZmZlci5mcm9tKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihjaHVua1NpemUgKyBjdXJyZW50Q2h1bmtTaXplID4gY2xpZW50LkNIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGxvYWQgY2h1bmssIHB1dCByZXN0IGludG8gbmV4dCBjaHVua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzVG9VcGxvYWQgPSBjbGllbnQuQ0hVTktfU0laRSAtIGN1cnJlbnRDaHVua1NpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2h1bmtTZWN0aW9uID0gY2h1bmsuc2xpY2UoMCwgYnl0ZXNUb1VwbG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rID0gQnVmZmVyLmNvbmNhdChbY3VycmVudENodW5rLCBuZXdDaHVua1NlY3Rpb25dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtTaXplID0gQnVmZmVyLmJ5dGVMZW5ndGgoY3VycmVudENodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB1cGxvYWRDaHVuaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuayA9IGNodW5rLnNsaWNlKGJ5dGVzVG9VcGxvYWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rU2l6ZSA9IGNodW5rU2l6ZSAtIGJ5dGVzVG9VcGxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBpbnRvIGN1cnJlbnQgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsgPSBCdWZmZXIuY29uY2F0KFtjdXJyZW50Q2h1bmssIGNodW5rXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rU2l6ZSA9IGNodW5rU2l6ZSArIGN1cnJlbnRDaHVua1NpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cml0ZVN0cmVhbS5vbihcImZpbmlzaFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoY3VycmVudENodW5rU2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZENodW5rKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgd3JpdGVTdHJlYW0ub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29kZS5zdHJlYW0ucGlwZSh3cml0ZVN0cmVhbSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRlcGxveW1lbnRcbiAgICAgKlxuICAgICAqIEdldCBhIGNvZGUgZGVwbG95bWVudCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVwbG95bWVudElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95bWVudChmdW5jdGlvbklkLCBkZXBsb3ltZW50SWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudElkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne2RlcGxveW1lbnRJZH0nLCBkZXBsb3ltZW50SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXBsb3ltZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRlcGxveW1lbnRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZnVuY3Rpb24gZGVwbG95bWVudFxuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSBmdW5jdGlvbiBjb2RlIGRlcGxveW1lbnQgSUQgdXNpbmcgdGhlIHVuaXF1ZSBmdW5jdGlvbiBJRC4gVXNlXG4gICAgICogdGhpcyBlbmRwb2ludCB0byBzd2l0Y2ggdGhlIGNvZGUgZGVwbG95bWVudCB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCBieSB0aGVcbiAgICAgKiBleGVjdXRpb24gZW5kcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXBsb3ltZW50SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVEZXBsb3ltZW50KGZ1bmN0aW9uSWQsIGRlcGxveW1lbnRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50SWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7ZGVwbG95bWVudElkfScsIGRlcGxveW1lbnRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlcGxveW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGVwbG95bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGRlcGxveW1lbnRcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIGNvZGUgZGVwbG95bWVudCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVwbG95bWVudElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlRGVwbG95bWVudChmdW5jdGlvbklkLCBkZXBsb3ltZW50SWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudElkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne2RlcGxveW1lbnRJZH0nLCBkZXBsb3ltZW50SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXBsb3ltZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRlcGxveW1lbnRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYnVpbGRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBidWlsZCBmb3IgYW4gQXBwd3JpdGUgRnVuY3Rpb24gZGVwbG95bWVudC4gVGhpcyBlbmRwb2ludCBjYW5cbiAgICAgKiBiZSB1c2VkIHRvIHJldHJ5IGEgZmFpbGVkIGJ1aWxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVwbG95bWVudElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1aWxkSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCdWlsZChmdW5jdGlvbklkLCBkZXBsb3ltZW50SWQsIGJ1aWxkSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudElkfS9idWlsZHMve2J1aWxkSWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7ZGVwbG95bWVudElkfScsIGRlcGxveW1lbnRJZCkucmVwbGFjZSgne2J1aWxkSWR9JywgYnVpbGRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlcGxveW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGVwbG95bWVudElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYnVpbGRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVpbGRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgRGVwbG95bWVudFxuICAgICAqXG4gICAgICogR2V0IGEgRGVwbG95bWVudCdzIGNvbnRlbnRzIGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgc3VwcG9ydHMgcmFuZ2VcbiAgICAgKiByZXF1ZXN0cyBmb3IgcGFydGlhbCBvciBzdHJlYW1pbmcgZmlsZSBkb3dubG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlcGxveW1lbnRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRvd25sb2FkRGVwbG95bWVudChmdW5jdGlvbklkLCBkZXBsb3ltZW50SWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudElkfS9kb3dubG9hZCcucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne2RlcGxveW1lbnRJZH0nLCBkZXBsb3ltZW50SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXBsb3ltZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRlcGxveW1lbnRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGV4ZWN1dGlvbnNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBjdXJyZW50IHVzZXIgZnVuY3Rpb24gZXhlY3V0aW9uIGxvZ3MuIFlvdSBjYW4gdXNlIHRoZVxuICAgICAqIHF1ZXJ5IHBhcmFtcyB0byBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RFeGVjdXRpb25zKGZ1bmN0aW9uSWQsIHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2V4ZWN1dGlvbnMnLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZXhlY3V0aW9uXG4gICAgICpcbiAgICAgKiBUcmlnZ2VyIGEgZnVuY3Rpb24gZXhlY3V0aW9uLiBUaGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgcmV0dXJuIHlvdSB0aGVcbiAgICAgKiBjdXJyZW50IGV4ZWN1dGlvbiBzdGF0dXMuIFlvdSBjYW4gcGluZyB0aGUgYEdldCBFeGVjdXRpb25gIGVuZHBvaW50IHRvIGdldFxuICAgICAqIHVwZGF0ZXMgb24gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIHN0YXR1cy4gT25jZSB0aGlzIGVuZHBvaW50IGlzIGNhbGxlZCwgeW91clxuICAgICAqIGZ1bmN0aW9uIGV4ZWN1dGlvbiBwcm9jZXNzIHdpbGwgc3RhcnQgYXN5bmNocm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhc3luY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4cGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaGVhZGVyc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUV4ZWN1dGlvbihmdW5jdGlvbklkLCBib2R5LCBhc3luYywgeHBhdGgsIG1ldGhvZCwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2V4ZWN1dGlvbnMnLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGJvZHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydib2R5J10gPSBib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FzeW5jJ10gPSBhc3luYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXRoJ10gPSB4cGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWV0aG9kJ10gPSBtZXRob2Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGhlYWRlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWFkZXJzJ10gPSBoZWFkZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXhlY3V0aW9uXG4gICAgICpcbiAgICAgKiBHZXQgYSBmdW5jdGlvbiBleGVjdXRpb24gbG9nIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleGVjdXRpb25JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEV4ZWN1dGlvbihmdW5jdGlvbklkLCBleGVjdXRpb25JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2V4ZWN1dGlvbnMve2V4ZWN1dGlvbklkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne2V4ZWN1dGlvbklkfScsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZXhlY3V0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImV4ZWN1dGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgdmFyaWFibGVzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB2YXJpYWJsZXMgb2YgYSBzcGVjaWZpYyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdFZhcmlhYmxlcyhmdW5jdGlvbklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vdmFyaWFibGVzJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB2YXJpYWJsZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IGZ1bmN0aW9uIGVudmlyb25tZW50IHZhcmlhYmxlLiBUaGVzZSB2YXJpYWJsZXMgY2FuIGJlIGFjY2Vzc2VkXG4gICAgICogaW4gdGhlIGZ1bmN0aW9uIGF0IHJ1bnRpbWUgYXMgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVmFyaWFibGUoZnVuY3Rpb25JZCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L3ZhcmlhYmxlcycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInZhbHVlXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd2YWx1ZSddID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB2YXJpYWJsZVxuICAgICAqXG4gICAgICogR2V0IGEgdmFyaWFibGUgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhcmlhYmxlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRWYXJpYWJsZShmdW5jdGlvbklkLCB2YXJpYWJsZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vdmFyaWFibGVzL3t2YXJpYWJsZUlkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne3ZhcmlhYmxlSWR9JywgdmFyaWFibGVJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhcmlhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInZhcmlhYmxlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHZhcmlhYmxlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdmFyaWFibGUgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhcmlhYmxlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVmFyaWFibGUoZnVuY3Rpb25JZCwgdmFyaWFibGVJZCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L3ZhcmlhYmxlcy97dmFyaWFibGVJZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3t2YXJpYWJsZUlkfScsIHZhcmlhYmxlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YXJpYWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ2YXJpYWJsZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3ZhbHVlJ10gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdmFyaWFibGVcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHZhcmlhYmxlIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJpYWJsZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlVmFyaWFibGUoZnVuY3Rpb25JZCwgdmFyaWFibGVJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L3ZhcmlhYmxlcy97dmFyaWFibGVJZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3t2YXJpYWJsZUlkfScsIHZhcmlhYmxlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YXJpYWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ2YXJpYWJsZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbnM7XG4iXSwibmFtZXMiOlsiU2VydmljZSIsInJlcXVpcmUiLCJBcHB3cml0ZUV4Y2VwdGlvbiIsIklucHV0RmlsZSIsImNsaWVudCIsIlN0cmVhbSIsInByb21pc2lmeSIsImZzIiwiRnVuY3Rpb25zIiwiY29uc3RydWN0b3IiLCJsaXN0IiwicXVlcmllcyIsInNlYXJjaCIsImFwaVBhdGgiLCJwYXlsb2FkIiwiY2FsbCIsImNyZWF0ZSIsImZ1bmN0aW9uSWQiLCJuYW1lIiwicnVudGltZSIsImV4ZWN1dGUiLCJldmVudHMiLCJzY2hlZHVsZSIsInRpbWVvdXQiLCJlbmFibGVkIiwibG9nZ2luZyIsImVudHJ5cG9pbnQiLCJjb21tYW5kcyIsImluc3RhbGxhdGlvbklkIiwicHJvdmlkZXJSZXBvc2l0b3J5SWQiLCJwcm92aWRlckJyYW5jaCIsInByb3ZpZGVyU2lsZW50TW9kZSIsInByb3ZpZGVyUm9vdERpcmVjdG9yeSIsInRlbXBsYXRlUmVwb3NpdG9yeSIsInRlbXBsYXRlT3duZXIiLCJ0ZW1wbGF0ZVJvb3REaXJlY3RvcnkiLCJ0ZW1wbGF0ZUJyYW5jaCIsImxpc3RSdW50aW1lcyIsImdldCIsInJlcGxhY2UiLCJ1cGRhdGUiLCJkZWxldGUiLCJsaXN0RGVwbG95bWVudHMiLCJjcmVhdGVEZXBsb3ltZW50IiwiY29kZSIsImFjdGl2YXRlIiwib25Qcm9ncmVzcyIsInRvU3RyaW5nIiwic2l6ZSIsImFwaUhlYWRlcnMiLCJpZCIsInVuZGVmaW5lZCIsInJlc3BvbnNlIiwiY2h1bmtzVXBsb2FkZWQiLCJjdXJyZW50Q2h1bmsiLCJCdWZmZXIiLCJmcm9tIiwiY3VycmVudENodW5rU2l6ZSIsImN1cnJlbnRDaHVua1N0YXJ0Iiwic2VsZkNsaWVudCIsInVwbG9hZENodW5rIiwibGFzdFVwbG9hZCIsIkNIVU5LX1NJWkUiLCJzdGFydCIsImVuZCIsInR5cGUiLCJmaWxlIiwiZmlsZW5hbWUiLCIkaWQiLCJwcm9ncmVzcyIsIk1hdGgiLCJtaW4iLCJzaXplVXBsb2FkZWQiLCJjaHVua3NUb3RhbCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwid3JpdGVTdHJlYW0iLCJXcml0YWJsZSIsIl93cml0ZSIsIm1haW5DaHVuayIsImVuY29kaW5nIiwiY2FsbGJhY2siLCJtYWluQ2h1bmtTaXplIiwiYnl0ZUxlbmd0aCIsImNodW5rc0NvdW50IiwiY2VpbCIsImNodW5rcyIsImkiLCJjaHVuayIsInNsaWNlIiwicHVzaCIsImNodW5rU2l6ZSIsImNvbmNhdCIsImJ5dGVzVG9VcGxvYWQiLCJuZXdDaHVua1NlY3Rpb24iLCJlIiwib24iLCJlcnIiLCJzdHJlYW0iLCJwaXBlIiwiZ2V0RGVwbG95bWVudCIsImRlcGxveW1lbnRJZCIsInVwZGF0ZURlcGxveW1lbnQiLCJkZWxldGVEZXBsb3ltZW50IiwiY3JlYXRlQnVpbGQiLCJidWlsZElkIiwiZG93bmxvYWREZXBsb3ltZW50IiwibGlzdEV4ZWN1dGlvbnMiLCJjcmVhdGVFeGVjdXRpb24iLCJib2R5IiwiYXN5bmMiLCJ4cGF0aCIsIm1ldGhvZCIsImhlYWRlcnMiLCJnZXRFeGVjdXRpb24iLCJleGVjdXRpb25JZCIsImxpc3RWYXJpYWJsZXMiLCJjcmVhdGVWYXJpYWJsZSIsImtleSIsInZhbHVlIiwiZ2V0VmFyaWFibGUiLCJ2YXJpYWJsZUlkIiwidXBkYXRlVmFyaWFibGUiLCJkZWxldGVWYXJpYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/functions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/graphql.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/graphql.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Graphql extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * GraphQL endpoint\n     *\n     * Execute a GraphQL mutation.\n     *\n     * @param {object} query\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async query(query) {\n        const apiPath = \"/graphql\";\n        let payload = {};\n        if (typeof query === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n        if (typeof query !== \"undefined\") {\n            payload[\"query\"] = query;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"x-sdk-graphql\": \"true\",\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * GraphQL endpoint\n     *\n     * Execute a GraphQL mutation.\n     *\n     * @param {object} query\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async mutation(query) {\n        const apiPath = \"/graphql/mutation\";\n        let payload = {};\n        if (typeof query === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n        if (typeof query !== \"undefined\") {\n            payload[\"query\"] = query;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"x-sdk-graphql\": \"true\",\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n}\nmodule.exports = Graphql;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvZ3JhcGhxbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUN4QixNQUFNQyxvQkFBb0JELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1JLFNBQVNKLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUssU0FBUyxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1NLEtBQUtOLG1CQUFPQSxDQUFDO0FBRW5CLE1BQU1PLGdCQUFnQlI7SUFFakJTLFlBQVlMLE1BQU0sQ0FDbEI7UUFDRyxLQUFLLENBQUNBO0lBQ1Q7SUFHRDs7Ozs7Ozs7S0FRQyxHQUNELE1BQU1NLE1BQU1BLEtBQUssRUFBRTtRQUNmLE1BQU1DLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRixVQUFVLGFBQWE7WUFDOUIsTUFBTSxJQUFJUixrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU9RLFVBQVUsYUFBYTtZQUM5QkUsT0FBTyxDQUFDLFFBQVEsR0FBR0Y7UUFDdkI7UUFFQSxPQUFPLE1BQU0sSUFBSSxDQUFDTixNQUFNLENBQUNTLElBQUksQ0FBQyxRQUFRRixTQUFTO1lBQzNDLGlCQUFpQjtZQUNqQixnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTUUsU0FBU0osS0FBSyxFQUFFO1FBQ2xCLE1BQU1DLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRixVQUFVLGFBQWE7WUFDOUIsTUFBTSxJQUFJUixrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU9RLFVBQVUsYUFBYTtZQUM5QkUsT0FBTyxDQUFDLFFBQVEsR0FBR0Y7UUFDdkI7UUFFQSxPQUFPLE1BQU0sSUFBSSxDQUFDTixNQUFNLENBQUNTLElBQUksQ0FBQyxRQUFRRixTQUFTO1lBQzNDLGlCQUFpQjtZQUNqQixnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtBQUNKO0FBRUFHLE9BQU9DLE9BQU8sR0FBR1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9ncmFwaHFsLmpzPzIzNjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5jbGFzcyBHcmFwaHFsIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR3JhcGhRTCBlbmRwb2ludFxuICAgICAqXG4gICAgICogRXhlY3V0ZSBhIEdyYXBoUUwgbXV0YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeShxdWVyeSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9ncmFwaHFsJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicXVlcnlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcnknXSA9IHF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAneC1zZGstZ3JhcGhxbCc6ICd0cnVlJyxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyYXBoUUwgZW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEV4ZWN1dGUgYSBHcmFwaFFMIG11dGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXJ5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbXV0YXRpb24ocXVlcnkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZ3JhcGhxbC9tdXRhdGlvbic7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInF1ZXJ5XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJ5J10gPSBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ3gtc2RrLWdyYXBocWwnOiAndHJ1ZScsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhxbDtcbiJdLCJuYW1lcyI6WyJTZXJ2aWNlIiwicmVxdWlyZSIsIkFwcHdyaXRlRXhjZXB0aW9uIiwiSW5wdXRGaWxlIiwiY2xpZW50IiwiU3RyZWFtIiwicHJvbWlzaWZ5IiwiZnMiLCJHcmFwaHFsIiwiY29uc3RydWN0b3IiLCJxdWVyeSIsImFwaVBhdGgiLCJwYXlsb2FkIiwiY2FsbCIsIm11dGF0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/graphql.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/health.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/health.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Health extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * Get HTTP\n     *\n     * Check the Appwrite HTTP server is up and responsive.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async get() {\n        const apiPath = \"/health\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get antivirus\n     *\n     * Check the Appwrite Antivirus server is up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getAntivirus() {\n        const apiPath = \"/health/anti-virus\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get cache\n     *\n     * Check the Appwrite in-memory cache servers are up and connection is\n     * successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getCache() {\n        const apiPath = \"/health/cache\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get DB\n     *\n     * Check the Appwrite database servers are up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getDB() {\n        const apiPath = \"/health/db\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get pubsub\n     *\n     * Check the Appwrite pub-sub servers are up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getPubSub() {\n        const apiPath = \"/health/pubsub\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get queue\n     *\n     * Check the Appwrite queue messaging servers are up and connection is\n     * successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueue() {\n        const apiPath = \"/health/queue\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get builds queue\n     *\n     * Get the number of builds that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueBuilds(threshold) {\n        const apiPath = \"/health/queue/builds\";\n        let payload = {};\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get certificates queue\n     *\n     * Get the number of certificates that are waiting to be issued against\n     * [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue\n     * server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueCertificates(threshold) {\n        const apiPath = \"/health/queue/certificates\";\n        let payload = {};\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get databases queue\n     *\n     * Get the number of database changes that are waiting to be processed in the\n     * Appwrite internal queue server.\n     *\n     * @param {string} name\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueDatabases(name, threshold) {\n        const apiPath = \"/health/queue/databases\";\n        let payload = {};\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get deletes queue\n     *\n     * Get the number of background destructive changes that are waiting to be\n     * processed in the Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueDeletes(threshold) {\n        const apiPath = \"/health/queue/deletes\";\n        let payload = {};\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get functions queue\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueFunctions(threshold) {\n        const apiPath = \"/health/queue/functions\";\n        let payload = {};\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get logs queue\n     *\n     * Get the number of logs that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueLogs(threshold) {\n        const apiPath = \"/health/queue/logs\";\n        let payload = {};\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get mails queue\n     *\n     * Get the number of mails that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueMails(threshold) {\n        const apiPath = \"/health/queue/mails\";\n        let payload = {};\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get messaging queue\n     *\n     * Get the number of messages that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueMessaging(threshold) {\n        const apiPath = \"/health/queue/messaging\";\n        let payload = {};\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get migrations queue\n     *\n     * Get the number of migrations that are waiting to be processed in the\n     * Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueMigrations(threshold) {\n        const apiPath = \"/health/queue/migrations\";\n        let payload = {};\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get webhooks queue\n     *\n     * Get the number of webhooks that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getQueueWebhooks(threshold) {\n        const apiPath = \"/health/queue/webhooks\";\n        let payload = {};\n        if (typeof threshold !== \"undefined\") {\n            payload[\"threshold\"] = threshold;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get local storage\n     *\n     * Check the Appwrite local storage device is up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getStorageLocal() {\n        const apiPath = \"/health/storage/local\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get time\n     *\n     * Check the Appwrite server time is synced with Google remote NTP server. We\n     * use this technology to smoothly handle leap seconds with no disruptive\n     * events. The [Network Time\n     * Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is\n     * used by hundreds of millions of computers and devices to synchronize their\n     * clocks over the Internet. If your computer sets its own clock, it likely\n     * uses NTP.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getTime() {\n        const apiPath = \"/health/time\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n}\nmodule.exports = Health;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvaGVhbHRoLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUM7QUFDbEMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUM7QUFDMUIsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUksU0FBU0osbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFSyxTQUFTLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDOUIsTUFBTU0sS0FBS04sbUJBQU9BLENBQUM7QUFFbkIsTUFBTU8sZUFBZVI7SUFFaEJTLFlBQVlMLE1BQU0sQ0FDbEI7UUFDRyxLQUFLLENBQUNBO0lBQ1Q7SUFHRDs7Ozs7OztLQU9DLEdBQ0QsTUFBTU0sTUFBTTtRQUNSLE1BQU1DLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBRWYsT0FBTyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7O0tBT0MsR0FDRCxNQUFNRSxlQUFlO1FBQ2pCLE1BQU1ILFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBRWYsT0FBTyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTUcsV0FBVztRQUNiLE1BQU1KLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBRWYsT0FBTyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7O0tBT0MsR0FDRCxNQUFNSSxRQUFRO1FBQ1YsTUFBTUws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UUFFZixJQUFJLE9BQU9RLGNBQWMsYUFBYTtZQUNsQ1IsT0FBTyxDQUFDLFlBQVksR0FBR1E7UUFDM0I7UUFFQSxPQUFPLE1BQU0sSUFBSSxDQUFDaEIsTUFBTSxDQUFDUyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7O0tBT0MsR0FDRCxNQUFNbUIsa0JBQWtCO1FBQ3BCLE1BQU1wQixVQUFVO1FBQ2hCLElBQUlDLFVBQVUsQ0FBQztRQUVmLE9BQU8sTUFBTSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1MsSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7Ozs7OztLQWFDLEdBQ0QsTUFBTW9CLFVBQVU7UUFDWixNQUFNckIsVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFFZixPQUFPLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNTLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0FBQ0o7QUFFQXFCLE9BQU9DLE9BQU8sR0FBRzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja25lc3QvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvaGVhbHRoLmpzP2I4YjIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5jbGFzcyBIZWFsdGggZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgSFRUUFxuICAgICAqXG4gICAgICogQ2hlY2sgdGhlIEFwcHdyaXRlIEhUVFAgc2VydmVyIGlzIHVwIGFuZCByZXNwb25zaXZlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW50aXZpcnVzXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgQW50aXZpcnVzIHNlcnZlciBpcyB1cCBhbmQgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0QW50aXZpcnVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvYW50aS12aXJ1cyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZVxuICAgICAqXG4gICAgICogQ2hlY2sgdGhlIEFwcHdyaXRlIGluLW1lbW9yeSBjYWNoZSBzZXJ2ZXJzIGFyZSB1cCBhbmQgY29ubmVjdGlvbiBpc1xuICAgICAqIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDYWNoZSgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL2NhY2hlJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IERCXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgZGF0YWJhc2Ugc2VydmVycyBhcmUgdXAgYW5kIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldERCKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvZGInO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcHVic3ViXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgcHViLXN1YiBzZXJ2ZXJzIGFyZSB1cCBhbmQgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHViU3ViKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcHVic3ViJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHF1ZXVlXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgcXVldWUgbWVzc2FnaW5nIHNlcnZlcnMgYXJlIHVwIGFuZCBjb25uZWN0aW9uIGlzXG4gICAgICogc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYnVpbGRzIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBidWlsZHMgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlXG4gICAgICogaW50ZXJuYWwgcXVldWUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlQnVpbGRzKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvYnVpbGRzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjZXJ0aWZpY2F0ZXMgcXVldWVcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNlcnRpZmljYXRlcyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIGlzc3VlZCBhZ2FpbnN0XG4gICAgICogW0xldHNlbmNyeXB0XShodHRwczovL2xldHNlbmNyeXB0Lm9yZy8pIGluIHRoZSBBcHB3cml0ZSBpbnRlcm5hbCBxdWV1ZVxuICAgICAqIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZUNlcnRpZmljYXRlcyh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL2NlcnRpZmljYXRlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YWJhc2VzIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBkYXRhYmFzZSBjaGFuZ2VzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZVxuICAgICAqIEFwcHdyaXRlIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlRGF0YWJhc2VzKG5hbWUsIHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvZGF0YWJhc2VzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGVsZXRlcyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgYmFja2dyb3VuZCBkZXN0cnVjdGl2ZSBjaGFuZ2VzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmVcbiAgICAgKiBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZURlbGV0ZXModGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9xdWV1ZS9kZWxldGVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmdW5jdGlvbnMgcXVldWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZUZ1bmN0aW9ucyh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL2Z1bmN0aW9ucyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbG9ncyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgbG9ncyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCBpbiB0aGUgQXBwd3JpdGVcbiAgICAgKiBpbnRlcm5hbCBxdWV1ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UXVldWVMb2dzKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvbG9ncyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWFpbHMgcXVldWVcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIG1haWxzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZSBBcHB3cml0ZVxuICAgICAqIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZU1haWxzKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvbWFpbHMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGhyZXNob2xkJ10gPSB0aHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IG1lc3NhZ2luZyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgbWVzc2FnZXMgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlXG4gICAgICogaW50ZXJuYWwgcXVldWUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlTWVzc2FnaW5nKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvbWVzc2FnaW5nJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBtaWdyYXRpb25zIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBtaWdyYXRpb25zIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZVxuICAgICAqIEFwcHdyaXRlIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZU1pZ3JhdGlvbnModGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9xdWV1ZS9taWdyYXRpb25zJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB3ZWJob29rcyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2Ygd2ViaG9va3MgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlXG4gICAgICogaW50ZXJuYWwgcXVldWUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlV2ViaG9va3ModGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9xdWV1ZS93ZWJob29rcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbG9jYWwgc3RvcmFnZVxuICAgICAqXG4gICAgICogQ2hlY2sgdGhlIEFwcHdyaXRlIGxvY2FsIHN0b3JhZ2UgZGV2aWNlIGlzIHVwIGFuZCBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdG9yYWdlTG9jYWwoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9zdG9yYWdlL2xvY2FsJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRpbWVcbiAgICAgKlxuICAgICAqIENoZWNrIHRoZSBBcHB3cml0ZSBzZXJ2ZXIgdGltZSBpcyBzeW5jZWQgd2l0aCBHb29nbGUgcmVtb3RlIE5UUCBzZXJ2ZXIuIFdlXG4gICAgICogdXNlIHRoaXMgdGVjaG5vbG9neSB0byBzbW9vdGhseSBoYW5kbGUgbGVhcCBzZWNvbmRzIHdpdGggbm8gZGlzcnVwdGl2ZVxuICAgICAqIGV2ZW50cy4gVGhlIFtOZXR3b3JrIFRpbWVcbiAgICAgKiBQcm90b2NvbF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmV0d29ya19UaW1lX1Byb3RvY29sKSAoTlRQKSBpc1xuICAgICAqIHVzZWQgYnkgaHVuZHJlZHMgb2YgbWlsbGlvbnMgb2YgY29tcHV0ZXJzIGFuZCBkZXZpY2VzIHRvIHN5bmNocm9uaXplIHRoZWlyXG4gICAgICogY2xvY2tzIG92ZXIgdGhlIEludGVybmV0LiBJZiB5b3VyIGNvbXB1dGVyIHNldHMgaXRzIG93biBjbG9jaywgaXQgbGlrZWx5XG4gICAgICogdXNlcyBOVFAuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUaW1lKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvdGltZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIZWFsdGg7XG4iXSwibmFtZXMiOlsiU2VydmljZSIsInJlcXVpcmUiLCJBcHB3cml0ZUV4Y2VwdGlvbiIsIklucHV0RmlsZSIsImNsaWVudCIsIlN0cmVhbSIsInByb21pc2lmeSIsImZzIiwiSGVhbHRoIiwiY29uc3RydWN0b3IiLCJnZXQiLCJhcGlQYXRoIiwicGF5bG9hZCIsImNhbGwiLCJnZXRBbnRpdmlydXMiLCJnZXRDYWNoZSIsImdldERCIiwiZ2V0UHViU3ViIiwiZ2V0UXVldWUiLCJnZXRRdWV1ZUJ1aWxkcyIsInRocmVzaG9sZCIsImdldFF1ZXVlQ2VydGlmaWNhdGVzIiwiZ2V0UXVldWVEYXRhYmFzZXMiLCJuYW1lIiwiZ2V0UXVldWVEZWxldGVzIiwiZ2V0UXVldWVGdW5jdGlvbnMiLCJnZXRRdWV1ZUxvZ3MiLCJnZXRRdWV1ZU1haWxzIiwiZ2V0UXVldWVNZXNzYWdpbmciLCJnZXRRdWV1ZU1pZ3JhdGlvbnMiLCJnZXRRdWV1ZVdlYmhvb2tzIiwiZ2V0U3RvcmFnZUxvY2FsIiwiZ2V0VGltZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/health.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/locale.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/locale.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Locale extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * Get user locale\n     *\n     * Get the current user location based on IP. Returns an object with user\n     * country code, country name, continent name, continent code, ip address and\n     * suggested currency. You can use the locale header to get the data in a\n     * supported language.\n     * \n     * ([IP Geolocation by DB-IP](https://db-ip.com))\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async get() {\n        const apiPath = \"/locale\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List Locale Codes\n     *\n     * List of all locale codes in [ISO\n     * 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listCodes() {\n        const apiPath = \"/locale/codes\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List continents\n     *\n     * List of all continents. You can use the locale header to get the data in a\n     * supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listContinents() {\n        const apiPath = \"/locale/continents\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List countries\n     *\n     * List of all countries. You can use the locale header to get the data in a\n     * supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listCountries() {\n        const apiPath = \"/locale/countries\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List EU countries\n     *\n     * List of all countries that are currently members of the EU. You can use the\n     * locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listCountriesEU() {\n        const apiPath = \"/locale/countries/eu\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List countries phone codes\n     *\n     * List of all countries phone codes. You can use the locale header to get the\n     * data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listCountriesPhones() {\n        const apiPath = \"/locale/countries/phones\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List currencies\n     *\n     * List of all currencies, including currency symbol, name, plural, and\n     * decimal digits for all major and minor currencies. You can use the locale\n     * header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listCurrencies() {\n        const apiPath = \"/locale/currencies\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List languages\n     *\n     * List of all languages classified by ISO 639-1 including 2-letter code, name\n     * in English, and name in the respective language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listLanguages() {\n        const apiPath = \"/locale/languages\";\n        let payload = {};\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n}\nmodule.exports = Locale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvbG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUM7QUFDbEMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUM7QUFDMUIsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUksU0FBU0osbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFSyxTQUFTLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDOUIsTUFBTU0sS0FBS04sbUJBQU9BLENBQUM7QUFFbkIsTUFBTU8sZUFBZVI7SUFFaEJTLFlBQVlMLE1BQU0sQ0FDbEI7UUFDRyxLQUFLLENBQUNBO0lBQ1Q7SUFHRDs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRCxNQUFNTSxNQUFNO1FBQ1IsTUFBTUMsVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFFZixPQUFPLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNTLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNRSxZQUFZO1FBQ2QsTUFBTUgsVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFFZixPQUFPLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNTLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNRyxpQkFBaUI7UUFDbkIsTUFBTUosVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFFZixPQUFPLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNTLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNSSxnQkFBZ0I7UUFDbEIsTUFBTUwsVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFFZixPQUFPLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNTLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNSyxrQkFBa0I7UUFDcEIsTUFBTU4sVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFFZixPQUFPLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNTLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNTSxzQkFBc0I7UUFDeEIsTUFBTVAsVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFFZixPQUFPLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNTLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7OztLQVNDLEdBQ0QsTUFBTU8saUJBQWlCO1FBQ25CLE1BQU1SLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBRWYsT0FBTyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTVEsZ0JBQWdCO1FBQ2xCLE1BQU1ULFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBRWYsT0FBTyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtBQUNKO0FBRUFTLE9BQU9DLE9BQU8sR0FBR2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9sb2NhbGUuanM/MDI1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmNsYXNzIExvY2FsZSBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGxvY2FsZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHVzZXIgbG9jYXRpb24gYmFzZWQgb24gSVAuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdXNlclxuICAgICAqIGNvdW50cnkgY29kZSwgY291bnRyeSBuYW1lLCBjb250aW5lbnQgbmFtZSwgY29udGluZW50IGNvZGUsIGlwIGFkZHJlc3MgYW5kXG4gICAgICogc3VnZ2VzdGVkIGN1cnJlbmN5LiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYVxuICAgICAqIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKiBcbiAgICAgKiAoW0lQIEdlb2xvY2F0aW9uIGJ5IERCLUlQXShodHRwczovL2RiLWlwLmNvbSkpXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgTG9jYWxlIENvZGVzXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIGFsbCBsb2NhbGUgY29kZXMgaW4gW0lTT1xuICAgICAqIDYzOS0xXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX0lTT182MzktMV9jb2RlcykuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb2Rlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgY29udGluZW50c1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgY29udGluZW50cy4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGFcbiAgICAgKiBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q29udGluZW50cygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2NvbnRpbmVudHMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGNvdW50cmllc1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgY291bnRyaWVzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYVxuICAgICAqIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RDb3VudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IEVVIGNvdW50cmllc1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgY291bnRyaWVzIHRoYXQgYXJlIGN1cnJlbnRseSBtZW1iZXJzIG9mIHRoZSBFVS4gWW91IGNhbiB1c2UgdGhlXG4gICAgICogbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYSBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q291bnRyaWVzRVUoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMvZXUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGNvdW50cmllcyBwaG9uZSBjb2Rlc1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgY291bnRyaWVzIHBob25lIGNvZGVzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlXG4gICAgICogZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RDb3VudHJpZXNQaG9uZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMvcGhvbmVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBjdXJyZW5jaWVzXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIGFsbCBjdXJyZW5jaWVzLCBpbmNsdWRpbmcgY3VycmVuY3kgc3ltYm9sLCBuYW1lLCBwbHVyYWwsIGFuZFxuICAgICAqIGRlY2ltYWwgZGlnaXRzIGZvciBhbGwgbWFqb3IgYW5kIG1pbm9yIGN1cnJlbmNpZXMuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGVcbiAgICAgKiBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGEgc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEN1cnJlbmNpZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jdXJyZW5jaWVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBsYW5ndWFnZXNcbiAgICAgKlxuICAgICAqIExpc3Qgb2YgYWxsIGxhbmd1YWdlcyBjbGFzc2lmaWVkIGJ5IElTTyA2MzktMSBpbmNsdWRpbmcgMi1sZXR0ZXIgY29kZSwgbmFtZVxuICAgICAqIGluIEVuZ2xpc2gsIGFuZCBuYW1lIGluIHRoZSByZXNwZWN0aXZlIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdExhbmd1YWdlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2xhbmd1YWdlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbGU7XG4iXSwibmFtZXMiOlsiU2VydmljZSIsInJlcXVpcmUiLCJBcHB3cml0ZUV4Y2VwdGlvbiIsIklucHV0RmlsZSIsImNsaWVudCIsIlN0cmVhbSIsInByb21pc2lmeSIsImZzIiwiTG9jYWxlIiwiY29uc3RydWN0b3IiLCJnZXQiLCJhcGlQYXRoIiwicGF5bG9hZCIsImNhbGwiLCJsaXN0Q29kZXMiLCJsaXN0Q29udGluZW50cyIsImxpc3RDb3VudHJpZXMiLCJsaXN0Q291bnRyaWVzRVUiLCJsaXN0Q291bnRyaWVzUGhvbmVzIiwibGlzdEN1cnJlbmNpZXMiLCJsaXN0TGFuZ3VhZ2VzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/locale.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/storage.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/storage.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Storage extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * List buckets\n     *\n     * Get a list of all the storage buckets. You can use the query params to\n     * filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listBuckets(queries, search) {\n        const apiPath = \"/storage/buckets\";\n        let payload = {};\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create bucket\n     *\n     * Create a new storage bucket.\n     *\n     * @param {string} bucketId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} fileSecurity\n     * @param {boolean} enabled\n     * @param {number} maximumFileSize\n     * @param {string[]} allowedFileExtensions\n     * @param {string} compression\n     * @param {boolean} encryption\n     * @param {boolean} antivirus\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createBucket(bucketId, name, permissions, fileSecurity, enabled, maximumFileSize, allowedFileExtensions, compression, encryption, antivirus) {\n        const apiPath = \"/storage/buckets\";\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof bucketId !== \"undefined\") {\n            payload[\"bucketId\"] = bucketId;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof permissions !== \"undefined\") {\n            payload[\"permissions\"] = permissions;\n        }\n        if (typeof fileSecurity !== \"undefined\") {\n            payload[\"fileSecurity\"] = fileSecurity;\n        }\n        if (typeof enabled !== \"undefined\") {\n            payload[\"enabled\"] = enabled;\n        }\n        if (typeof maximumFileSize !== \"undefined\") {\n            payload[\"maximumFileSize\"] = maximumFileSize;\n        }\n        if (typeof allowedFileExtensions !== \"undefined\") {\n            payload[\"allowedFileExtensions\"] = allowedFileExtensions;\n        }\n        if (typeof compression !== \"undefined\") {\n            payload[\"compression\"] = compression;\n        }\n        if (typeof encryption !== \"undefined\") {\n            payload[\"encryption\"] = encryption;\n        }\n        if (typeof antivirus !== \"undefined\") {\n            payload[\"antivirus\"] = antivirus;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get bucket\n     *\n     * Get a storage bucket by its unique ID. This endpoint response returns a\n     * JSON object with the storage bucket metadata.\n     *\n     * @param {string} bucketId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getBucket(bucketId) {\n        const apiPath = \"/storage/buckets/{bucketId}\".replace(\"{bucketId}\", bucketId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update bucket\n     *\n     * Update a storage bucket by its unique ID.\n     *\n     * @param {string} bucketId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} fileSecurity\n     * @param {boolean} enabled\n     * @param {number} maximumFileSize\n     * @param {string[]} allowedFileExtensions\n     * @param {string} compression\n     * @param {boolean} encryption\n     * @param {boolean} antivirus\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateBucket(bucketId, name, permissions, fileSecurity, enabled, maximumFileSize, allowedFileExtensions, compression, encryption, antivirus) {\n        const apiPath = \"/storage/buckets/{bucketId}\".replace(\"{bucketId}\", bucketId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof permissions !== \"undefined\") {\n            payload[\"permissions\"] = permissions;\n        }\n        if (typeof fileSecurity !== \"undefined\") {\n            payload[\"fileSecurity\"] = fileSecurity;\n        }\n        if (typeof enabled !== \"undefined\") {\n            payload[\"enabled\"] = enabled;\n        }\n        if (typeof maximumFileSize !== \"undefined\") {\n            payload[\"maximumFileSize\"] = maximumFileSize;\n        }\n        if (typeof allowedFileExtensions !== \"undefined\") {\n            payload[\"allowedFileExtensions\"] = allowedFileExtensions;\n        }\n        if (typeof compression !== \"undefined\") {\n            payload[\"compression\"] = compression;\n        }\n        if (typeof encryption !== \"undefined\") {\n            payload[\"encryption\"] = encryption;\n        }\n        if (typeof antivirus !== \"undefined\") {\n            payload[\"antivirus\"] = antivirus;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete bucket\n     *\n     * Delete a storage bucket by its unique ID.\n     *\n     * @param {string} bucketId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteBucket(bucketId) {\n        const apiPath = \"/storage/buckets/{bucketId}\".replace(\"{bucketId}\", bucketId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List files\n     *\n     * Get a list of all the user files. You can use the query params to filter\n     * your results.\n     *\n     * @param {string} bucketId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listFiles(bucketId, queries, search) {\n        const apiPath = \"/storage/buckets/{bucketId}/files\".replace(\"{bucketId}\", bucketId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create file\n     *\n     * Create a new file. Before using this route, you should create a new bucket\n     * resource using either a [server\n     * integration](https://appwrite.io/docs/server/storage#storageCreateBucket)\n     * API or directly from your Appwrite console.\n     * \n     * Larger files should be uploaded using multiple requests with the\n     * [content-range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range)\n     * header to send a partial request with a maximum supported chunk of `5MB`.\n     * The `content-range` header values should always be in bytes.\n     * \n     * When the first request is sent, the server will return the **File** object,\n     * and the subsequent part request must include the file's **id** in\n     * `x-appwrite-id` header to allow the server to know that the partial upload\n     * is for the existing file and not for a new one.\n     * \n     * If you're creating a new file using one of the Appwrite SDKs, all the\n     * chunking logic will be managed by the SDK internally.\n     * \n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {InputFile} file\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createFile(bucketId, fileId, file, permissions, onProgress = ()=>{}) {\n        const apiPath = \"/storage/buckets/{bucketId}/files\".replace(\"{bucketId}\", bucketId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        if (typeof file === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"file\"');\n        }\n        if (typeof fileId !== \"undefined\") {\n            payload[\"fileId\"] = fileId;\n        }\n        if (typeof file !== \"undefined\") {\n            payload[\"file\"] = file;\n        }\n        if (typeof permissions !== \"undefined\") {\n            payload[\"permissions\"] = permissions;\n        }\n        const size = file.size;\n        const apiHeaders = {\n            \"content-type\": \"multipart/form-data\"\n        };\n        let id = undefined;\n        let response = undefined;\n        let chunksUploaded = 0;\n        if (fileId != \"unique()\") {\n            try {\n                response = await this.client.call(\"get\", apiPath + \"/\" + fileId, apiHeaders);\n                chunksUploaded = response.chunksUploaded;\n            } catch (e) {}\n        }\n        let currentChunk = Buffer.from(\"\");\n        let currentChunkSize = 0;\n        let currentChunkStart = 0;\n        const selfClient = this.client;\n        async function uploadChunk(lastUpload = false) {\n            if (chunksUploaded - 1 >= currentChunkStart / client.CHUNK_SIZE) {\n                return;\n            }\n            const start = currentChunkStart;\n            const end = currentChunkStart + currentChunkSize - 1;\n            if (!lastUpload || currentChunkStart !== 0) {\n                apiHeaders[\"content-range\"] = \"bytes \" + start + \"-\" + end + \"/\" + size;\n            }\n            if (id) {\n                apiHeaders[\"x-appwrite-id\"] = id;\n            }\n            payload[\"file\"] = {\n                type: \"file\",\n                file: currentChunk,\n                filename: file.filename,\n                size: currentChunkSize\n            };\n            response = await selfClient.call(\"post\", apiPath, apiHeaders, payload);\n            if (!id) {\n                id = response[\"$id\"];\n            }\n            if (onProgress !== null) {\n                onProgress({\n                    $id: response[\"$id\"],\n                    progress: Math.min((start + client.CHUNK_SIZE) * client.CHUNK_SIZE, size) / size * 100,\n                    sizeUploaded: end + 1,\n                    chunksTotal: response[\"chunksTotal\"],\n                    chunksUploaded: response[\"chunksUploaded\"]\n                });\n            }\n            currentChunkStart += client.CHUNK_SIZE;\n        }\n        return await new Promise((resolve, reject)=>{\n            const writeStream = new Stream.Writable();\n            writeStream._write = async (mainChunk, encoding, callback)=>{\n                try {\n                    // Segment incoming chunk into up to 5MB chunks\n                    const mainChunkSize = Buffer.byteLength(mainChunk);\n                    const chunksCount = Math.ceil(mainChunkSize / client.CHUNK_SIZE);\n                    const chunks = [];\n                    for(let i = 0; i < chunksCount; i++){\n                        const chunk = mainChunk.slice(i * client.CHUNK_SIZE, (i + 1) * client.CHUNK_SIZE);\n                        chunks.push(chunk);\n                    }\n                    for (const chunk of chunks){\n                        const chunkSize = Buffer.byteLength(chunk);\n                        if (chunkSize + currentChunkSize == client.CHUNK_SIZE) {\n                            // Upload chunk\n                            currentChunk = Buffer.concat([\n                                currentChunk,\n                                chunk\n                            ]);\n                            currentChunkSize = Buffer.byteLength(currentChunk);\n                            await uploadChunk();\n                            currentChunk = Buffer.from(\"\");\n                            currentChunkSize = 0;\n                        } else if (chunkSize + currentChunkSize > client.CHUNK_SIZE) {\n                            // Upload chunk, put rest into next chunk\n                            const bytesToUpload = client.CHUNK_SIZE - currentChunkSize;\n                            const newChunkSection = chunk.slice(0, bytesToUpload);\n                            currentChunk = Buffer.concat([\n                                currentChunk,\n                                newChunkSection\n                            ]);\n                            currentChunkSize = Buffer.byteLength(currentChunk);\n                            await uploadChunk();\n                            currentChunk = chunk.slice(bytesToUpload, undefined);\n                            currentChunkSize = chunkSize - bytesToUpload;\n                        } else {\n                            // Append into current chunk\n                            currentChunk = Buffer.concat([\n                                currentChunk,\n                                chunk\n                            ]);\n                            currentChunkSize = chunkSize + currentChunkSize;\n                        }\n                    }\n                    callback();\n                } catch (e) {\n                    callback(e);\n                }\n            };\n            writeStream.on(\"finish\", async ()=>{\n                if (currentChunkSize > 0) {\n                    try {\n                        await uploadChunk(true);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                resolve(response);\n            });\n            writeStream.on(\"error\", (err)=>{\n                reject(err);\n            });\n            file.stream.pipe(writeStream);\n        });\n    }\n    /**\n     * Get file\n     *\n     * Get a file by its unique ID. This endpoint response returns a JSON object\n     * with the file metadata.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getFile(bucketId, fileId) {\n        const apiPath = \"/storage/buckets/{bucketId}/files/{fileId}\".replace(\"{bucketId}\", bucketId).replace(\"{fileId}\", fileId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update file\n     *\n     * Update a file by its unique ID. Only users with write permissions have\n     * access to update this resource.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateFile(bucketId, fileId, name, permissions) {\n        const apiPath = \"/storage/buckets/{bucketId}/files/{fileId}\".replace(\"{bucketId}\", bucketId).replace(\"{fileId}\", fileId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof permissions !== \"undefined\") {\n            payload[\"permissions\"] = permissions;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete File\n     *\n     * Delete a file by its unique ID. Only users with write permissions have\n     * access to delete this resource.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteFile(bucketId, fileId) {\n        const apiPath = \"/storage/buckets/{bucketId}/files/{fileId}\".replace(\"{bucketId}\", bucketId).replace(\"{fileId}\", fileId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get file for download\n     *\n     * Get a file content by its unique ID. The endpoint response return with a\n     * 'Content-Disposition: attachment' header that tells the browser to start\n     * downloading the file to user downloads directory.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getFileDownload(bucketId, fileId) {\n        const apiPath = \"/storage/buckets/{bucketId}/files/{fileId}/download\".replace(\"{bucketId}\", bucketId).replace(\"{fileId}\", fileId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n    /**\n     * Get file preview\n     *\n     * Get a file preview image. Currently, this method supports preview for image\n     * files (jpg, png, and gif), other supported formats, like pdf, docs, slides,\n     * and spreadsheets, will return the file icon image. You can also pass query\n     * string arguments for cutting and resizing your preview image. Preview is\n     * supported only for image files smaller than 10MB.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {number} width\n     * @param {number} height\n     * @param {string} gravity\n     * @param {number} quality\n     * @param {number} borderWidth\n     * @param {string} borderColor\n     * @param {number} borderRadius\n     * @param {number} opacity\n     * @param {number} rotation\n     * @param {string} background\n     * @param {string} output\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getFilePreview(bucketId, fileId, width, height, gravity, quality, borderWidth, borderColor, borderRadius, opacity, rotation, background, output) {\n        const apiPath = \"/storage/buckets/{bucketId}/files/{fileId}/preview\".replace(\"{bucketId}\", bucketId).replace(\"{fileId}\", fileId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        if (typeof width !== \"undefined\") {\n            payload[\"width\"] = width;\n        }\n        if (typeof height !== \"undefined\") {\n            payload[\"height\"] = height;\n        }\n        if (typeof gravity !== \"undefined\") {\n            payload[\"gravity\"] = gravity;\n        }\n        if (typeof quality !== \"undefined\") {\n            payload[\"quality\"] = quality;\n        }\n        if (typeof borderWidth !== \"undefined\") {\n            payload[\"borderWidth\"] = borderWidth;\n        }\n        if (typeof borderColor !== \"undefined\") {\n            payload[\"borderColor\"] = borderColor;\n        }\n        if (typeof borderRadius !== \"undefined\") {\n            payload[\"borderRadius\"] = borderRadius;\n        }\n        if (typeof opacity !== \"undefined\") {\n            payload[\"opacity\"] = opacity;\n        }\n        if (typeof rotation !== \"undefined\") {\n            payload[\"rotation\"] = rotation;\n        }\n        if (typeof background !== \"undefined\") {\n            payload[\"background\"] = background;\n        }\n        if (typeof output !== \"undefined\") {\n            payload[\"output\"] = output;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n    /**\n     * Get file for view\n     *\n     * Get a file content by its unique ID. This endpoint is similar to the\n     * download method but returns with no  'Content-Disposition: attachment'\n     * header.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getFileView(bucketId, fileId) {\n        const apiPath = \"/storage/buckets/{bucketId}/files/{fileId}/view\".replace(\"{bucketId}\", bucketId).replace(\"{fileId}\", fileId);\n        let payload = {};\n        if (typeof bucketId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload, \"arraybuffer\");\n    }\n}\nmodule.exports = Storage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUN4QixNQUFNQyxvQkFBb0JELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1JLFNBQVNKLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUssU0FBUyxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1NLEtBQUtOLG1CQUFPQSxDQUFDO0FBRW5CLE1BQU1PLGdCQUFnQlI7SUFFakJTLFlBQVlMLE1BQU0sQ0FDbEI7UUFDRyxLQUFLLENBQUNBO0lBQ1Q7SUFHRDs7Ozs7Ozs7OztLQVVDLEdBQ0QsTUFBTU0sWUFBWUMsT0FBTyxFQUFFQyxNQUFNLEVBQUU7UUFDL0IsTUFBTUMsVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFFZixJQUFJLE9BQU9ILFlBQVksYUFBYTtZQUNoQ0csT0FBTyxDQUFDLFVBQVUsR0FBR0g7UUFDekI7UUFFQSxJQUFJLE9BQU9DLFdBQVcsYUFBYTtZQUMvQkUsT0FBTyxDQUFDLFNBQVMsR0FBR0Y7UUFDeEI7UUFFQSxPQUFPLE1BQU0sSUFBSSxDQUFDUixNQUFNLENBQUNXLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBaUJDLEdBQ0QsTUFBTUUsYUFBYUMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLGVBQWUsRUFBRUMscUJBQXFCLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUU7UUFDL0ksTUFBTWIsVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGFBQWEsYUFBYTtZQUNqQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT2dCLFNBQVMsYUFBYTtZQUM3QixNQUFNLElBQUloQixrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU9lLGFBQWEsYUFBYTtZQUNqQ0gsT0FBTyxDQUFDLFdBQVcsR0FBR0c7UUFDMUI7UUFFQSxJQUFJLE9BQU9DLFNBQVMsYUFBYTtZQUM3QkosT0FBTyxDQUFDLE9BQU8sR0FBR0k7UUFDdEI7UUFFQSxJQUFJLE9BQU9DLGdCQUFnQixhQUFhO1lBQ3BDTCxPQUFPLENBQUMsY0FBYyxHQUFHSztRQUM3QjtRQUVBLElBQUksT0FBT0MsaUJBQWlCLGFBQWE7WUFDckNOLE9BQU8sQ0FBQyxlQUFlLEdBQUdNO1FBQzlCO1FBRUEsSUFBSSxPQUFPQyxZQUFZLGFBQWE7WUFDaENQLE9BQU8sQ0FBQyxVQUFVLEdBQUdPO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxvQkFBb0IsYUFBYTtZQUN4Q1IsT0FBTyxDQUFDLGtCQUFrQixHQUFHUTtRQUNqQztRQUVBLElBQUksT0FBT0MsMEJBQTBCLGFBQWE7WUFDOUNULE9BQU8sQ0FBQyx3QkFBd0IsR0FBR1M7UUFDdkM7UUFFQSxJQUFJLE9BQU9DLGdCQUFnQixhQUFhO1lBQ3BDVixPQUFPLENBQUMsY0FBYyxHQUFHVTtRQUM3QjtRQUVBLElBQUksT0FBT0MsZUFBZSxhQUFhO1lBQ25DWCxPQUFPLENBQUMsYUFBYSxHQUFHVztRQUM1QjtRQUVBLElBQUksT0FBT0MsY0FBYyxhQUFhO1lBQ2xDWixPQUFPLENBQUMsWUFBWSxHQUFHWTtRQUMzQjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUN0QixNQUFNLENBQUNXLElBQUksQ0FBQyxRQUFRRixTQUFTO1lBQzNDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7OztLQVNDLEdBQ0QsTUFBTWEsVUFBVVYsUUFBUSxFQUFFO1FBQ3RCLE1BQU1KLFVBQVUsOEJBQThCZSxPQUFPLENBQUMsY0FBY1g7UUFDcEUsSUFBSUgsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxhQUFhLGFBQWE7WUFDakMsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFHQSxPQUFPLE1BQU0sSUFBSSxDQUFDRSxNQUFNLENBQUNXLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQztJQUNQO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBaUJDLEdBQ0QsTUFBTWUsYUFBYVosUUFBUSxFQUFFQyxJQUFJLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLGVBQWUsRUFBRUMscUJBQXFCLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUU7UUFDL0ksTUFBTWIsVUFBVSw4QkFBOEJlLE9BQU8sQ0FBQyxjQUFjWDtRQUNwRSxJQUFJSCxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGFBQWEsYUFBYTtZQUNqQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT2dCLFNBQVMsYUFBYTtZQUM3QixNQUFNLElBQUloQixrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU9nQixTQUFTLGFBQWE7WUFDN0JKLE9BQU8sQ0FBQyxPQUFPLEdBQUdJO1FBQ3RCO1FBRUEsSUFBSSxPQUFPQyxnQkFBZ0IsYUFBYTtZQUNwQ0wsT0FBTyxDQUFDLGNBQWMsR0FBR0s7UUFDN0I7UUFFQSxJQUFJLE9BQU9DLGlCQUFpQixhQUFhO1lBQ3JDTixPQUFPLENBQUMsZUFBZSxHQUFHTTtRQUM5QjtRQUVBLElBQUksT0FBT0MsWUFBWSxhQUFhO1lBQ2hDUCxPQUFPLENBQUMsVUFBVSxHQUFHTztRQUN6QjtRQUVBLElBQUksT0FBT0Msb0JBQW9CLGFBQWE7WUFDeENSLE9BQU8sQ0FBQyxrQkFBa0IsR0FBR1E7UUFDakM7UUFFQSxJQUFJLE9BQU9DLDBCQUEwQixhQUFhO1lBQzlDVCxPQUFPLENBQUMsd0JBQXdCLEdBQUdTO1FBQ3ZDO1FBRUEsSUFBSSxPQUFPQyxnQkFBZ0IsYUFBYTtZQUNwQ1YsT0FBTyxDQUFDLGNBQWMsR0FBR1U7UUFDN0I7UUFFQSxJQUFJLE9BQU9DLGVBQWUsYUFBYTtZQUNuQ1gsT0FBTyxDQUFDLGFBQWEsR0FBR1c7UUFDNUI7UUFFQSxJQUFJLE9BQU9DLGNBQWMsYUFBYTtZQUNsQ1osT0FBTyxDQUFDLFlBQVksR0FBR1k7UUFDM0I7UUFFQSxPQUFPLE1BQU0sSUFBSSxDQUFDdEIsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTWdCLGFBQWFiLFFBQVEsRUFBRTtRQUN6QixNQUFNSixVQUFVLDhCQUE4QmUsT0FBTyxDQUFDLGNBQWNYO1FBQ3BFLElBQUlILFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csYUFBYSxhQUFhO1lBQ2pDLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBR0EsT0FBTyxNQUFNLElBQUksQ0FBQ0UsTUFBTSxDQUFDVyxJQUFJLENBQUMsVUFBVUYsU0FBUztZQUM3QyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7OztLQVdDLEdBQ0QsTUFBTWlCLFVBQVVkLFFBQVEsRUFBRU4sT0FBTyxFQUFFQyxNQUFNLEVBQUU7UUFDdkMsTUFBTUMsVUFBVSxvQ0FBb0NlLE9BQU8sQ0FBQyxjQUFjWDtRQUMxRSxJQUFJSCxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGFBQWEsYUFBYTtZQUNqQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUdBLElBQUksT0FBT1MsWUFBWSxhQUFhO1lBQ2hDRyxPQUFPLENBQUMsVUFBVSxHQUFHSDtRQUN6QjtRQUVBLElBQUksT0FBT0MsV0FBVyxhQUFhO1lBQy9CRSxPQUFPLENBQUMsU0FBUyxHQUFHRjtRQUN4QjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTRCQyxHQUNELE1BQU1rQixXQUFXZixRQUFRLEVBQUVnQixNQUFNLEVBQUVDLElBQUksRUFBRWYsV0FBVyxFQUFFZ0IsYUFBYSxLQUFPLENBQUMsRUFBRTtRQUN6RSxNQUFNdEIsVUFBVSxvQ0FBb0NlLE9BQU8sQ0FBQyxjQUFjWDtRQUMxRSxJQUFJSCxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGFBQWEsYUFBYTtZQUNqQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBTytCLFdBQVcsYUFBYTtZQUMvQixNQUFNLElBQUkvQixrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU9nQyxTQUFTLGFBQWE7WUFDN0IsTUFBTSxJQUFJaEMsa0JBQWtCO1FBQ2hDO1FBR0EsSUFBSSxPQUFPK0IsV0FBVyxhQUFhO1lBQy9CbkIsT0FBTyxDQUFDLFNBQVMsR0FBR21CO1FBQ3hCO1FBRUEsSUFBSSxPQUFPQyxTQUFTLGFBQWE7WUFDN0JwQixPQUFPLENBQUMsT0FBTyxHQUFHb0I7UUFDdEI7UUFFQSxJQUFJLE9BQU9mLGdCQUFnQixhQUFhO1lBQ3BDTCxPQUFPLENBQUMsY0FBYyxHQUFHSztRQUM3QjtRQUVBLE1BQU1pQixPQUFPRixLQUFLRSxJQUFJO1FBRXRCLE1BQU1DLGFBQWE7WUFDZixnQkFBZ0I7UUFDcEI7UUFFQSxJQUFJQyxLQUFLQztRQUNULElBQUlDLFdBQVdEO1FBRWYsSUFBSUUsaUJBQWlCO1FBRXJCLElBQUdSLFVBQVUsWUFBWTtZQUNyQixJQUFJO2dCQUNBTyxXQUFXLE1BQU0sSUFBSSxDQUFDcEMsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsVUFBVSxNQUFNb0IsUUFBUUk7Z0JBQ2pFSSxpQkFBaUJELFNBQVNDLGNBQWM7WUFDNUMsRUFBRSxPQUFNQyxHQUFHLENBQ1g7UUFDSjtRQUVBLElBQUlDLGVBQWVDLE9BQU9DLElBQUksQ0FBQztRQUMvQixJQUFJQyxtQkFBbUI7UUFDdkIsSUFBSUMsb0JBQW9CO1FBRXhCLE1BQU1DLGFBQWEsSUFBSSxDQUFDNUMsTUFBTTtRQUU5QixlQUFlNkMsWUFBWUMsYUFBYSxLQUFLO1lBQ3pDLElBQUdULGlCQUFpQixLQUFLTSxvQkFBb0IzQyxPQUFPK0MsVUFBVSxFQUFFO2dCQUM1RDtZQUNKO1lBRUEsTUFBTUMsUUFBUUw7WUFDZCxNQUFNTSxNQUFNTixvQkFBb0JELG1CQUFtQjtZQUVuRCxJQUFHLENBQUNJLGNBQWNILHNCQUFzQixHQUFHO2dCQUN2Q1YsVUFBVSxDQUFDLGdCQUFnQixHQUFHLFdBQVdlLFFBQVEsTUFBTUMsTUFBTSxNQUFNakI7WUFDdkU7WUFFQSxJQUFJRSxJQUFJO2dCQUNKRCxVQUFVLENBQUMsZ0JBQWdCLEdBQUdDO1lBQ2xDO1lBRUF4QixPQUFPLENBQUMsT0FBTyxHQUFHO2dCQUNkd0MsTUFBTTtnQkFDTnBCLE1BQU1TO2dCQUNOWSxVQUFVckIsS0FBS3FCLFFBQVE7Z0JBQ3ZCbkIsTUFBTVU7WUFDVjtZQUVBTixXQUFXLE1BQU1RLFdBQVdqQyxJQUFJLENBQUMsUUFBUUYsU0FBU3dCLFlBQVl2QjtZQUU5RCxJQUFJLENBQUN3QixJQUFJO2dCQUNMQSxLQUFLRSxRQUFRLENBQUMsTUFBTTtZQUN4QjtZQUVBLElBQUlMLGVBQWUsTUFBTTtnQkFDckJBLFdBQVc7b0JBQ1BxQixLQUFLaEIsUUFBUSxDQUFDLE1BQU07b0JBQ3BCaUIsVUFBVUMsS0FBS0MsR0FBRyxDQUFDLENBQUNQLFFBQU1oRCxPQUFPK0MsVUFBVSxJQUFJL0MsT0FBTytDLFVBQVUsRUFBRWYsUUFBUUEsT0FBTztvQkFDakZ3QixjQUFjUCxNQUFJO29CQUNsQlEsYUFBYXJCLFFBQVEsQ0FBQyxjQUFjO29CQUNwQ0MsZ0JBQWdCRCxRQUFRLENBQUMsaUJBQWlCO2dCQUM5QztZQUNKO1lBRUFPLHFCQUFxQjNDLE9BQU8rQyxVQUFVO1FBQzFDO1FBRUEsT0FBTyxNQUFNLElBQUlXLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDL0IsTUFBTUMsY0FBYyxJQUFJNUQsT0FBTzZELFFBQVE7WUFDdkNELFlBQVlFLE1BQU0sR0FBRyxPQUFPQyxXQUFXQyxVQUFVQztnQkFDN0MsSUFBSTtvQkFDQSwrQ0FBK0M7b0JBQy9DLE1BQU1DLGdCQUFnQjNCLE9BQU80QixVQUFVLENBQUNKO29CQUN4QyxNQUFNSyxjQUFjZixLQUFLZ0IsSUFBSSxDQUFDSCxnQkFBZ0JuRSxPQUFPK0MsVUFBVTtvQkFDL0QsTUFBTXdCLFNBQVMsRUFBRTtvQkFFakIsSUFBSSxJQUFJQyxJQUFJLEdBQUdBLElBQUlILGFBQWFHLElBQUs7d0JBQ2pDLE1BQU1DLFFBQVFULFVBQVVVLEtBQUssQ0FBQ0YsSUFBSXhFLE9BQU8rQyxVQUFVLEVBQUUsQ0FBQ3lCLElBQUksS0FBS3hFLE9BQU8rQyxVQUFVO3dCQUNoRndCLE9BQU9JLElBQUksQ0FBQ0Y7b0JBQ2hCO29CQUVBLEtBQUssTUFBTUEsU0FBU0YsT0FBUTt3QkFDeEIsTUFBTUssWUFBWXBDLE9BQU80QixVQUFVLENBQUNLO3dCQUVwQyxJQUFHRyxZQUFZbEMsb0JBQW9CMUMsT0FBTytDLFVBQVUsRUFBRTs0QkFDbEQsZUFBZTs0QkFDZlIsZUFBZUMsT0FBT3FDLE1BQU0sQ0FBQztnQ0FBQ3RDO2dDQUFja0M7NkJBQU07NEJBQ2xEL0IsbUJBQW1CRixPQUFPNEIsVUFBVSxDQUFDN0I7NEJBQ3JDLE1BQU1NOzRCQUNOTixlQUFlQyxPQUFPQyxJQUFJLENBQUM7NEJBQzNCQyxtQkFBbUI7d0JBQ3ZCLE9BQU8sSUFBR2tDLFlBQVlsQyxtQkFBbUIxQyxPQUFPK0MsVUFBVSxFQUFFOzRCQUN4RCx5Q0FBeUM7NEJBQ3pDLE1BQU0rQixnQkFBZ0I5RSxPQUFPK0MsVUFBVSxHQUFHTDs0QkFDMUMsTUFBTXFDLGtCQUFrQk4sTUFBTUMsS0FBSyxDQUFDLEdBQUdJOzRCQUN2Q3ZDLGVBQWVDLE9BQU9xQyxNQUFNLENBQUM7Z0NBQUN0QztnQ0FBY3dDOzZCQUFnQjs0QkFDNURyQyxtQkFBbUJGLE9BQU80QixVQUFVLENBQUM3Qjs0QkFDckMsTUFBTU07NEJBQ05OLGVBQWVrQyxNQUFNQyxLQUFLLENBQUNJLGVBQWUzQzs0QkFDMUNPLG1CQUFtQmtDLFlBQVlFO3dCQUNuQyxPQUFPOzRCQUNILDRCQUE0Qjs0QkFDNUJ2QyxlQUFlQyxPQUFPcUMsTUFBTSxDQUFDO2dDQUFDdEM7Z0NBQWNrQzs2QkFBTTs0QkFDbEQvQixtQkFBbUJrQyxZQUFZbEM7d0JBQ25DO29CQUNKO29CQUVBd0I7Z0JBQ0osRUFBRSxPQUFPNUIsR0FBRztvQkFDUjRCLFNBQVM1QjtnQkFDYjtZQUNKO1lBRUF1QixZQUFZbUIsRUFBRSxDQUFDLFVBQVU7Z0JBQ3JCLElBQUd0QyxtQkFBbUIsR0FBRztvQkFDckIsSUFBSTt3QkFDQSxNQUFNRyxZQUFZO29CQUN0QixFQUFFLE9BQU9QLEdBQUc7d0JBQ1JzQixPQUFPdEI7b0JBQ1g7Z0JBQ0o7Z0JBRUFxQixRQUFRdkI7WUFDWjtZQUVBeUIsWUFBWW1CLEVBQUUsQ0FBQyxTQUFTLENBQUNDO2dCQUNyQnJCLE9BQU9xQjtZQUNYO1lBRUFuRCxLQUFLb0QsTUFBTSxDQUFDQyxJQUFJLENBQUN0QjtRQUNyQjtJQUVKO0lBRUE7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU11QixRQUFRdkUsUUFBUSxFQUFFZ0IsTUFBTSxFQUFFO1FBQzVCLE1BQU1wQixVQUFVLDZDQUE2Q2UsT0FBTyxDQUFDLGNBQWNYLFVBQVVXLE9BQU8sQ0FBQyxZQUFZSztRQUNqSCxJQUFJbkIsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxhQUFhLGFBQWE7WUFDakMsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU8rQixXQUFXLGFBQWE7WUFDL0IsTUFBTSxJQUFJL0Isa0JBQWtCO1FBQ2hDO1FBR0EsT0FBTyxNQUFNLElBQUksQ0FBQ0UsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELE1BQU0yRSxXQUFXeEUsUUFBUSxFQUFFZ0IsTUFBTSxFQUFFZixJQUFJLEVBQUVDLFdBQVcsRUFBRTtRQUNsRCxNQUFNTixVQUFVLDZDQUE2Q2UsT0FBTyxDQUFDLGNBQWNYLFVBQVVXLE9BQU8sQ0FBQyxZQUFZSztRQUNqSCxJQUFJbkIsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxhQUFhLGFBQWE7WUFDakMsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU8rQixXQUFXLGFBQWE7WUFDL0IsTUFBTSxJQUFJL0Isa0JBQWtCO1FBQ2hDO1FBR0EsSUFBSSxPQUFPZ0IsU0FBUyxhQUFhO1lBQzdCSixPQUFPLENBQUMsT0FBTyxHQUFHSTtRQUN0QjtRQUVBLElBQUksT0FBT0MsZ0JBQWdCLGFBQWE7WUFDcENMLE9BQU8sQ0FBQyxjQUFjLEdBQUdLO1FBQzdCO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FBQ2YsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNNEUsV0FBV3pFLFFBQVEsRUFBRWdCLE1BQU0sRUFBRTtRQUMvQixNQUFNcEIsVUFBVSw2Q0FBNkNlLE9BQU8sQ0FBQyxjQUFjWCxVQUFVVyxPQUFPLENBQUMsWUFBWUs7UUFDakgsSUFBSW5CLFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csYUFBYSxhQUFhO1lBQ2pDLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBRUEsSUFBSSxPQUFPK0IsV0FBVyxhQUFhO1lBQy9CLE1BQU0sSUFBSS9CLGtCQUFrQjtRQUNoQztRQUdBLE9BQU8sTUFBTSxJQUFJLENBQUNFLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLFVBQVVGLFNBQVM7WUFDN0MsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7SUFFQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNELE1BQU02RSxnQkFBZ0IxRSxRQUFRLEVBQUVnQixNQUFNLEVBQUU7UUFDcEMsTUFBTXBCLFVBQVUsc0RBQXNEZSxPQUFPLENBQUMsY0FBY1gsVUFBVVcsT0FBTyxDQUFDLFlBQVlLO1FBQzFILElBQUluQixVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGFBQWEsYUFBYTtZQUNqQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBTytCLFdBQVcsYUFBYTtZQUMvQixNQUFNLElBQUkvQixrQkFBa0I7UUFDaEM7UUFHQSxPQUFPLE1BQU0sSUFBSSxDQUFDRSxNQUFNLENBQUNXLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQyxTQUFTO0lBQ2hCO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXdCQyxHQUNELE1BQU04RSxlQUFlM0UsUUFBUSxFQUFFZ0IsTUFBTSxFQUFFNEQsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFFQyxNQUFNLEVBQUU7UUFDbkosTUFBTTFGLFVBQVUscURBQXFEZSxPQUFPLENBQUMsY0FBY1gsVUFBVVcsT0FBTyxDQUFDLFlBQVlLO1FBQ3pILElBQUluQixVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLGFBQWEsYUFBYTtZQUNqQyxNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBTytCLFdBQVcsYUFBYTtZQUMvQixNQUFNLElBQUkvQixrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU8yRixVQUFVLGFBQWE7WUFDOUIvRSxPQUFPLENBQUMsUUFBUSxHQUFHK0U7UUFDdkI7UUFFQSxJQUFJLE9BQU9DLFdBQVcsYUFBYTtZQUMvQmhGLE9BQU8sQ0FBQyxTQUFTLEdBQUdnRjtRQUN4QjtRQUVBLElBQUksT0FBT0MsWUFBWSxhQUFhO1lBQ2hDakYsT0FBTyxDQUFDLFVBQVUsR0FBR2lGO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxZQUFZLGFBQWE7WUFDaENsRixPQUFPLENBQUMsVUFBVSxHQUFHa0Y7UUFDekI7UUFFQSxJQUFJLE9BQU9DLGdCQUFnQixhQUFhO1lBQ3BDbkYsT0FBTyxDQUFDLGNBQWMsR0FBR21GO1FBQzdCO1FBRUEsSUFBSSxPQUFPQyxnQkFBZ0IsYUFBYTtZQUNwQ3BGLE9BQU8sQ0FBQyxjQUFjLEdBQUdvRjtRQUM3QjtRQUVBLElBQUksT0FBT0MsaUJBQWlCLGFBQWE7WUFDckNyRixPQUFPLENBQUMsZUFBZSxHQUFHcUY7UUFDOUI7UUFFQSxJQUFJLE9BQU9DLFlBQVksYUFBYTtZQUNoQ3RGLE9BQU8sQ0FBQyxVQUFVLEdBQUdzRjtRQUN6QjtRQUVBLElBQUksT0FBT0MsYUFBYSxhQUFhO1lBQ2pDdkYsT0FBTyxDQUFDLFdBQVcsR0FBR3VGO1FBQzFCO1FBRUEsSUFBSSxPQUFPQyxlQUFlLGFBQWE7WUFDbkN4RixPQUFPLENBQUMsYUFBYSxHQUFHd0Y7UUFDNUI7UUFFQSxJQUFJLE9BQU9DLFdBQVcsYUFBYTtZQUMvQnpGLE9BQU8sQ0FBQyxTQUFTLEdBQUd5RjtRQUN4QjtRQUVBLE9BQU8sTUFBTSxJQUFJLENBQUNuRyxNQUFNLENBQUNXLElBQUksQ0FBQyxPQUFPRixTQUFTO1lBQzFDLGdCQUFnQjtRQUNwQixHQUFHQyxTQUFTO0lBQ2hCO0lBRUE7Ozs7Ozs7Ozs7O0tBV0MsR0FDRCxNQUFNMEYsWUFBWXZGLFFBQVEsRUFBRWdCLE1BQU0sRUFBRTtRQUNoQyxNQUFNcEIsVUFBVSxrREFBa0RlLE9BQU8sQ0FBQyxjQUFjWCxVQUFVVyxPQUFPLENBQUMsWUFBWUs7UUFDdEgsSUFBSW5CLFVBQVUsQ0FBQztRQUNmLElBQUksT0FBT0csYUFBYSxhQUFhO1lBQ2pDLE1BQU0sSUFBSWYsa0JBQWtCO1FBQ2hDO1FBRUEsSUFBSSxPQUFPK0IsV0FBVyxhQUFhO1lBQy9CLE1BQU0sSUFBSS9CLGtCQUFrQjtRQUNoQztRQUdBLE9BQU8sTUFBTSxJQUFJLENBQUNFLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDLFNBQVM7SUFDaEI7QUFDSjtBQUVBMkYsT0FBT0MsT0FBTyxHQUFHbEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9zdG9yYWdlLmpzPzk2N2EiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5jbGFzcyBTdG9yYWdlIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGlzdCBidWNrZXRzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgc3RvcmFnZSBidWNrZXRzLiBZb3UgY2FuIHVzZSB0aGUgcXVlcnkgcGFyYW1zIHRvXG4gICAgICogZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEJ1Y2tldHMocXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGJ1Y2tldFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0b3JhZ2UgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJtaXNzaW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsZVNlY3VyaXR5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heGltdW1GaWxlU2l6ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGFsbG93ZWRGaWxlRXh0ZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5jcnlwdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYW50aXZpcnVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQnVja2V0KGJ1Y2tldElkLCBuYW1lLCBwZXJtaXNzaW9ucywgZmlsZVNlY3VyaXR5LCBlbmFibGVkLCBtYXhpbXVtRmlsZVNpemUsIGFsbG93ZWRGaWxlRXh0ZW5zaW9ucywgY29tcHJlc3Npb24sIGVuY3J5cHRpb24sIGFudGl2aXJ1cykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYnVja2V0SWQnXSA9IGJ1Y2tldElkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVTZWN1cml0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZpbGVTZWN1cml0eSddID0gZmlsZVNlY3VyaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4aW11bUZpbGVTaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4aW11bUZpbGVTaXplJ10gPSBtYXhpbXVtRmlsZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFsbG93ZWRGaWxlRXh0ZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FsbG93ZWRGaWxlRXh0ZW5zaW9ucyddID0gYWxsb3dlZEZpbGVFeHRlbnNpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21wcmVzc2lvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbXByZXNzaW9uJ10gPSBjb21wcmVzc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5jcnlwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuY3J5cHRpb24nXSA9IGVuY3J5cHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFudGl2aXJ1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FudGl2aXJ1cyddID0gYW50aXZpcnVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYnVja2V0XG4gICAgICpcbiAgICAgKiBHZXQgYSBzdG9yYWdlIGJ1Y2tldCBieSBpdHMgdW5pcXVlIElELiBUaGlzIGVuZHBvaW50IHJlc3BvbnNlIHJldHVybnMgYVxuICAgICAqIEpTT04gb2JqZWN0IHdpdGggdGhlIHN0b3JhZ2UgYnVja2V0IG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnVja2V0KGJ1Y2tldElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYnVja2V0XG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBzdG9yYWdlIGJ1Y2tldCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJtaXNzaW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsZVNlY3VyaXR5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heGltdW1GaWxlU2l6ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGFsbG93ZWRGaWxlRXh0ZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5jcnlwdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYW50aXZpcnVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQnVja2V0KGJ1Y2tldElkLCBuYW1lLCBwZXJtaXNzaW9ucywgZmlsZVNlY3VyaXR5LCBlbmFibGVkLCBtYXhpbXVtRmlsZVNpemUsIGFsbG93ZWRGaWxlRXh0ZW5zaW9ucywgY29tcHJlc3Npb24sIGVuY3J5cHRpb24sIGFudGl2aXJ1cykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVTZWN1cml0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZpbGVTZWN1cml0eSddID0gZmlsZVNlY3VyaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4aW11bUZpbGVTaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4aW11bUZpbGVTaXplJ10gPSBtYXhpbXVtRmlsZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFsbG93ZWRGaWxlRXh0ZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FsbG93ZWRGaWxlRXh0ZW5zaW9ucyddID0gYWxsb3dlZEZpbGVFeHRlbnNpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21wcmVzc2lvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbXByZXNzaW9uJ10gPSBjb21wcmVzc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5jcnlwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuY3J5cHRpb24nXSA9IGVuY3J5cHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFudGl2aXJ1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FudGl2aXJ1cyddID0gYW50aXZpcnVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBidWNrZXRcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHN0b3JhZ2UgYnVja2V0IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVCdWNrZXQoYnVja2V0SWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgZmlsZXNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSB1c2VyIGZpbGVzLiBZb3UgY2FuIHVzZSB0aGUgcXVlcnkgcGFyYW1zIHRvIGZpbHRlclxuICAgICAqIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEZpbGVzKGJ1Y2tldElkLCBxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZpbGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmaWxlLiBCZWZvcmUgdXNpbmcgdGhpcyByb3V0ZSwgeW91IHNob3VsZCBjcmVhdGUgYSBuZXcgYnVja2V0XG4gICAgICogcmVzb3VyY2UgdXNpbmcgZWl0aGVyIGEgW3NlcnZlclxuICAgICAqIGludGVncmF0aW9uXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL3N0b3JhZ2Ujc3RvcmFnZUNyZWF0ZUJ1Y2tldClcbiAgICAgKiBBUEkgb3IgZGlyZWN0bHkgZnJvbSB5b3VyIEFwcHdyaXRlIGNvbnNvbGUuXG4gICAgICogXG4gICAgICogTGFyZ2VyIGZpbGVzIHNob3VsZCBiZSB1cGxvYWRlZCB1c2luZyBtdWx0aXBsZSByZXF1ZXN0cyB3aXRoIHRoZVxuICAgICAqIFtjb250ZW50LXJhbmdlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ29udGVudC1SYW5nZSlcbiAgICAgKiBoZWFkZXIgdG8gc2VuZCBhIHBhcnRpYWwgcmVxdWVzdCB3aXRoIGEgbWF4aW11bSBzdXBwb3J0ZWQgY2h1bmsgb2YgYDVNQmAuXG4gICAgICogVGhlIGBjb250ZW50LXJhbmdlYCBoZWFkZXIgdmFsdWVzIHNob3VsZCBhbHdheXMgYmUgaW4gYnl0ZXMuXG4gICAgICogXG4gICAgICogV2hlbiB0aGUgZmlyc3QgcmVxdWVzdCBpcyBzZW50LCB0aGUgc2VydmVyIHdpbGwgcmV0dXJuIHRoZSAqKkZpbGUqKiBvYmplY3QsXG4gICAgICogYW5kIHRoZSBzdWJzZXF1ZW50IHBhcnQgcmVxdWVzdCBtdXN0IGluY2x1ZGUgdGhlIGZpbGUncyAqKmlkKiogaW5cbiAgICAgKiBgeC1hcHB3cml0ZS1pZGAgaGVhZGVyIHRvIGFsbG93IHRoZSBzZXJ2ZXIgdG8ga25vdyB0aGF0IHRoZSBwYXJ0aWFsIHVwbG9hZFxuICAgICAqIGlzIGZvciB0aGUgZXhpc3RpbmcgZmlsZSBhbmQgbm90IGZvciBhIG5ldyBvbmUuXG4gICAgICogXG4gICAgICogSWYgeW91J3JlIGNyZWF0aW5nIGEgbmV3IGZpbGUgdXNpbmcgb25lIG9mIHRoZSBBcHB3cml0ZSBTREtzLCBhbGwgdGhlXG4gICAgICogY2h1bmtpbmcgbG9naWMgd2lsbCBiZSBtYW5hZ2VkIGJ5IHRoZSBTREsgaW50ZXJuYWxseS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAcGFyYW0ge0lucHV0RmlsZX0gZmlsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRmlsZShidWNrZXRJZCwgZmlsZUlkLCBmaWxlLCBwZXJtaXNzaW9ucywgb25Qcm9ncmVzcyA9ICgpID0+IHt9KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzJy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZmlsZUlkJ10gPSBmaWxlSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlJ10gPSBmaWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNpemUgPSBmaWxlLnNpemU7XG5cbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGlkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgbGV0IGNodW5rc1VwbG9hZGVkID0gMDtcblxuICAgICAgICBpZihmaWxlSWQgIT0gJ3VuaXF1ZSgpJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGggKyAnLycgKyBmaWxlSWQsIGFwaUhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIGNodW5rc1VwbG9hZGVkID0gcmVzcG9uc2UuY2h1bmtzVXBsb2FkZWQ7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJyZW50Q2h1bmsgPSBCdWZmZXIuZnJvbSgnJyk7XG4gICAgICAgIGxldCBjdXJyZW50Q2h1bmtTaXplID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRDaHVua1N0YXJ0ID0gMDtcblxuICAgICAgICBjb25zdCBzZWxmQ2xpZW50ID0gdGhpcy5jbGllbnQ7XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gdXBsb2FkQ2h1bmsobGFzdFVwbG9hZCA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZihjaHVua3NVcGxvYWRlZCAtIDEgPj0gY3VycmVudENodW5rU3RhcnQgLyBjbGllbnQuQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBjdXJyZW50Q2h1bmtTdGFydDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGN1cnJlbnRDaHVua1N0YXJ0ICsgY3VycmVudENodW5rU2l6ZSAtIDE7XG5cbiAgICAgICAgICAgIGlmKCFsYXN0VXBsb2FkIHx8IGN1cnJlbnRDaHVua1N0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgYXBpSGVhZGVyc1snY29udGVudC1yYW5nZSddID0gJ2J5dGVzICcgKyBzdGFydCArICctJyArIGVuZCArICcvJyArIHNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGFwaUhlYWRlcnNbJ3gtYXBwd3JpdGUtaWQnXSA9IGlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlJ10gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgICAgICAgICAgIGZpbGU6IGN1cnJlbnRDaHVuayxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZS5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBjdXJyZW50Q2h1bmtTaXplXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHNlbGZDbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgaWQgPSByZXNwb25zZVsnJGlkJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgICAgICRpZDogcmVzcG9uc2VbJyRpZCddLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogTWF0aC5taW4oKHN0YXJ0K2NsaWVudC5DSFVOS19TSVpFKSAqIGNsaWVudC5DSFVOS19TSVpFLCBzaXplKSAvIHNpemUgKiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIHNpemVVcGxvYWRlZDogZW5kKzEsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1RvdGFsOiByZXNwb25zZVsnY2h1bmtzVG90YWwnXSxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzVXBsb2FkZWQ6IHJlc3BvbnNlWydjaHVua3NVcGxvYWRlZCddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRDaHVua1N0YXJ0ICs9IGNsaWVudC5DSFVOS19TSVpFO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gbmV3IFN0cmVhbS5Xcml0YWJsZSgpO1xuICAgICAgICAgICAgd3JpdGVTdHJlYW0uX3dyaXRlID0gYXN5bmMgKG1haW5DaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VnbWVudCBpbmNvbWluZyBjaHVuayBpbnRvIHVwIHRvIDVNQiBjaHVua3NcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFpbkNodW5rU2l6ZSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG1haW5DaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rc0NvdW50ID0gTWF0aC5jZWlsKG1haW5DaHVua1NpemUgLyBjbGllbnQuQ0hVTktfU0laRSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjaHVua3NDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IG1haW5DaHVuay5zbGljZShpICogY2xpZW50LkNIVU5LX1NJWkUsIChpICsgMSkgKiBjbGllbnQuQ0hVTktfU0laRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjaHVua1NpemUgKyBjdXJyZW50Q2h1bmtTaXplID09IGNsaWVudC5DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBsb2FkIGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rID0gQnVmZmVyLmNvbmNhdChbY3VycmVudENodW5rLCBjaHVua10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1NpemUgPSBCdWZmZXIuYnl0ZUxlbmd0aChjdXJyZW50Q2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZENodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rID0gQnVmZmVyLmZyb20oJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1NpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGNodW5rU2l6ZSArIGN1cnJlbnRDaHVua1NpemUgPiBjbGllbnQuQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwbG9hZCBjaHVuaywgcHV0IHJlc3QgaW50byBuZXh0IGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXNUb1VwbG9hZCA9IGNsaWVudC5DSFVOS19TSVpFIC0gY3VycmVudENodW5rU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDaHVua1NlY3Rpb24gPSBjaHVuay5zbGljZSgwLCBieXRlc1RvVXBsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsgPSBCdWZmZXIuY29uY2F0KFtjdXJyZW50Q2h1bmssIG5ld0NodW5rU2VjdGlvbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1NpemUgPSBCdWZmZXIuYnl0ZUxlbmd0aChjdXJyZW50Q2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZENodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rID0gY2h1bmsuc2xpY2UoYnl0ZXNUb1VwbG9hZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtTaXplID0gY2h1bmtTaXplIC0gYnl0ZXNUb1VwbG9hZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGludG8gY3VycmVudCBjaHVua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuayA9IEJ1ZmZlci5jb25jYXQoW2N1cnJlbnRDaHVuaywgY2h1bmtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtTaXplID0gY2h1bmtTaXplICsgY3VycmVudENodW5rU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyaXRlU3RyZWFtLm9uKFwiZmluaXNoXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50Q2h1bmtTaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkQ2h1bmsodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3cml0ZVN0cmVhbS5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmaWxlLnN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZVxuICAgICAqXG4gICAgICogR2V0IGEgZmlsZSBieSBpdHMgdW5pcXVlIElELiBUaGlzIGVuZHBvaW50IHJlc3BvbnNlIHJldHVybnMgYSBKU09OIG9iamVjdFxuICAgICAqIHdpdGggdGhlIGZpbGUgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmlsZShidWNrZXRJZCwgZmlsZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZmlsZVxuICAgICAqXG4gICAgICogVXBkYXRlIGEgZmlsZSBieSBpdHMgdW5pcXVlIElELiBPbmx5IHVzZXJzIHdpdGggd3JpdGUgcGVybWlzc2lvbnMgaGF2ZVxuICAgICAqIGFjY2VzcyB0byB1cGRhdGUgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRmlsZShidWNrZXRJZCwgZmlsZUlkLCBuYW1lLCBwZXJtaXNzaW9ucykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgRmlsZVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgZmlsZSBieSBpdHMgdW5pcXVlIElELiBPbmx5IHVzZXJzIHdpdGggd3JpdGUgcGVybWlzc2lvbnMgaGF2ZVxuICAgICAqIGFjY2VzcyB0byBkZWxldGUgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVGaWxlKGJ1Y2tldElkLCBmaWxlSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIGZvciBkb3dubG9hZFxuICAgICAqXG4gICAgICogR2V0IGEgZmlsZSBjb250ZW50IGJ5IGl0cyB1bmlxdWUgSUQuIFRoZSBlbmRwb2ludCByZXNwb25zZSByZXR1cm4gd2l0aCBhXG4gICAgICogJ0NvbnRlbnQtRGlzcG9zaXRpb246IGF0dGFjaG1lbnQnIGhlYWRlciB0aGF0IHRlbGxzIHRoZSBicm93c2VyIHRvIHN0YXJ0XG4gICAgICogZG93bmxvYWRpbmcgdGhlIGZpbGUgdG8gdXNlciBkb3dubG9hZHMgZGlyZWN0b3J5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbGVEb3dubG9hZChidWNrZXRJZCwgZmlsZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L2Rvd25sb2FkJy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBwcmV2aWV3XG4gICAgICpcbiAgICAgKiBHZXQgYSBmaWxlIHByZXZpZXcgaW1hZ2UuIEN1cnJlbnRseSwgdGhpcyBtZXRob2Qgc3VwcG9ydHMgcHJldmlldyBmb3IgaW1hZ2VcbiAgICAgKiBmaWxlcyAoanBnLCBwbmcsIGFuZCBnaWYpLCBvdGhlciBzdXBwb3J0ZWQgZm9ybWF0cywgbGlrZSBwZGYsIGRvY3MsIHNsaWRlcyxcbiAgICAgKiBhbmQgc3ByZWFkc2hlZXRzLCB3aWxsIHJldHVybiB0aGUgZmlsZSBpY29uIGltYWdlLiBZb3UgY2FuIGFsc28gcGFzcyBxdWVyeVxuICAgICAqIHN0cmluZyBhcmd1bWVudHMgZm9yIGN1dHRpbmcgYW5kIHJlc2l6aW5nIHlvdXIgcHJldmlldyBpbWFnZS4gUHJldmlldyBpc1xuICAgICAqIHN1cHBvcnRlZCBvbmx5IGZvciBpbWFnZSBmaWxlcyBzbWFsbGVyIHRoYW4gMTBNQi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdyYXZpdHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3JkZXJXaWR0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3JkZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrZ3JvdW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG91dHB1dFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbGVQcmV2aWV3KGJ1Y2tldElkLCBmaWxlSWQsIHdpZHRoLCBoZWlnaHQsIGdyYXZpdHksIHF1YWxpdHksIGJvcmRlcldpZHRoLCBib3JkZXJDb2xvciwgYm9yZGVyUmFkaXVzLCBvcGFjaXR5LCByb3RhdGlvbiwgYmFja2dyb3VuZCwgb3V0cHV0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L3ByZXZpZXcnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGdyYXZpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydncmF2aXR5J10gPSBncmF2aXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVhbGl0eSddID0gcXVhbGl0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYm9yZGVyV2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydib3JkZXJXaWR0aCddID0gYm9yZGVyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJvcmRlckNvbG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9yZGVyQ29sb3InXSA9IGJvcmRlckNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBib3JkZXJSYWRpdXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydib3JkZXJSYWRpdXMnXSA9IGJvcmRlclJhZGl1cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ29wYWNpdHknXSA9IG9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJvdGF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm90YXRpb24nXSA9IHJvdGF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBiYWNrZ3JvdW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYmFja2dyb3VuZCddID0gYmFja2dyb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3V0cHV0J10gPSBvdXRwdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2FycmF5YnVmZmVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGZpbGUgZm9yIHZpZXdcbiAgICAgKlxuICAgICAqIEdldCBhIGZpbGUgY29udGVudCBieSBpdHMgdW5pcXVlIElELiBUaGlzIGVuZHBvaW50IGlzIHNpbWlsYXIgdG8gdGhlXG4gICAgICogZG93bmxvYWQgbWV0aG9kIGJ1dCByZXR1cm5zIHdpdGggbm8gICdDb250ZW50LURpc3Bvc2l0aW9uOiBhdHRhY2htZW50J1xuICAgICAqIGhlYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGaWxlVmlldyhidWNrZXRJZCwgZmlsZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L3ZpZXcnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdG9yYWdlO1xuIl0sIm5hbWVzIjpbIlNlcnZpY2UiLCJyZXF1aXJlIiwiQXBwd3JpdGVFeGNlcHRpb24iLCJJbnB1dEZpbGUiLCJjbGllbnQiLCJTdHJlYW0iLCJwcm9taXNpZnkiLCJmcyIsIlN0b3JhZ2UiLCJjb25zdHJ1Y3RvciIsImxpc3RCdWNrZXRzIiwicXVlcmllcyIsInNlYXJjaCIsImFwaVBhdGgiLCJwYXlsb2FkIiwiY2FsbCIsImNyZWF0ZUJ1Y2tldCIsImJ1Y2tldElkIiwibmFtZSIsInBlcm1pc3Npb25zIiwiZmlsZVNlY3VyaXR5IiwiZW5hYmxlZCIsIm1heGltdW1GaWxlU2l6ZSIsImFsbG93ZWRGaWxlRXh0ZW5zaW9ucyIsImNvbXByZXNzaW9uIiwiZW5jcnlwdGlvbiIsImFudGl2aXJ1cyIsImdldEJ1Y2tldCIsInJlcGxhY2UiLCJ1cGRhdGVCdWNrZXQiLCJkZWxldGVCdWNrZXQiLCJsaXN0RmlsZXMiLCJjcmVhdGVGaWxlIiwiZmlsZUlkIiwiZmlsZSIsIm9uUHJvZ3Jlc3MiLCJzaXplIiwiYXBpSGVhZGVycyIsImlkIiwidW5kZWZpbmVkIiwicmVzcG9uc2UiLCJjaHVua3NVcGxvYWRlZCIsImUiLCJjdXJyZW50Q2h1bmsiLCJCdWZmZXIiLCJmcm9tIiwiY3VycmVudENodW5rU2l6ZSIsImN1cnJlbnRDaHVua1N0YXJ0Iiwic2VsZkNsaWVudCIsInVwbG9hZENodW5rIiwibGFzdFVwbG9hZCIsIkNIVU5LX1NJWkUiLCJzdGFydCIsImVuZCIsInR5cGUiLCJmaWxlbmFtZSIsIiRpZCIsInByb2dyZXNzIiwiTWF0aCIsIm1pbiIsInNpemVVcGxvYWRlZCIsImNodW5rc1RvdGFsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ3cml0ZVN0cmVhbSIsIldyaXRhYmxlIiwiX3dyaXRlIiwibWFpbkNodW5rIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsIm1haW5DaHVua1NpemUiLCJieXRlTGVuZ3RoIiwiY2h1bmtzQ291bnQiLCJjZWlsIiwiY2h1bmtzIiwiaSIsImNodW5rIiwic2xpY2UiLCJwdXNoIiwiY2h1bmtTaXplIiwiY29uY2F0IiwiYnl0ZXNUb1VwbG9hZCIsIm5ld0NodW5rU2VjdGlvbiIsIm9uIiwiZXJyIiwic3RyZWFtIiwicGlwZSIsImdldEZpbGUiLCJ1cGRhdGVGaWxlIiwiZGVsZXRlRmlsZSIsImdldEZpbGVEb3dubG9hZCIsImdldEZpbGVQcmV2aWV3Iiwid2lkdGgiLCJoZWlnaHQiLCJncmF2aXR5IiwicXVhbGl0eSIsImJvcmRlcldpZHRoIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJSYWRpdXMiLCJvcGFjaXR5Iiwicm90YXRpb24iLCJiYWNrZ3JvdW5kIiwib3V0cHV0IiwiZ2V0RmlsZVZpZXciLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/storage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/teams.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/teams.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Teams extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * List teams\n     *\n     * Get a list of all the teams in which the current user is a member. You can\n     * use the parameters to filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async list(queries, search) {\n        const apiPath = \"/teams\";\n        let payload = {};\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create team\n     *\n     * Create a new team. The user who creates the team will automatically be\n     * assigned as the owner of the team. Only the users with the owner role can\n     * invite new members, add new owners and delete or update the team.\n     *\n     * @param {string} teamId\n     * @param {string} name\n     * @param {string[]} roles\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async create(teamId, name, roles) {\n        const apiPath = \"/teams\";\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof teamId !== \"undefined\") {\n            payload[\"teamId\"] = teamId;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        if (typeof roles !== \"undefined\") {\n            payload[\"roles\"] = roles;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get team\n     *\n     * Get a team by its ID. All team members have read access for this resource.\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async get(teamId) {\n        const apiPath = \"/teams/{teamId}\".replace(\"{teamId}\", teamId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update name\n     *\n     * Update the team's name by its unique ID.\n     *\n     * @param {string} teamId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateName(teamId, name) {\n        const apiPath = \"/teams/{teamId}\".replace(\"{teamId}\", teamId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete team\n     *\n     * Delete a team using its ID. Only team members with the owner role can\n     * delete the team.\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async delete(teamId) {\n        const apiPath = \"/teams/{teamId}\".replace(\"{teamId}\", teamId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List team memberships\n     *\n     * Use this endpoint to list a team's members using the team's ID. All team\n     * members have read access to this endpoint.\n     *\n     * @param {string} teamId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listMemberships(teamId, queries, search) {\n        const apiPath = \"/teams/{teamId}/memberships\".replace(\"{teamId}\", teamId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create team membership\n     *\n     * Invite a new member to join your team. Provide an ID for existing users, or\n     * invite unregistered users using an email or phone number. If initiated from\n     * a Client SDK, Appwrite will send an email or sms with a link to join the\n     * team to the invited user, and an account will be created for them if one\n     * doesn't exist. If initiated from a Server SDK, the new member will be added\n     * automatically to the team.\n     * \n     * You only need to provide one of a user ID, email, or phone number. Appwrite\n     * will prioritize accepting the user ID > email > phone number if you provide\n     * more than one of these parameters.\n     * \n     * Use the `url` parameter to redirect the user from the invitation email to\n     * your app. After the user is redirected, use the [Update Team Membership\n     * Status](https://appwrite.io/docs/references/cloud/client-web/teams#updateMembershipStatus)\n     * endpoint to allow the user to accept the invitation to the team. \n     * \n     * Please note that to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n     * Appwrite will accept the only redirect URLs under the domains you have\n     * added as a platform on the Appwrite Console.\n     * \n     *\n     * @param {string} teamId\n     * @param {string[]} roles\n     * @param {string} email\n     * @param {string} userId\n     * @param {string} phone\n     * @param {string} url\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createMembership(teamId, roles, email, userId, phone, url, name) {\n        const apiPath = \"/teams/{teamId}/memberships\".replace(\"{teamId}\", teamId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof roles === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof phone !== \"undefined\") {\n            payload[\"phone\"] = phone;\n        }\n        if (typeof roles !== \"undefined\") {\n            payload[\"roles\"] = roles;\n        }\n        if (typeof url !== \"undefined\") {\n            payload[\"url\"] = url;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get team membership\n     *\n     * Get a team member by the membership unique id. All team members have read\n     * access for this resource.\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getMembership(teamId, membershipId) {\n        const apiPath = \"/teams/{teamId}/memberships/{membershipId}\".replace(\"{teamId}\", teamId).replace(\"{membershipId}\", membershipId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update membership\n     *\n     * Modify the roles of a team member. Only team members with the owner role\n     * have access to this endpoint. Learn more about [roles and\n     * permissions](https://appwrite.io/docs/permissions).\n     * \n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @param {string[]} roles\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateMembership(teamId, membershipId, roles) {\n        const apiPath = \"/teams/{teamId}/memberships/{membershipId}\".replace(\"{teamId}\", teamId).replace(\"{membershipId}\", membershipId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        if (typeof roles === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n        if (typeof roles !== \"undefined\") {\n            payload[\"roles\"] = roles;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete team membership\n     *\n     * This endpoint allows a user to leave a team or for a team owner to delete\n     * the membership of any other team member. You can also use this endpoint to\n     * delete a user membership even if it is not accepted.\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteMembership(teamId, membershipId) {\n        const apiPath = \"/teams/{teamId}/memberships/{membershipId}\".replace(\"{teamId}\", teamId).replace(\"{membershipId}\", membershipId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update team membership status\n     *\n     * Use this endpoint to allow a user to accept an invitation to join a team\n     * after being redirected back to your app from the invitation email received\n     * by the user.\n     * \n     * If the request is successful, a session for the user is automatically\n     * created.\n     * \n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateMembershipStatus(teamId, membershipId, userId, secret) {\n        const apiPath = \"/teams/{teamId}/memberships/{membershipId}/status\".replace(\"{teamId}\", teamId).replace(\"{membershipId}\", membershipId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof secret !== \"undefined\") {\n            payload[\"secret\"] = secret;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get team preferences\n     *\n     * Get the team's shared preferences by its unique ID. If a preference doesn't\n     * need to be shared by all team members, prefer storing them in [user\n     * preferences](https://appwrite.io/docs/references/cloud/client-web/account#getPrefs).\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getPrefs(teamId) {\n        const apiPath = \"/teams/{teamId}/prefs\".replace(\"{teamId}\", teamId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update preferences\n     *\n     * Update the team's preferences by its unique ID. The object you pass is\n     * stored as is and replaces any previous value. The maximum allowed prefs\n     * size is 64kB and throws an error if exceeded.\n     *\n     * @param {string} teamId\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updatePrefs(teamId, prefs) {\n        const apiPath = \"/teams/{teamId}/prefs\".replace(\"{teamId}\", teamId);\n        let payload = {};\n        if (typeof teamId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof prefs === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n        if (typeof prefs !== \"undefined\") {\n            payload[\"prefs\"] = prefs;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n}\nmodule.exports = Teams;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvdGVhbXMuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUFDeEIsTUFBTUMsb0JBQW9CRCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNRSxZQUFZRixtQkFBT0EsQ0FBQztBQUMxQixNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNSSxTQUFTSixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVLLFNBQVMsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUM5QixNQUFNTSxLQUFLTixtQkFBT0EsQ0FBQztBQUVuQixNQUFNTyxjQUFjUjtJQUVmUyxZQUFZTCxNQUFNLENBQ2xCO1FBQ0csS0FBSyxDQUFDQTtJQUNUO0lBR0Q7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU1NLEtBQUtDLE9BQU8sRUFBRUMsTUFBTSxFQUFFO1FBQ3hCLE1BQU1DLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBRWYsSUFBSSxPQUFPSCxZQUFZLGFBQWE7WUFDaENHLE9BQU8sQ0FBQyxVQUFVLEdBQUdIO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxXQUFXLGFBQWE7WUFDL0JFLE9BQU8sQ0FBQyxTQUFTLEdBQUdGO1FBQ3hCO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELE1BQU1FLE9BQU9DLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUU7UUFDOUIsTUFBTU4sVUFBVTtRQUNoQixJQUFJQyxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLFdBQVcsYUFBYTtZQUMvQixNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBT2dCLFNBQVMsYUFBYTtZQUM3QixNQUFNLElBQUloQixrQkFBa0I7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SUFBSUgsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxXQUFXLGFBQWE7WUFDL0IsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFFQSxJQUFJLE9BQU9vQyxVQUFVLGFBQWE7WUFDOUIsTUFBTSxJQUFJcEMsa0JBQWtCO1FBQ2hDO1FBR0EsSUFBSSxPQUFPb0MsVUFBVSxhQUFhO1lBQzlCeEIsT0FBTyxDQUFDLFFBQVEsR0FBR3dCO1FBQ3ZCO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FBQ2xDLE1BQU0sQ0FBQ1csSUFBSSxDQUFDLE9BQU9GLFNBQVM7WUFDMUMsZ0JBQWdCO1FBQ3BCLEdBQUdDO0lBQ1A7QUFDSjtBQUVBeUIsT0FBT0MsT0FBTyxHQUFHaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy90ZWFtcy5qcz9lOWEwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxuY2xhc3MgVGVhbXMgZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHRlYW1zXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgdGVhbXMgaW4gd2hpY2ggdGhlIGN1cnJlbnQgdXNlciBpcyBhIG1lbWJlci4gWW91IGNhblxuICAgICAqIHVzZSB0aGUgcGFyYW1ldGVycyB0byBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRlYW1cbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0ZWFtLiBUaGUgdXNlciB3aG8gY3JlYXRlcyB0aGUgdGVhbSB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICAgKiBhc3NpZ25lZCBhcyB0aGUgb3duZXIgb2YgdGhlIHRlYW0uIE9ubHkgdGhlIHVzZXJzIHdpdGggdGhlIG93bmVyIHJvbGUgY2FuXG4gICAgICogaW52aXRlIG5ldyBtZW1iZXJzLCBhZGQgbmV3IG93bmVycyBhbmQgZGVsZXRlIG9yIHVwZGF0ZSB0aGUgdGVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHJvbGVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHRlYW1JZCwgbmFtZSwgcm9sZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVhbUlkJ10gPSB0ZWFtSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByb2xlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvbGVzJ10gPSByb2xlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRlYW1cbiAgICAgKlxuICAgICAqIEdldCBhIHRlYW0gYnkgaXRzIElELiBBbGwgdGVhbSBtZW1iZXJzIGhhdmUgcmVhZCBhY2Nlc3MgZm9yIHRoaXMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHRlYW1JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfScucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBuYW1lXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHRlYW0ncyBuYW1lIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVOYW1lKHRlYW1JZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfScucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRlYW1cbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHRlYW0gdXNpbmcgaXRzIElELiBPbmx5IHRlYW0gbWVtYmVycyB3aXRoIHRoZSBvd25lciByb2xlIGNhblxuICAgICAqIGRlbGV0ZSB0aGUgdGVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUodGVhbUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCB0ZWFtIG1lbWJlcnNoaXBzXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBsaXN0IGEgdGVhbSdzIG1lbWJlcnMgdXNpbmcgdGhlIHRlYW0ncyBJRC4gQWxsIHRlYW1cbiAgICAgKiBtZW1iZXJzIGhhdmUgcmVhZCBhY2Nlc3MgdG8gdGhpcyBlbmRwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RNZW1iZXJzaGlwcyh0ZWFtSWQsIHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRlYW0gbWVtYmVyc2hpcFxuICAgICAqXG4gICAgICogSW52aXRlIGEgbmV3IG1lbWJlciB0byBqb2luIHlvdXIgdGVhbS4gUHJvdmlkZSBhbiBJRCBmb3IgZXhpc3RpbmcgdXNlcnMsIG9yXG4gICAgICogaW52aXRlIHVucmVnaXN0ZXJlZCB1c2VycyB1c2luZyBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIuIElmIGluaXRpYXRlZCBmcm9tXG4gICAgICogYSBDbGllbnQgU0RLLCBBcHB3cml0ZSB3aWxsIHNlbmQgYW4gZW1haWwgb3Igc21zIHdpdGggYSBsaW5rIHRvIGpvaW4gdGhlXG4gICAgICogdGVhbSB0byB0aGUgaW52aXRlZCB1c2VyLCBhbmQgYW4gYWNjb3VudCB3aWxsIGJlIGNyZWF0ZWQgZm9yIHRoZW0gaWYgb25lXG4gICAgICogZG9lc24ndCBleGlzdC4gSWYgaW5pdGlhdGVkIGZyb20gYSBTZXJ2ZXIgU0RLLCB0aGUgbmV3IG1lbWJlciB3aWxsIGJlIGFkZGVkXG4gICAgICogYXV0b21hdGljYWxseSB0byB0aGUgdGVhbS5cbiAgICAgKiBcbiAgICAgKiBZb3Ugb25seSBuZWVkIHRvIHByb3ZpZGUgb25lIG9mIGEgdXNlciBJRCwgZW1haWwsIG9yIHBob25lIG51bWJlci4gQXBwd3JpdGVcbiAgICAgKiB3aWxsIHByaW9yaXRpemUgYWNjZXB0aW5nIHRoZSB1c2VyIElEID4gZW1haWwgPiBwaG9uZSBudW1iZXIgaWYgeW91IHByb3ZpZGVcbiAgICAgKiBtb3JlIHRoYW4gb25lIG9mIHRoZXNlIHBhcmFtZXRlcnMuXG4gICAgICogXG4gICAgICogVXNlIHRoZSBgdXJsYCBwYXJhbWV0ZXIgdG8gcmVkaXJlY3QgdGhlIHVzZXIgZnJvbSB0aGUgaW52aXRhdGlvbiBlbWFpbCB0b1xuICAgICAqIHlvdXIgYXBwLiBBZnRlciB0aGUgdXNlciBpcyByZWRpcmVjdGVkLCB1c2UgdGhlIFtVcGRhdGUgVGVhbSBNZW1iZXJzaGlwXG4gICAgICogU3RhdHVzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL3RlYW1zI3VwZGF0ZU1lbWJlcnNoaXBTdGF0dXMpXG4gICAgICogZW5kcG9pbnQgdG8gYWxsb3cgdGhlIHVzZXIgdG8gYWNjZXB0IHRoZSBpbnZpdGF0aW9uIHRvIHRoZSB0ZWFtLiBcbiAgICAgKiBcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRvIGF2b2lkIGEgW1JlZGlyZWN0XG4gICAgICogQXR0YWNrXShodHRwczovL2dpdGh1Yi5jb20vT1dBU1AvQ2hlYXRTaGVldFNlcmllcy9ibG9iL21hc3Rlci9jaGVhdHNoZWV0cy9VbnZhbGlkYXRlZF9SZWRpcmVjdHNfYW5kX0ZvcndhcmRzX0NoZWF0X1NoZWV0Lm1kKVxuICAgICAqIEFwcHdyaXRlIHdpbGwgYWNjZXB0IHRoZSBvbmx5IHJlZGlyZWN0IFVSTHMgdW5kZXIgdGhlIGRvbWFpbnMgeW91IGhhdmVcbiAgICAgKiBhZGRlZCBhcyBhIHBsYXRmb3JtIG9uIHRoZSBBcHB3cml0ZSBDb25zb2xlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHJvbGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwaG9uZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZU1lbWJlcnNoaXAodGVhbUlkLCByb2xlcywgZW1haWwsIHVzZXJJZCwgcGhvbmUsIHVybCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvbGVzXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBob25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhvbmUnXSA9IHBob25lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByb2xlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvbGVzJ10gPSByb2xlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGVhbSBtZW1iZXJzaGlwXG4gICAgICpcbiAgICAgKiBHZXQgYSB0ZWFtIG1lbWJlciBieSB0aGUgbWVtYmVyc2hpcCB1bmlxdWUgaWQuIEFsbCB0ZWFtIG1lbWJlcnMgaGF2ZSByZWFkXG4gICAgICogYWNjZXNzIGZvciB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJzaGlwSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRNZW1iZXJzaGlwKHRlYW1JZCwgbWVtYmVyc2hpcElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIG1lbWJlcnNoaXBcbiAgICAgKlxuICAgICAqIE1vZGlmeSB0aGUgcm9sZXMgb2YgYSB0ZWFtIG1lbWJlci4gT25seSB0ZWFtIG1lbWJlcnMgd2l0aCB0aGUgb3duZXIgcm9sZVxuICAgICAqIGhhdmUgYWNjZXNzIHRvIHRoaXMgZW5kcG9pbnQuIExlYXJuIG1vcmUgYWJvdXQgW3JvbGVzIGFuZFxuICAgICAqIHBlcm1pc3Npb25zXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcGVybWlzc2lvbnMpLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJzaGlwSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSByb2xlc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU1lbWJlcnNoaXAodGVhbUlkLCBtZW1iZXJzaGlwSWQsIHJvbGVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByb2xlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm9sZXNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJvbGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm9sZXMnXSA9IHJvbGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRlYW0gbWVtYmVyc2hpcFxuICAgICAqXG4gICAgICogVGhpcyBlbmRwb2ludCBhbGxvd3MgYSB1c2VyIHRvIGxlYXZlIGEgdGVhbSBvciBmb3IgYSB0ZWFtIG93bmVyIHRvIGRlbGV0ZVxuICAgICAqIHRoZSBtZW1iZXJzaGlwIG9mIGFueSBvdGhlciB0ZWFtIG1lbWJlci4gWW91IGNhbiBhbHNvIHVzZSB0aGlzIGVuZHBvaW50IHRvXG4gICAgICogZGVsZXRlIGEgdXNlciBtZW1iZXJzaGlwIGV2ZW4gaWYgaXQgaXMgbm90IGFjY2VwdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJzaGlwSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVNZW1iZXJzaGlwKHRlYW1JZCwgbWVtYmVyc2hpcElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRlYW0gbWVtYmVyc2hpcCBzdGF0dXNcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGFsbG93IGEgdXNlciB0byBhY2NlcHQgYW4gaW52aXRhdGlvbiB0byBqb2luIGEgdGVhbVxuICAgICAqIGFmdGVyIGJlaW5nIHJlZGlyZWN0ZWQgYmFjayB0byB5b3VyIGFwcCBmcm9tIHRoZSBpbnZpdGF0aW9uIGVtYWlsIHJlY2VpdmVkXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICogXG4gICAgICogSWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCwgYSBzZXNzaW9uIGZvciB0aGUgdXNlciBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogY3JlYXRlZC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVtYmVyc2hpcElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNZW1iZXJzaGlwU3RhdHVzKHRlYW1JZCwgbWVtYmVyc2hpcElkLCB1c2VySWQsIHNlY3JldCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcy97bWVtYmVyc2hpcElkfS9zdGF0dXMnLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKS5yZXBsYWNlKCd7bWVtYmVyc2hpcElkfScsIG1lbWJlcnNoaXBJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0ZWFtIHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHRlYW0ncyBzaGFyZWQgcHJlZmVyZW5jZXMgYnkgaXRzIHVuaXF1ZSBJRC4gSWYgYSBwcmVmZXJlbmNlIGRvZXNuJ3RcbiAgICAgKiBuZWVkIHRvIGJlIHNoYXJlZCBieSBhbGwgdGVhbSBtZW1iZXJzLCBwcmVmZXIgc3RvcmluZyB0aGVtIGluIFt1c2VyXG4gICAgICogcHJlZmVyZW5jZXNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNnZXRQcmVmcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJlZnModGVhbUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L3ByZWZzJy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHRlYW0ncyBwcmVmZXJlbmNlcyBieSBpdHMgdW5pcXVlIElELiBUaGUgb2JqZWN0IHlvdSBwYXNzIGlzXG4gICAgICogc3RvcmVkIGFzIGlzIGFuZCByZXBsYWNlcyBhbnkgcHJldmlvdXMgdmFsdWUuIFRoZSBtYXhpbXVtIGFsbG93ZWQgcHJlZnNcbiAgICAgKiBzaXplIGlzIDY0a0IgYW5kIHRocm93cyBhbiBlcnJvciBpZiBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJlZnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQcmVmcyh0ZWFtSWQsIHByZWZzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L3ByZWZzJy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJlZnNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHByZWZzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJlZnMnXSA9IHByZWZzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZWFtcztcbiJdLCJuYW1lcyI6WyJTZXJ2aWNlIiwicmVxdWlyZSIsIkFwcHdyaXRlRXhjZXB0aW9uIiwiSW5wdXRGaWxlIiwiY2xpZW50IiwiU3RyZWFtIiwicHJvbWlzaWZ5IiwiZnMiLCJUZWFtcyIsImNvbnN0cnVjdG9yIiwibGlzdCIsInF1ZXJpZXMiLCJzZWFyY2giLCJhcGlQYXRoIiwicGF5bG9hZCIsImNhbGwiLCJjcmVhdGUiLCJ0ZWFtSWQiLCJuYW1lIiwicm9sZXMiLCJnZXQiLCJyZXBsYWNlIiwidXBkYXRlTmFtZSIsImRlbGV0ZSIsImxpc3RNZW1iZXJzaGlwcyIsImNyZWF0ZU1lbWJlcnNoaXAiLCJlbWFpbCIsInVzZXJJZCIsInBob25lIiwidXJsIiwiZ2V0TWVtYmVyc2hpcCIsIm1lbWJlcnNoaXBJZCIsInVwZGF0ZU1lbWJlcnNoaXAiLCJkZWxldGVNZW1iZXJzaGlwIiwidXBkYXRlTWVtYmVyc2hpcFN0YXR1cyIsInNlY3JldCIsImdldFByZWZzIiwidXBkYXRlUHJlZnMiLCJwcmVmcyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/teams.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/users.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/users.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nclass Users extends Service {\n    constructor(client){\n        super(client);\n    }\n    /**\n     * List users\n     *\n     * Get a list of all the project's users. You can use the query params to\n     * filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async list(queries, search) {\n        const apiPath = \"/users\";\n        let payload = {};\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create user\n     *\n     * Create a new user.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} phone\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async create(userId, email, phone, password, name) {\n        const apiPath = \"/users\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof phone !== \"undefined\") {\n            payload[\"phone\"] = phone;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create user with Argon2 password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createArgon2User(userId, email, password, name) {\n        const apiPath = \"/users/argon2\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create user with bcrypt password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createBcryptUser(userId, email, password, name) {\n        const apiPath = \"/users/bcrypt\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List Identities\n     *\n     * Get identities for all users.\n     *\n     * @param {string} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listIdentities(queries, search) {\n        const apiPath = \"/users/identities\";\n        let payload = {};\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        if (typeof search !== \"undefined\") {\n            payload[\"search\"] = search;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete Identity\n     *\n     * Delete an identity by its unique ID.\n     *\n     * @param {string} identityId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteIdentity(identityId) {\n        const apiPath = \"/users/identities/{identityId}\".replace(\"{identityId}\", identityId);\n        let payload = {};\n        if (typeof identityId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"identityId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create user with MD5 password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createMD5User(userId, email, password, name) {\n        const apiPath = \"/users/md5\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create user with PHPass password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createPHPassUser(userId, email, password, name) {\n        const apiPath = \"/users/phpass\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create user with Scrypt password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} passwordSalt\n     * @param {number} passwordCpu\n     * @param {number} passwordMemory\n     * @param {number} passwordParallel\n     * @param {number} passwordLength\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createScryptUser(userId, email, password, passwordSalt, passwordCpu, passwordMemory, passwordParallel, passwordLength, name) {\n        const apiPath = \"/users/scrypt\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof passwordSalt === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"passwordSalt\"');\n        }\n        if (typeof passwordCpu === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"passwordCpu\"');\n        }\n        if (typeof passwordMemory === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"passwordMemory\"');\n        }\n        if (typeof passwordParallel === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"passwordParallel\"');\n        }\n        if (typeof passwordLength === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"passwordLength\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof passwordSalt !== \"undefined\") {\n            payload[\"passwordSalt\"] = passwordSalt;\n        }\n        if (typeof passwordCpu !== \"undefined\") {\n            payload[\"passwordCpu\"] = passwordCpu;\n        }\n        if (typeof passwordMemory !== \"undefined\") {\n            payload[\"passwordMemory\"] = passwordMemory;\n        }\n        if (typeof passwordParallel !== \"undefined\") {\n            payload[\"passwordParallel\"] = passwordParallel;\n        }\n        if (typeof passwordLength !== \"undefined\") {\n            payload[\"passwordLength\"] = passwordLength;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create user with Scrypt modified password\n     *\n     * Create a new user. Password provided must be hashed with the [Scrypt\n     * Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc)\n     * algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} passwordSalt\n     * @param {string} passwordSaltSeparator\n     * @param {string} passwordSignerKey\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createScryptModifiedUser(userId, email, password, passwordSalt, passwordSaltSeparator, passwordSignerKey, name) {\n        const apiPath = \"/users/scrypt-modified\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof passwordSalt === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"passwordSalt\"');\n        }\n        if (typeof passwordSaltSeparator === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"passwordSaltSeparator\"');\n        }\n        if (typeof passwordSignerKey === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"passwordSignerKey\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof passwordSalt !== \"undefined\") {\n            payload[\"passwordSalt\"] = passwordSalt;\n        }\n        if (typeof passwordSaltSeparator !== \"undefined\") {\n            payload[\"passwordSaltSeparator\"] = passwordSaltSeparator;\n        }\n        if (typeof passwordSignerKey !== \"undefined\") {\n            payload[\"passwordSignerKey\"] = passwordSignerKey;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Create user with SHA password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use\n     * the [POST /users](https://appwrite.io/docs/server/users#usersCreate)\n     * endpoint to create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} passwordVersion\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async createSHAUser(userId, email, password, passwordVersion, name) {\n        const apiPath = \"/users/sha\";\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof userId !== \"undefined\") {\n            payload[\"userId\"] = userId;\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        if (typeof passwordVersion !== \"undefined\") {\n            payload[\"passwordVersion\"] = passwordVersion;\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"post\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get user\n     *\n     * Get a user by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async get(userId) {\n        const apiPath = \"/users/{userId}\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete user\n     *\n     * Delete a user by its unique ID, thereby releasing it's ID. Since ID is\n     * released and can be reused, all user-related resources like documents or\n     * storage files should be deleted before user deletion. If you want to keep\n     * ID reserved, use the\n     * [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus)\n     * endpoint instead.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async delete(userId) {\n        const apiPath = \"/users/{userId}\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update email\n     *\n     * Update the user email by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateEmail(userId, email) {\n        const apiPath = \"/users/{userId}/email\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof email !== \"undefined\") {\n            payload[\"email\"] = email;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update user labels\n     *\n     * Update the user labels by its unique ID. \n     * \n     * Labels can be used to grant access to resources. While teams are a way for\n     * user's to share access to a resource, labels can be defined by the\n     * developer to grant access without an invitation. See the [Permissions\n     * docs](https://appwrite.io/docs/permissions) for more info.\n     *\n     * @param {string} userId\n     * @param {string[]} labels\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateLabels(userId, labels) {\n        const apiPath = \"/users/{userId}/labels\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof labels === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"labels\"');\n        }\n        if (typeof labels !== \"undefined\") {\n            payload[\"labels\"] = labels;\n        }\n        return await this.client.call(\"put\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List user logs\n     *\n     * Get the user activity logs list by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listLogs(userId, queries) {\n        const apiPath = \"/users/{userId}/logs\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof queries !== \"undefined\") {\n            payload[\"queries\"] = queries;\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List user memberships\n     *\n     * Get the user membership list by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listMemberships(userId) {\n        const apiPath = \"/users/{userId}/memberships\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update name\n     *\n     * Update the user name by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateName(userId, name) {\n        const apiPath = \"/users/{userId}/name\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof name === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof name !== \"undefined\") {\n            payload[\"name\"] = name;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update password\n     *\n     * Update the user password by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updatePassword(userId, password) {\n        const apiPath = \"/users/{userId}/password\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof password === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        if (typeof password !== \"undefined\") {\n            payload[\"password\"] = password;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update phone\n     *\n     * Update the user phone by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} number\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updatePhone(userId, number) {\n        const apiPath = \"/users/{userId}/phone\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof number === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"number\"');\n        }\n        if (typeof number !== \"undefined\") {\n            payload[\"number\"] = number;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Get user preferences\n     *\n     * Get the user preferences by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async getPrefs(userId) {\n        const apiPath = \"/users/{userId}/prefs\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update user preferences\n     *\n     * Update the user preferences by its unique ID. The object you pass is stored\n     * as is, and replaces any previous value. The maximum allowed prefs size is\n     * 64kB and throws error if exceeded.\n     *\n     * @param {string} userId\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updatePrefs(userId, prefs) {\n        const apiPath = \"/users/{userId}/prefs\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof prefs === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n        if (typeof prefs !== \"undefined\") {\n            payload[\"prefs\"] = prefs;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * List user sessions\n     *\n     * Get the user sessions list by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async listSessions(userId) {\n        const apiPath = \"/users/{userId}/sessions\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        return await this.client.call(\"get\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete user sessions\n     *\n     * Delete all user's sessions by using the user's unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteSessions(userId) {\n        const apiPath = \"/users/{userId}/sessions\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Delete user session\n     *\n     * Delete a user sessions by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async deleteSession(userId, sessionId) {\n        const apiPath = \"/users/{userId}/sessions/{sessionId}\".replace(\"{userId}\", userId).replace(\"{sessionId}\", sessionId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof sessionId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        return await this.client.call(\"delete\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update user status\n     *\n     * Update the user status by its unique ID. Use this endpoint as an\n     * alternative to deleting a user if you want to keep user's ID reserved.\n     *\n     * @param {string} userId\n     * @param {boolean} status\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateStatus(userId, status) {\n        const apiPath = \"/users/{userId}/status\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof status === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"status\"');\n        }\n        if (typeof status !== \"undefined\") {\n            payload[\"status\"] = status;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update email verification\n     *\n     * Update the user email verification status by its unique ID.\n     *\n     * @param {string} userId\n     * @param {boolean} emailVerification\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updateEmailVerification(userId, emailVerification) {\n        const apiPath = \"/users/{userId}/verification\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof emailVerification === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"emailVerification\"');\n        }\n        if (typeof emailVerification !== \"undefined\") {\n            payload[\"emailVerification\"] = emailVerification;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n    /**\n     * Update phone verification\n     *\n     * Update the user phone verification status by its unique ID.\n     *\n     * @param {string} userId\n     * @param {boolean} phoneVerification\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */ async updatePhoneVerification(userId, phoneVerification) {\n        const apiPath = \"/users/{userId}/verification/phone\".replace(\"{userId}\", userId);\n        let payload = {};\n        if (typeof userId === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof phoneVerification === \"undefined\") {\n            throw new AppwriteException('Missing required parameter: \"phoneVerification\"');\n        }\n        if (typeof phoneVerification !== \"undefined\") {\n            payload[\"phoneVerification\"] = phoneVerification;\n        }\n        return await this.client.call(\"patch\", apiPath, {\n            \"content-type\": \"application/json\"\n        }, payload);\n    }\n}\nmodule.exports = Users;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvdXNlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUFDeEIsTUFBTUMsb0JBQW9CRCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNRSxZQUFZRixtQkFBT0EsQ0FBQztBQUMxQixNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNSSxTQUFTSixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVLLFNBQVMsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUM5QixNQUFNTSxLQUFLTixtQkFBT0EsQ0FBQztBQUVuQixNQUFNTyxjQUFjUjtJQUVmUyxZQUFZTCxNQUFNLENBQ2xCO1FBQ0csS0FBSyxDQUFDQTtJQUNUO0lBR0Q7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU1NLEtBQUtDLE9BQU8sRUFBRUMsTUFBTSxFQUFFO1FBQ3hCLE1BQU1DLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBRWYsSUFBSSxPQUFPSCxZQUFZLGFBQWE7WUFDaENHLE9BQU8sQ0FBQyxVQUFVLEdBQUdIO1FBQ3pCO1FBRUEsSUFBSSxPQUFPQyxXQUFXLGFBQWE7WUFDL0JFLE9BQU8sQ0FBQyxTQUFTLEdBQUdGO1FBQ3hCO1FBRUEsT0FBTyxNQUFNLElBQUksQ0FBQ1IsTUFBTSxDQUFDVyxJQUFJLENBQUMsT0FBT0YsU0FBUztZQUMxQyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELE1BQU1FLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFO1FBQy9DLE1BQU1SLFVBQVU7UUFDaEIsSUFBSUMsVUFBVSxDQUFDO1FBQ2YsSUFBSSxPQUFPRyxXQUFXLGFBQWE7WUFDL0IsTUFBTSxJQUFJZixrQkFBa0I7UUFDaEM7UUFHQSxJQUFJLE9BQU9lLFdBQVcsYUFBYTtZQUMv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Z0Q7UUFDbkM7UUFFQSxPQUFPLE1BQU0sSUFBSSxDQUFDMUQsTUFBTSxDQUFDVyxJQUFJLENBQUMsU0FBU0YsU0FBUztZQUM1QyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtJQUVBOzs7Ozs7Ozs7S0FTQyxHQUNELE1BQU1pRCx3QkFBd0I5QyxNQUFNLEVBQUUrQyxpQkFBaUIsRUFBRTtRQUNyRCxNQUFNbkQsVUFBVSxxQ0FBcUNjLE9BQU8sQ0FBQyxZQUFZVjtRQUN6RSxJQUFJSCxVQUFVLENBQUM7UUFDZixJQUFJLE9BQU9HLFdBQVcsYUFBYTtZQUMvQixNQUFNLElBQUlmLGtCQUFrQjtRQUNoQztRQUVBLElBQUksT0FBTzhELHNCQUFzQixhQUFhO1lBQzFDLE1BQU0sSUFBSTlELGtCQUFrQjtRQUNoQztRQUdBLElBQUksT0FBTzhELHNCQUFzQixhQUFhO1lBQzFDbEQsT0FBTyxDQUFDLG9CQUFvQixHQUFHa0Q7UUFDbkM7UUFFQSxPQUFPLE1BQU0sSUFBSSxDQUFDNUQsTUFBTSxDQUFDVyxJQUFJLENBQUMsU0FBU0YsU0FBUztZQUM1QyxnQkFBZ0I7UUFDcEIsR0FBR0M7SUFDUDtBQUNKO0FBRUFtRCxPQUFPQyxPQUFPLEdBQUcxRCIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2tuZXN0Ly4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL3VzZXJzLmpzPzE1Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5jbGFzcyBVc2VycyBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExpc3QgdXNlcnNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9qZWN0J3MgdXNlcnMuIFlvdSBjYW4gdXNlIHRoZSBxdWVyeSBwYXJhbXMgdG9cbiAgICAgKiBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHVzZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwaG9uZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHVzZXJJZCwgZW1haWwsIHBob25lLCBwYXNzd29yZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaG9uZSddID0gcGhvbmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHVzZXIgd2l0aCBBcmdvbjIgcGFzc3dvcmRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1c2VyLiBQYXNzd29yZCBwcm92aWRlZCBtdXN0IGJlIGhhc2hlZCB3aXRoIHRoZVxuICAgICAqIFtBcmdvbjJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FyZ29uMikgYWxnb3JpdGhtLiBVc2UgdGhlIFtQT1NUXG4gICAgICogL3VzZXJzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL3VzZXJzI3VzZXJzQ3JlYXRlKSBlbmRwb2ludCB0b1xuICAgICAqIGNyZWF0ZSB1c2VycyB3aXRoIGEgcGxhaW4gdGV4dCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFyZ29uMlVzZXIodXNlcklkLCBlbWFpbCwgcGFzc3dvcmQsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMvYXJnb24yJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB1c2VyIHdpdGggYmNyeXB0IHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXNlci4gUGFzc3dvcmQgcHJvdmlkZWQgbXVzdCBiZSBoYXNoZWQgd2l0aCB0aGVcbiAgICAgKiBbQmNyeXB0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CY3J5cHQpIGFsZ29yaXRobS4gVXNlIHRoZSBbUE9TVFxuICAgICAqIC91c2Vyc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci91c2VycyN1c2Vyc0NyZWF0ZSkgZW5kcG9pbnQgdG9cbiAgICAgKiBjcmVhdGUgdXNlcnMgd2l0aCBhIHBsYWluIHRleHQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCY3J5cHRVc2VyKHVzZXJJZCwgZW1haWwsIHBhc3N3b3JkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL2JjcnlwdCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IElkZW50aXRpZXNcbiAgICAgKlxuICAgICAqIEdldCBpZGVudGl0aWVzIGZvciBhbGwgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0SWRlbnRpdGllcyhxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMvaWRlbnRpdGllcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIElkZW50aXR5XG4gICAgICpcbiAgICAgKiBEZWxldGUgYW4gaWRlbnRpdHkgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGl0eUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlSWRlbnRpdHkoaWRlbnRpdHlJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9pZGVudGl0aWVzL3tpZGVudGl0eUlkfScucmVwbGFjZSgne2lkZW50aXR5SWR9JywgaWRlbnRpdHlJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpdHlJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiaWRlbnRpdHlJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdXNlciB3aXRoIE1ENSBwYXNzd29yZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVzZXIuIFBhc3N3b3JkIHByb3ZpZGVkIG11c3QgYmUgaGFzaGVkIHdpdGggdGhlXG4gICAgICogW01ENV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUQ1KSBhbGdvcml0aG0uIFVzZSB0aGUgW1BPU1RcbiAgICAgKiAvdXNlcnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjdXNlcnNDcmVhdGUpIGVuZHBvaW50IHRvXG4gICAgICogY3JlYXRlIHVzZXJzIHdpdGggYSBwbGFpbiB0ZXh0IHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTUQ1VXNlcih1c2VySWQsIGVtYWlsLCBwYXNzd29yZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9tZDUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHVzZXIgd2l0aCBQSFBhc3MgcGFzc3dvcmRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1c2VyLiBQYXNzd29yZCBwcm92aWRlZCBtdXN0IGJlIGhhc2hlZCB3aXRoIHRoZVxuICAgICAqIFtQSFBhc3NdKGh0dHBzOi8vd3d3Lm9wZW53YWxsLmNvbS9waHBhc3MvKSBhbGdvcml0aG0uIFVzZSB0aGUgW1BPU1RcbiAgICAgKiAvdXNlcnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjdXNlcnNDcmVhdGUpIGVuZHBvaW50IHRvXG4gICAgICogY3JlYXRlIHVzZXJzIHdpdGggYSBwbGFpbiB0ZXh0IHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUEhQYXNzVXNlcih1c2VySWQsIGVtYWlsLCBwYXNzd29yZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9waHBhc3MnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHVzZXIgd2l0aCBTY3J5cHQgcGFzc3dvcmRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1c2VyLiBQYXNzd29yZCBwcm92aWRlZCBtdXN0IGJlIGhhc2hlZCB3aXRoIHRoZVxuICAgICAqIFtTY3J5cHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9UYXJzbmFwL3NjcnlwdCkgYWxnb3JpdGhtLiBVc2UgdGhlIFtQT1NUXG4gICAgICogL3VzZXJzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL3VzZXJzI3VzZXJzQ3JlYXRlKSBlbmRwb2ludCB0b1xuICAgICAqIGNyZWF0ZSB1c2VycyB3aXRoIGEgcGxhaW4gdGV4dCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRTYWx0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhc3N3b3JkQ3B1XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhc3N3b3JkTWVtb3J5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhc3N3b3JkUGFyYWxsZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFzc3dvcmRMZW5ndGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNjcnlwdFVzZXIodXNlcklkLCBlbWFpbCwgcGFzc3dvcmQsIHBhc3N3b3JkU2FsdCwgcGFzc3dvcmRDcHUsIHBhc3N3b3JkTWVtb3J5LCBwYXNzd29yZFBhcmFsbGVsLCBwYXNzd29yZExlbmd0aCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9zY3J5cHQnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRTYWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFNhbHRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZENwdSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRDcHVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZE1lbW9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRNZW1vcnlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFBhcmFsbGVsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFBhcmFsbGVsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRMZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkTGVuZ3RoXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFNhbHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZFNhbHQnXSA9IHBhc3N3b3JkU2FsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRDcHUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZENwdSddID0gcGFzc3dvcmRDcHU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkTWVtb3J5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmRNZW1vcnknXSA9IHBhc3N3b3JkTWVtb3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFBhcmFsbGVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmRQYXJhbGxlbCddID0gcGFzc3dvcmRQYXJhbGxlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRMZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZExlbmd0aCddID0gcGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdXNlciB3aXRoIFNjcnlwdCBtb2RpZmllZCBwYXNzd29yZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVzZXIuIFBhc3N3b3JkIHByb3ZpZGVkIG11c3QgYmUgaGFzaGVkIHdpdGggdGhlIFtTY3J5cHRcbiAgICAgKiBNb2RpZmllZF0oaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vTWVsZGlyb24vZWVjZjg0YTAyMjVlY2NiNWEzNzhkNDViYjI3NDYyY2MpXG4gICAgICogYWxnb3JpdGhtLiBVc2UgdGhlIFtQT1NUXG4gICAgICogL3VzZXJzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL3VzZXJzI3VzZXJzQ3JlYXRlKSBlbmRwb2ludCB0b1xuICAgICAqIGNyZWF0ZSB1c2VycyB3aXRoIGEgcGxhaW4gdGV4dCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRTYWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkU2FsdFNlcGFyYXRvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFNpZ25lcktleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU2NyeXB0TW9kaWZpZWRVc2VyKHVzZXJJZCwgZW1haWwsIHBhc3N3b3JkLCBwYXNzd29yZFNhbHQsIHBhc3N3b3JkU2FsdFNlcGFyYXRvciwgcGFzc3dvcmRTaWduZXJLZXksIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMvc2NyeXB0LW1vZGlmaWVkJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkU2FsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRTYWx0XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRTYWx0U2VwYXJhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFNhbHRTZXBhcmF0b3JcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFNpZ25lcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRTaWduZXJLZXlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkU2FsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkU2FsdCddID0gcGFzc3dvcmRTYWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFNhbHRTZXBhcmF0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZFNhbHRTZXBhcmF0b3InXSA9IHBhc3N3b3JkU2FsdFNlcGFyYXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRTaWduZXJLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZFNpZ25lcktleSddID0gcGFzc3dvcmRTaWduZXJLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdXNlciB3aXRoIFNIQSBwYXNzd29yZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVzZXIuIFBhc3N3b3JkIHByb3ZpZGVkIG11c3QgYmUgaGFzaGVkIHdpdGggdGhlXG4gICAgICogW1NIQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VjdXJlX0hhc2hfQWxnb3JpdGhtKSBhbGdvcml0aG0uIFVzZVxuICAgICAqIHRoZSBbUE9TVCAvdXNlcnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjdXNlcnNDcmVhdGUpXG4gICAgICogZW5kcG9pbnQgdG8gY3JlYXRlIHVzZXJzIHdpdGggYSBwbGFpbiB0ZXh0IHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFZlcnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNIQVVzZXIodXNlcklkLCBlbWFpbCwgcGFzc3dvcmQsIHBhc3N3b3JkVmVyc2lvbiwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9zaGEnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFZlcnNpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZFZlcnNpb24nXSA9IHBhc3N3b3JkVmVyc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyXG4gICAgICpcbiAgICAgKiBHZXQgYSB1c2VyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHVzZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfScucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB1c2VyXG4gICAgICpcbiAgICAgKiBEZWxldGUgYSB1c2VyIGJ5IGl0cyB1bmlxdWUgSUQsIHRoZXJlYnkgcmVsZWFzaW5nIGl0J3MgSUQuIFNpbmNlIElEIGlzXG4gICAgICogcmVsZWFzZWQgYW5kIGNhbiBiZSByZXVzZWQsIGFsbCB1c2VyLXJlbGF0ZWQgcmVzb3VyY2VzIGxpa2UgZG9jdW1lbnRzIG9yXG4gICAgICogc3RvcmFnZSBmaWxlcyBzaG91bGQgYmUgZGVsZXRlZCBiZWZvcmUgdXNlciBkZWxldGlvbi4gSWYgeW91IHdhbnQgdG8ga2VlcFxuICAgICAqIElEIHJlc2VydmVkLCB1c2UgdGhlXG4gICAgICogW3VwZGF0ZVN0YXR1c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci91c2VycyN1c2Vyc1VwZGF0ZVN0YXR1cylcbiAgICAgKiBlbmRwb2ludCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZSh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0nLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW1haWxcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgdXNlciBlbWFpbCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUVtYWlsKHVzZXJJZCwgZW1haWwpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vZW1haWwnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdXNlciBsYWJlbHNcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgdXNlciBsYWJlbHMgYnkgaXRzIHVuaXF1ZSBJRC4gXG4gICAgICogXG4gICAgICogTGFiZWxzIGNhbiBiZSB1c2VkIHRvIGdyYW50IGFjY2VzcyB0byByZXNvdXJjZXMuIFdoaWxlIHRlYW1zIGFyZSBhIHdheSBmb3JcbiAgICAgKiB1c2VyJ3MgdG8gc2hhcmUgYWNjZXNzIHRvIGEgcmVzb3VyY2UsIGxhYmVscyBjYW4gYmUgZGVmaW5lZCBieSB0aGVcbiAgICAgKiBkZXZlbG9wZXIgdG8gZ3JhbnQgYWNjZXNzIHdpdGhvdXQgYW4gaW52aXRhdGlvbi4gU2VlIHRoZSBbUGVybWlzc2lvbnNcbiAgICAgKiBkb2NzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcGVybWlzc2lvbnMpIGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGFiZWxzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTGFiZWxzKHVzZXJJZCwgbGFiZWxzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L2xhYmVscycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJsYWJlbHNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGxhYmVscyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2xhYmVscyddID0gbGFiZWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgdXNlciBsb2dzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHVzZXIgYWN0aXZpdHkgbG9ncyBsaXN0IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RMb2dzKHVzZXJJZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9sb2dzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgdXNlciBtZW1iZXJzaGlwc1xuICAgICAqXG4gICAgICogR2V0IHRoZSB1c2VyIG1lbWJlcnNoaXAgbGlzdCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RNZW1iZXJzaGlwcyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vbWVtYmVyc2hpcHMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbmFtZVxuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIG5hbWUgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU5hbWUodXNlcklkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L25hbWUnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHVzZXIgcGFzc3dvcmQgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQYXNzd29yZCh1c2VySWQsIHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3Bhc3N3b3JkJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBob25lXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHVzZXIgcGhvbmUgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtYmVyXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUGhvbmUodXNlcklkLCBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vcGhvbmUnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibnVtYmVyXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydudW1iZXInXSA9IG51bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHVzZXIgcHJlZmVyZW5jZXMgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcmVmcyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vcHJlZnMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdXNlciBwcmVmZXJlbmNlc1xuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIHByZWZlcmVuY2VzIGJ5IGl0cyB1bmlxdWUgSUQuIFRoZSBvYmplY3QgeW91IHBhc3MgaXMgc3RvcmVkXG4gICAgICogYXMgaXMsIGFuZCByZXBsYWNlcyBhbnkgcHJldmlvdXMgdmFsdWUuIFRoZSBtYXhpbXVtIGFsbG93ZWQgcHJlZnMgc2l6ZSBpc1xuICAgICAqIDY0a0IgYW5kIHRocm93cyBlcnJvciBpZiBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJlZnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQcmVmcyh1c2VySWQsIHByZWZzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3ByZWZzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJlZnNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHByZWZzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJlZnMnXSA9IHByZWZzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCB1c2VyIHNlc3Npb25zXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHVzZXIgc2Vzc2lvbnMgbGlzdCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RTZXNzaW9ucyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vc2Vzc2lvbnMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdXNlciBzZXNzaW9uc1xuICAgICAqXG4gICAgICogRGVsZXRlIGFsbCB1c2VyJ3Mgc2Vzc2lvbnMgYnkgdXNpbmcgdGhlIHVzZXIncyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlU2Vzc2lvbnModXNlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3Nlc3Npb25zJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHVzZXIgc2Vzc2lvblxuICAgICAqXG4gICAgICogRGVsZXRlIGEgdXNlciBzZXNzaW9ucyBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVTZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3Nlc3Npb25zL3tzZXNzaW9uSWR9Jy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCkucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZXNzaW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHVzZXIgc3RhdHVzXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHVzZXIgc3RhdHVzIGJ5IGl0cyB1bmlxdWUgSUQuIFVzZSB0aGlzIGVuZHBvaW50IGFzIGFuXG4gICAgICogYWx0ZXJuYXRpdmUgdG8gZGVsZXRpbmcgYSB1c2VyIGlmIHlvdSB3YW50IHRvIGtlZXAgdXNlcidzIElEIHJlc2VydmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdHVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU3RhdHVzKHVzZXJJZCwgc3RhdHVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3N0YXR1cycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzdGF0dXNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3N0YXR1cyddID0gc3RhdHVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGVtYWlsIHZlcmlmaWNhdGlvblxuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIGVtYWlsIHZlcmlmaWNhdGlvbiBzdGF0dXMgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVtYWlsVmVyaWZpY2F0aW9uXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRW1haWxWZXJpZmljYXRpb24odXNlcklkLCBlbWFpbFZlcmlmaWNhdGlvbikge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS92ZXJpZmljYXRpb24nLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsVmVyaWZpY2F0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFZlcmlmaWNhdGlvblwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWxWZXJpZmljYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbFZlcmlmaWNhdGlvbiddID0gZW1haWxWZXJpZmljYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcGhvbmUgdmVyaWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHVzZXIgcGhvbmUgdmVyaWZpY2F0aW9uIHN0YXR1cyBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGhvbmVWZXJpZmljYXRpb25cbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQaG9uZVZlcmlmaWNhdGlvbih1c2VySWQsIHBob25lVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3ZlcmlmaWNhdGlvbi9waG9uZScucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmVWZXJpZmljYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBob25lVmVyaWZpY2F0aW9uXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZVZlcmlmaWNhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bob25lVmVyaWZpY2F0aW9uJ10gPSBwaG9uZVZlcmlmaWNhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVc2VycztcbiJdLCJuYW1lcyI6WyJTZXJ2aWNlIiwicmVxdWlyZSIsIkFwcHdyaXRlRXhjZXB0aW9uIiwiSW5wdXRGaWxlIiwiY2xpZW50IiwiU3RyZWFtIiwicHJvbWlzaWZ5IiwiZnMiLCJVc2VycyIsImNvbnN0cnVjdG9yIiwibGlzdCIsInF1ZXJpZXMiLCJzZWFyY2giLCJhcGlQYXRoIiwicGF5bG9hZCIsImNhbGwiLCJjcmVhdGUiLCJ1c2VySWQiLCJlbWFpbCIsInBob25lIiwicGFzc3dvcmQiLCJuYW1lIiwiY3JlYXRlQXJnb24yVXNlciIsImNyZWF0ZUJjcnlwdFVzZXIiLCJsaXN0SWRlbnRpdGllcyIsImRlbGV0ZUlkZW50aXR5IiwiaWRlbnRpdHlJZCIsInJlcGxhY2UiLCJjcmVhdGVNRDVVc2VyIiwiY3JlYXRlUEhQYXNzVXNlciIsImNyZWF0ZVNjcnlwdFVzZXIiLCJwYXNzd29yZFNhbHQiLCJwYXNzd29yZENwdSIsInBhc3N3b3JkTWVtb3J5IiwicGFzc3dvcmRQYXJhbGxlbCIsInBhc3N3b3JkTGVuZ3RoIiwiY3JlYXRlU2NyeXB0TW9kaWZpZWRVc2VyIiwicGFzc3dvcmRTYWx0U2VwYXJhdG9yIiwicGFzc3dvcmRTaWduZXJLZXkiLCJjcmVhdGVTSEFVc2VyIiwicGFzc3dvcmRWZXJzaW9uIiwiZ2V0IiwiZGVsZXRlIiwidXBkYXRlRW1haWwiLCJ1cGRhdGVMYWJlbHMiLCJsYWJlbHMiLCJsaXN0TG9ncyIsImxpc3RNZW1iZXJzaGlwcyIsInVwZGF0ZU5hbWUiLCJ1cGRhdGVQYXNzd29yZCIsInVwZGF0ZVBob25lIiwibnVtYmVyIiwiZ2V0UHJlZnMiLCJ1cGRhdGVQcmVmcyIsInByZWZzIiwibGlzdFNlc3Npb25zIiwiZGVsZXRlU2Vzc2lvbnMiLCJkZWxldGVTZXNzaW9uIiwic2Vzc2lvbklkIiwidXBkYXRlU3RhdHVzIiwic3RhdHVzIiwidXBkYXRlRW1haWxWZXJpZmljYXRpb24iLCJlbWFpbFZlcmlmaWNhdGlvbiIsInVwZGF0ZVBob25lVmVyaWZpY2F0aW9uIiwicGhvbmVWZXJpZmljYXRpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/users.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/node_modules/form-data/lib/form_data.js":
/*!****************************************************************************!*\
  !*** ./node_modules/node-appwrite/node_modules/form-data/lib/form_data.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var CombinedStream = __webpack_require__(/*! combined-stream */ \"(rsc)/./node_modules/combined-stream/lib/combined_stream.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar parseUrl = (__webpack_require__(/*! url */ \"url\").parse);\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\nvar mime = __webpack_require__(/*! mime-types */ \"(rsc)/./node_modules/mime-types/index.js\");\nvar asynckit = __webpack_require__(/*! asynckit */ \"(rsc)/./node_modules/asynckit/index.js\");\nvar populate = __webpack_require__(/*! ./populate.js */ \"(rsc)/./node_modules/node-appwrite/node_modules/form-data/lib/populate.js\");\n// Public API\nmodule.exports = FormData;\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\n */ function FormData(options) {\n    if (!(this instanceof FormData)) {\n        return new FormData(options);\n    }\n    this._overheadLength = 0;\n    this._valueLength = 0;\n    this._valuesToMeasure = [];\n    CombinedStream.call(this);\n    options = options || {};\n    for(var option in options){\n        this[option] = options[option];\n    }\n}\nFormData.LINE_BREAK = \"\\r\\n\";\nFormData.DEFAULT_CONTENT_TYPE = \"application/octet-stream\";\nFormData.prototype.append = function(field, value, options) {\n    options = options || {};\n    // allow filename as single option\n    if (typeof options == \"string\") {\n        options = {\n            filename: options\n        };\n    }\n    var append = CombinedStream.prototype.append.bind(this);\n    // all that streamy business can't handle numbers\n    if (typeof value == \"number\") {\n        value = \"\" + value;\n    }\n    // https://github.com/felixge/node-form-data/issues/38\n    if (util.isArray(value)) {\n        // Please convert your array into string\n        // the way web server expects it\n        this._error(new Error(\"Arrays are not supported.\"));\n        return;\n    }\n    var header = this._multiPartHeader(field, value, options);\n    var footer = this._multiPartFooter();\n    append(header);\n    append(value);\n    append(footer);\n    // pass along options.knownLength\n    this._trackLength(header, value, options);\n};\nFormData.prototype._trackLength = function(header, value, options) {\n    var valueLength = 0;\n    // used w/ getLengthSync(), when length is known.\n    // e.g. for streaming directly from a remote server,\n    // w/ a known file a size, and not wanting to wait for\n    // incoming file to finish to get its size.\n    if (options.knownLength != null) {\n        valueLength += +options.knownLength;\n    } else if (Buffer.isBuffer(value)) {\n        valueLength = value.length;\n    } else if (typeof value === \"string\") {\n        valueLength = Buffer.byteLength(value);\n    }\n    this._valueLength += valueLength;\n    // @check why add CRLF? does this account for custom/multiple CRLFs?\n    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;\n    // empty or either doesn't have path or not an http response or not a stream\n    if (!value || !value.path && !(value.readable && value.hasOwnProperty(\"httpVersion\")) && !(value instanceof Stream)) {\n        return;\n    }\n    // no need to bother with the length\n    if (!options.knownLength) {\n        this._valuesToMeasure.push(value);\n    }\n};\nFormData.prototype._lengthRetriever = function(value, callback) {\n    if (value.hasOwnProperty(\"fd\")) {\n        // take read range into a account\n        // `end` = Infinity > read file till the end\n        //\n        // TODO: Looks like there is bug in Node fs.createReadStream\n        // it doesn't respect `end` options without `start` options\n        // Fix it when node fixes it.\n        // https://github.com/joyent/node/issues/7819\n        if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n            // when end specified\n            // no need to calculate range\n            // inclusive, starts with 0\n            callback(null, value.end + 1 - (value.start ? value.start : 0));\n        // not that fast snoopy\n        } else {\n            // still need to fetch file size from fs\n            fs.stat(value.path, function(err, stat) {\n                var fileSize;\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                // update final size based on the range options\n                fileSize = stat.size - (value.start ? value.start : 0);\n                callback(null, fileSize);\n            });\n        }\n    // or http response\n    } else if (value.hasOwnProperty(\"httpVersion\")) {\n        callback(null, +value.headers[\"content-length\"]);\n    // or request stream http://github.com/mikeal/request\n    } else if (value.hasOwnProperty(\"httpModule\")) {\n        // wait till response come back\n        value.on(\"response\", function(response) {\n            value.pause();\n            callback(null, +response.headers[\"content-length\"]);\n        });\n        value.resume();\n    // something else\n    } else {\n        callback(\"Unknown stream\");\n    }\n};\nFormData.prototype._multiPartHeader = function(field, value, options) {\n    // custom header specified (as string)?\n    // it becomes responsible for boundary\n    // (e.g. to handle extra CRLFs on .NET servers)\n    if (typeof options.header == \"string\") {\n        return options.header;\n    }\n    var contentDisposition = this._getContentDisposition(value, options);\n    var contentType = this._getContentType(value, options);\n    var contents = \"\";\n    var headers = {\n        // add custom disposition as third element or keep it two elements if not\n        \"Content-Disposition\": [\n            \"form-data\",\n            'name=\"' + field + '\"'\n        ].concat(contentDisposition || []),\n        // if no content type. allow it to be empty array\n        \"Content-Type\": [].concat(contentType || [])\n    };\n    // allow custom headers.\n    if (typeof options.header == \"object\") {\n        populate(headers, options.header);\n    }\n    var header;\n    for(var prop in headers){\n        if (!headers.hasOwnProperty(prop)) continue;\n        header = headers[prop];\n        // skip nullish headers.\n        if (header == null) {\n            continue;\n        }\n        // convert all headers to arrays.\n        if (!Array.isArray(header)) {\n            header = [\n                header\n            ];\n        }\n        // add non-empty headers.\n        if (header.length) {\n            contents += prop + \": \" + header.join(\"; \") + FormData.LINE_BREAK;\n        }\n    }\n    return \"--\" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\nFormData.prototype._getContentDisposition = function(value, options) {\n    var filename, contentDisposition;\n    if (typeof options.filepath === \"string\") {\n        // custom filepath for relative paths\n        filename = path.normalize(options.filepath).replace(/\\\\/g, \"/\");\n    } else if (options.filename || value.name || value.path) {\n        // custom filename take precedence\n        // formidable and the browser add a name property\n        // fs- and request- streams have path property\n        filename = path.basename(options.filename || value.name || value.path);\n    } else if (value.readable && value.hasOwnProperty(\"httpVersion\")) {\n        // or try http response\n        filename = path.basename(value.client._httpMessage.path || \"\");\n    }\n    if (filename) {\n        contentDisposition = 'filename=\"' + filename + '\"';\n    }\n    return contentDisposition;\n};\nFormData.prototype._getContentType = function(value, options) {\n    // use custom content-type above all\n    var contentType = options.contentType;\n    // or try `name` from formidable, browser\n    if (!contentType && value.name) {\n        contentType = mime.lookup(value.name);\n    }\n    // or try `path` from fs-, request- streams\n    if (!contentType && value.path) {\n        contentType = mime.lookup(value.path);\n    }\n    // or if it's http-reponse\n    if (!contentType && value.readable && value.hasOwnProperty(\"httpVersion\")) {\n        contentType = value.headers[\"content-type\"];\n    }\n    // or guess it from the filepath or filename\n    if (!contentType && (options.filepath || options.filename)) {\n        contentType = mime.lookup(options.filepath || options.filename);\n    }\n    // fallback to the default content type if `value` is not simple value\n    if (!contentType && typeof value == \"object\") {\n        contentType = FormData.DEFAULT_CONTENT_TYPE;\n    }\n    return contentType;\n};\nFormData.prototype._multiPartFooter = function() {\n    return (function(next) {\n        var footer = FormData.LINE_BREAK;\n        var lastPart = this._streams.length === 0;\n        if (lastPart) {\n            footer += this._lastBoundary();\n        }\n        next(footer);\n    }).bind(this);\n};\nFormData.prototype._lastBoundary = function() {\n    return \"--\" + this.getBoundary() + \"--\" + FormData.LINE_BREAK;\n};\nFormData.prototype.getHeaders = function(userHeaders) {\n    var header;\n    var formHeaders = {\n        \"content-type\": \"multipart/form-data; boundary=\" + this.getBoundary()\n    };\n    for(header in userHeaders){\n        if (userHeaders.hasOwnProperty(header)) {\n            formHeaders[header.toLowerCase()] = userHeaders[header];\n        }\n    }\n    return formHeaders;\n};\nFormData.prototype.setBoundary = function(boundary) {\n    this._boundary = boundary;\n};\nFormData.prototype.getBoundary = function() {\n    if (!this._boundary) {\n        this._generateBoundary();\n    }\n    return this._boundary;\n};\nFormData.prototype.getBuffer = function() {\n    var dataBuffer = new Buffer.alloc(0);\n    var boundary = this.getBoundary();\n    // Create the form content. Add Line breaks to the end of data.\n    for(var i = 0, len = this._streams.length; i < len; i++){\n        if (typeof this._streams[i] !== \"function\") {\n            // Add content to the buffer.\n            if (Buffer.isBuffer(this._streams[i])) {\n                dataBuffer = Buffer.concat([\n                    dataBuffer,\n                    this._streams[i]\n                ]);\n            } else {\n                dataBuffer = Buffer.concat([\n                    dataBuffer,\n                    Buffer.from(this._streams[i])\n                ]);\n            }\n            // Add break after content.\n            if (typeof this._streams[i] !== \"string\" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {\n                dataBuffer = Buffer.concat([\n                    dataBuffer,\n                    Buffer.from(FormData.LINE_BREAK)\n                ]);\n            }\n        }\n    }\n    // Add the footer and return the Buffer object.\n    return Buffer.concat([\n        dataBuffer,\n        Buffer.from(this._lastBoundary())\n    ]);\n};\nFormData.prototype._generateBoundary = function() {\n    // This generates a 50 character boundary similar to those used by Firefox.\n    // They are optimized for boyer-moore parsing.\n    var boundary = \"--------------------------\";\n    for(var i = 0; i < 24; i++){\n        boundary += Math.floor(Math.random() * 10).toString(16);\n    }\n    this._boundary = boundary;\n};\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function() {\n    var knownLength = this._overheadLength + this._valueLength;\n    // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n    // so it basically checks if there is any value added to the form\n    if (this._streams.length) {\n        knownLength += this._lastBoundary().length;\n    }\n    // https://github.com/form-data/form-data/issues/40\n    if (!this.hasKnownLength()) {\n        // Some async length retrievers are present\n        // therefore synchronous length calculation is false.\n        // Please use getLength(callback) to get proper length\n        this._error(new Error(\"Cannot calculate proper length in synchronous way.\"));\n    }\n    return knownLength;\n};\n// Public API to check if length of added values is known\n// https://github.com/form-data/form-data/issues/196\n// https://github.com/form-data/form-data/issues/262\nFormData.prototype.hasKnownLength = function() {\n    var hasKnownLength = true;\n    if (this._valuesToMeasure.length) {\n        hasKnownLength = false;\n    }\n    return hasKnownLength;\n};\nFormData.prototype.getLength = function(cb) {\n    var knownLength = this._overheadLength + this._valueLength;\n    if (this._streams.length) {\n        knownLength += this._lastBoundary().length;\n    }\n    if (!this._valuesToMeasure.length) {\n        process.nextTick(cb.bind(this, null, knownLength));\n        return;\n    }\n    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\n        if (err) {\n            cb(err);\n            return;\n        }\n        values.forEach(function(length) {\n            knownLength += length;\n        });\n        cb(null, knownLength);\n    });\n};\nFormData.prototype.submit = function(params, cb) {\n    var request, options, defaults = {\n        method: \"post\"\n    };\n    // parse provided url if it's string\n    // or treat it as options object\n    if (typeof params == \"string\") {\n        params = parseUrl(params);\n        options = populate({\n            port: params.port,\n            path: params.pathname,\n            host: params.hostname,\n            protocol: params.protocol\n        }, defaults);\n    // use custom params\n    } else {\n        options = populate(params, defaults);\n        // if no port provided use default one\n        if (!options.port) {\n            options.port = options.protocol == \"https:\" ? 443 : 80;\n        }\n    }\n    // put that good code in getHeaders to some use\n    options.headers = this.getHeaders(params.headers);\n    // https if specified, fallback to http in any other case\n    if (options.protocol == \"https:\") {\n        request = https.request(options);\n    } else {\n        request = http.request(options);\n    }\n    // get content length and fire away\n    this.getLength((function(err, length) {\n        if (err && err !== \"Unknown stream\") {\n            this._error(err);\n            return;\n        }\n        // add content length\n        if (length) {\n            request.setHeader(\"Content-Length\", length);\n        }\n        this.pipe(request);\n        if (cb) {\n            var onResponse;\n            var callback = function(error, responce) {\n                request.removeListener(\"error\", callback);\n                request.removeListener(\"response\", onResponse);\n                return cb.call(this, error, responce);\n            };\n            onResponse = callback.bind(this, null);\n            request.on(\"error\", callback);\n            request.on(\"response\", onResponse);\n        }\n    }).bind(this));\n    return request;\n};\nFormData.prototype._error = function(err) {\n    if (!this.error) {\n        this.error = err;\n        this.pause();\n        this.emit(\"error\", err);\n    }\n};\nFormData.prototype.toString = function() {\n    return \"[object FormData]\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsaUJBQWlCQyxtQkFBT0EsQ0FBQztBQUM3QixJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNuQixJQUFJRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxXQUFXTCw2Q0FBb0I7QUFDbkMsSUFBSU8sS0FBS1AsbUJBQU9BLENBQUM7QUFDakIsSUFBSVEsU0FBU1Isb0RBQXdCO0FBQ3JDLElBQUlTLE9BQU9ULG1CQUFPQSxDQUFDO0FBQ25CLElBQUlVLFdBQVdWLG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlXLFdBQVdYLG1CQUFPQSxDQUFDO0FBRXZCLGFBQWE7QUFDYlksT0FBT0MsT0FBTyxHQUFHQztBQUVqQixtQkFBbUI7QUFDbkJiLEtBQUtjLFFBQVEsQ0FBQ0QsVUFBVWY7QUFFeEI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNlLFNBQVNFLE9BQU87SUFDdkIsSUFBSSxDQUFFLEtBQUksWUFBWUYsUUFBTyxHQUFJO1FBQy9CLE9BQU8sSUFBSUEsU0FBU0U7SUFDdEI7SUFFQSxJQUFJLENBQUNDLGVBQWUsR0FBRztJQUN2QixJQUFJLENBQUNDLFlBQVksR0FBRztJQUNwQixJQUFJLENBQUNDLGdCQUFnQixHQUFHLEVBQUU7SUFFMUJwQixlQUFlcUIsSUFBSSxDQUFDLElBQUk7SUFFeEJKLFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFLLElBQUlLLFVBQVVMLFFBQVM7UUFDMUIsSUFBSSxDQUFDSyxPQUFPLEdBQUdMLE9BQU8sQ0FBQ0ssT0FBTztJQUNoQztBQUNGO0FBRUFQLFNBQVNRLFVBQVUsR0FBRztBQUN0QlIsU0FBU1Msb0JBQW9CLEdBQUc7QUFFaENULFNBQVNVLFNBQVMs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QVMxRTtJQUNyQjtBQUNGO0FBRUF4QyxTQUFTVSxTQUFTLENBQUM4RSxRQUFRLEdBQUc7SUFDNUIsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja25lc3QvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanM/MjI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tYmluZWRTdHJlYW0gPSByZXF1aXJlKCdjb21iaW5lZC1zdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgcGFyc2VVcmwgPSByZXF1aXJlKCd1cmwnKS5wYXJzZTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJyk7XG52YXIgYXN5bmNraXQgPSByZXF1aXJlKCdhc3luY2tpdCcpO1xudmFyIHBvcHVsYXRlID0gcmVxdWlyZSgnLi9wb3B1bGF0ZS5qcycpO1xuXG4vLyBQdWJsaWMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1EYXRhO1xuXG4vLyBtYWtlIGl0IGEgU3RyZWFtXG51dGlsLmluaGVyaXRzKEZvcm1EYXRhLCBDb21iaW5lZFN0cmVhbSk7XG5cbi8qKlxuICogQ3JlYXRlIHJlYWRhYmxlIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHN0cmVhbXMuXG4gKiBDYW4gYmUgdXNlZCB0byBzdWJtaXQgZm9ybXNcbiAqIGFuZCBmaWxlIHVwbG9hZHMgdG8gb3RoZXIgd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvcGVydGllcyB0byBiZSBhZGRlZC9vdmVycmlkZW4gZm9yIEZvcm1EYXRhIGFuZCBDb21iaW5lZFN0cmVhbVxuICovXG5mdW5jdGlvbiBGb3JtRGF0YShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1EYXRhKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggPSAwO1xuICB0aGlzLl92YWx1ZUxlbmd0aCA9IDA7XG4gIHRoaXMuX3ZhbHVlc1RvTWVhc3VyZSA9IFtdO1xuXG4gIENvbWJpbmVkU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgdGhpc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICB9XG59XG5cbkZvcm1EYXRhLkxJTkVfQlJFQUsgPSAnXFxyXFxuJztcbkZvcm1EYXRhLkRFRkFVTFRfQ09OVEVOVF9UWVBFID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBhbGxvdyBmaWxlbmFtZSBhcyBzaW5nbGUgb3B0aW9uXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7ZmlsZW5hbWU6IG9wdGlvbnN9O1xuICB9XG5cbiAgdmFyIGFwcGVuZCA9IENvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5hcHBlbmQuYmluZCh0aGlzKTtcblxuICAvLyBhbGwgdGhhdCBzdHJlYW15IGJ1c2luZXNzIGNhbid0IGhhbmRsZSBudW1iZXJzXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICB2YWx1ZSA9ICcnICsgdmFsdWU7XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmVsaXhnZS9ub2RlLWZvcm0tZGF0YS9pc3N1ZXMvMzhcbiAgaWYgKHV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBQbGVhc2UgY29udmVydCB5b3VyIGFycmF5IGludG8gc3RyaW5nXG4gICAgLy8gdGhlIHdheSB3ZWIgc2VydmVyIGV4cGVjdHMgaXRcbiAgICB0aGlzLl9lcnJvcihuZXcgRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZC4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhlYWRlciA9IHRoaXMuX211bHRpUGFydEhlYWRlcihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpO1xuICB2YXIgZm9vdGVyID0gdGhpcy5fbXVsdGlQYXJ0Rm9vdGVyKCk7XG5cbiAgYXBwZW5kKGhlYWRlcik7XG4gIGFwcGVuZCh2YWx1ZSk7XG4gIGFwcGVuZChmb290ZXIpO1xuXG4gIC8vIHBhc3MgYWxvbmcgb3B0aW9ucy5rbm93bkxlbmd0aFxuICB0aGlzLl90cmFja0xlbmd0aChoZWFkZXIsIHZhbHVlLCBvcHRpb25zKTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fdHJhY2tMZW5ndGggPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB2YWx1ZUxlbmd0aCA9IDA7XG5cbiAgLy8gdXNlZCB3LyBnZXRMZW5ndGhTeW5jKCksIHdoZW4gbGVuZ3RoIGlzIGtub3duLlxuICAvLyBlLmcuIGZvciBzdHJlYW1pbmcgZGlyZWN0bHkgZnJvbSBhIHJlbW90ZSBzZXJ2ZXIsXG4gIC8vIHcvIGEga25vd24gZmlsZSBhIHNpemUsIGFuZCBub3Qgd2FudGluZyB0byB3YWl0IGZvclxuICAvLyBpbmNvbWluZyBmaWxlIHRvIGZpbmlzaCB0byBnZXQgaXRzIHNpemUuXG4gIGlmIChvcHRpb25zLmtub3duTGVuZ3RoICE9IG51bGwpIHtcbiAgICB2YWx1ZUxlbmd0aCArPSArb3B0aW9ucy5rbm93bkxlbmd0aDtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICB9XG5cbiAgdGhpcy5fdmFsdWVMZW5ndGggKz0gdmFsdWVMZW5ndGg7XG5cbiAgLy8gQGNoZWNrIHdoeSBhZGQgQ1JMRj8gZG9lcyB0aGlzIGFjY291bnQgZm9yIGN1c3RvbS9tdWx0aXBsZSBDUkxGcz9cbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggKz1cbiAgICBCdWZmZXIuYnl0ZUxlbmd0aChoZWFkZXIpICtcbiAgICBGb3JtRGF0YS5MSU5FX0JSRUFLLmxlbmd0aDtcblxuICAvLyBlbXB0eSBvciBlaXRoZXIgZG9lc24ndCBoYXZlIHBhdGggb3Igbm90IGFuIGh0dHAgcmVzcG9uc2Ugb3Igbm90IGEgc3RyZWFtXG4gIGlmICghdmFsdWUgfHwgKCAhdmFsdWUucGF0aCAmJiAhKHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgU3RyZWFtKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBubyBuZWVkIHRvIGJvdGhlciB3aXRoIHRoZSBsZW5ndGhcbiAgaWYgKCFvcHRpb25zLmtub3duTGVuZ3RoKSB7XG4gICAgdGhpcy5fdmFsdWVzVG9NZWFzdXJlLnB1c2godmFsdWUpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2xlbmd0aFJldHJpZXZlciA9IGZ1bmN0aW9uKHZhbHVlLCBjYWxsYmFjaykge1xuXG4gIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZmQnKSkge1xuXG4gICAgLy8gdGFrZSByZWFkIHJhbmdlIGludG8gYSBhY2NvdW50XG4gICAgLy8gYGVuZGAgPSBJbmZpbml0eSDigJM+IHJlYWQgZmlsZSB0aWxsIHRoZSBlbmRcbiAgICAvL1xuICAgIC8vIFRPRE86IExvb2tzIGxpa2UgdGhlcmUgaXMgYnVnIGluIE5vZGUgZnMuY3JlYXRlUmVhZFN0cmVhbVxuICAgIC8vIGl0IGRvZXNuJ3QgcmVzcGVjdCBgZW5kYCBvcHRpb25zIHdpdGhvdXQgYHN0YXJ0YCBvcHRpb25zXG4gICAgLy8gRml4IGl0IHdoZW4gbm9kZSBmaXhlcyBpdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzc4MTlcbiAgICBpZiAodmFsdWUuZW5kICE9IHVuZGVmaW5lZCAmJiB2YWx1ZS5lbmQgIT0gSW5maW5pdHkgJiYgdmFsdWUuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIC8vIHdoZW4gZW5kIHNwZWNpZmllZFxuICAgICAgLy8gbm8gbmVlZCB0byBjYWxjdWxhdGUgcmFuZ2VcbiAgICAgIC8vIGluY2x1c2l2ZSwgc3RhcnRzIHdpdGggMFxuICAgICAgY2FsbGJhY2sobnVsbCwgdmFsdWUuZW5kICsgMSAtICh2YWx1ZS5zdGFydCA/IHZhbHVlLnN0YXJ0IDogMCkpO1xuXG4gICAgLy8gbm90IHRoYXQgZmFzdCBzbm9vcHlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RpbGwgbmVlZCB0byBmZXRjaCBmaWxlIHNpemUgZnJvbSBmc1xuICAgICAgZnMuc3RhdCh2YWx1ZS5wYXRoLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcblxuICAgICAgICB2YXIgZmlsZVNpemU7XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGZpbmFsIHNpemUgYmFzZWQgb24gdGhlIHJhbmdlIG9wdGlvbnNcbiAgICAgICAgZmlsZVNpemUgPSBzdGF0LnNpemUgLSAodmFsdWUuc3RhcnQgPyB2YWx1ZS5zdGFydCA6IDApO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBmaWxlU2l6ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgLy8gb3IgaHR0cCByZXNwb25zZVxuICB9IGVsc2UgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgK3ZhbHVlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuXG4gIC8vIG9yIHJlcXVlc3Qgc3RyZWFtIGh0dHA6Ly9naXRodWIuY29tL21pa2VhbC9yZXF1ZXN0XG4gIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBNb2R1bGUnKSkge1xuICAgIC8vIHdhaXQgdGlsbCByZXNwb25zZSBjb21lIGJhY2tcbiAgICB2YWx1ZS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFsdWUucGF1c2UoKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsICtyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcbiAgICB9KTtcbiAgICB2YWx1ZS5yZXN1bWUoKTtcblxuICAvLyBzb21ldGhpbmcgZWxzZVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCdVbmtub3duIHN0cmVhbScpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX211bHRpUGFydEhlYWRlciA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAvLyBjdXN0b20gaGVhZGVyIHNwZWNpZmllZCAoYXMgc3RyaW5nKT9cbiAgLy8gaXQgYmVjb21lcyByZXNwb25zaWJsZSBmb3IgYm91bmRhcnlcbiAgLy8gKGUuZy4gdG8gaGFuZGxlIGV4dHJhIENSTEZzIG9uIC5ORVQgc2VydmVycylcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlciA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvcHRpb25zLmhlYWRlcjtcbiAgfVxuXG4gIHZhciBjb250ZW50RGlzcG9zaXRpb24gPSB0aGlzLl9nZXRDb250ZW50RGlzcG9zaXRpb24odmFsdWUsIG9wdGlvbnMpO1xuICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9nZXRDb250ZW50VHlwZSh2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgdmFyIGNvbnRlbnRzID0gJyc7XG4gIHZhciBoZWFkZXJzICA9IHtcbiAgICAvLyBhZGQgY3VzdG9tIGRpc3Bvc2l0aW9uIGFzIHRoaXJkIGVsZW1lbnQgb3Iga2VlcCBpdCB0d28gZWxlbWVudHMgaWYgbm90XG4gICAgJ0NvbnRlbnQtRGlzcG9zaXRpb24nOiBbJ2Zvcm0tZGF0YScsICduYW1lPVwiJyArIGZpZWxkICsgJ1wiJ10uY29uY2F0KGNvbnRlbnREaXNwb3NpdGlvbiB8fCBbXSksXG4gICAgLy8gaWYgbm8gY29udGVudCB0eXBlLiBhbGxvdyBpdCB0byBiZSBlbXB0eSBhcnJheVxuICAgICdDb250ZW50LVR5cGUnOiBbXS5jb25jYXQoY29udGVudFR5cGUgfHwgW10pXG4gIH07XG5cbiAgLy8gYWxsb3cgY3VzdG9tIGhlYWRlcnMuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXIgPT0gJ29iamVjdCcpIHtcbiAgICBwb3B1bGF0ZShoZWFkZXJzLCBvcHRpb25zLmhlYWRlcik7XG4gIH1cblxuICB2YXIgaGVhZGVyO1xuICBmb3IgKHZhciBwcm9wIGluIGhlYWRlcnMpIHtcbiAgICBpZiAoIWhlYWRlcnMuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuICAgIGhlYWRlciA9IGhlYWRlcnNbcHJvcF07XG5cbiAgICAvLyBza2lwIG51bGxpc2ggaGVhZGVycy5cbiAgICBpZiAoaGVhZGVyID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYWxsIGhlYWRlcnMgdG8gYXJyYXlzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXIpKSB7XG4gICAgICBoZWFkZXIgPSBbaGVhZGVyXTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbm9uLWVtcHR5IGhlYWRlcnMuXG4gICAgaWYgKGhlYWRlci5sZW5ndGgpIHtcbiAgICAgIGNvbnRlbnRzICs9IHByb3AgKyAnOiAnICsgaGVhZGVyLmpvaW4oJzsgJykgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnLS0nICsgdGhpcy5nZXRCb3VuZGFyeSgpICsgRm9ybURhdGEuTElORV9CUkVBSyArIGNvbnRlbnRzICsgRm9ybURhdGEuTElORV9CUkVBSztcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2V0Q29udGVudERpc3Bvc2l0aW9uID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcblxuICB2YXIgZmlsZW5hbWVcbiAgICAsIGNvbnRlbnREaXNwb3NpdGlvblxuICAgIDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsZXBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gY3VzdG9tIGZpbGVwYXRoIGZvciByZWxhdGl2ZSBwYXRoc1xuICAgIGZpbGVuYW1lID0gcGF0aC5ub3JtYWxpemUob3B0aW9ucy5maWxlcGF0aCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZmlsZW5hbWUgfHwgdmFsdWUubmFtZSB8fCB2YWx1ZS5wYXRoKSB7XG4gICAgLy8gY3VzdG9tIGZpbGVuYW1lIHRha2UgcHJlY2VkZW5jZVxuICAgIC8vIGZvcm1pZGFibGUgYW5kIHRoZSBicm93c2VyIGFkZCBhIG5hbWUgcHJvcGVydHlcbiAgICAvLyBmcy0gYW5kIHJlcXVlc3QtIHN0cmVhbXMgaGF2ZSBwYXRoIHByb3BlcnR5XG4gICAgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKG9wdGlvbnMuZmlsZW5hbWUgfHwgdmFsdWUubmFtZSB8fCB2YWx1ZS5wYXRoKTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xuICAgIC8vIG9yIHRyeSBodHRwIHJlc3BvbnNlXG4gICAgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHZhbHVlLmNsaWVudC5faHR0cE1lc3NhZ2UucGF0aCB8fCAnJyk7XG4gIH1cblxuICBpZiAoZmlsZW5hbWUpIHtcbiAgICBjb250ZW50RGlzcG9zaXRpb24gPSAnZmlsZW5hbWU9XCInICsgZmlsZW5hbWUgKyAnXCInO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnREaXNwb3NpdGlvbjtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2V0Q29udGVudFR5cGUgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuXG4gIC8vIHVzZSBjdXN0b20gY29udGVudC10eXBlIGFib3ZlIGFsbFxuICB2YXIgY29udGVudFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXG4gIC8vIG9yIHRyeSBgbmFtZWAgZnJvbSBmb3JtaWRhYmxlLCBicm93c2VyXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUubmFtZSkge1xuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAodmFsdWUubmFtZSk7XG4gIH1cblxuICAvLyBvciB0cnkgYHBhdGhgIGZyb20gZnMtLCByZXF1ZXN0LSBzdHJlYW1zXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUucGF0aCkge1xuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAodmFsdWUucGF0aCk7XG4gIH1cblxuICAvLyBvciBpZiBpdCdzIGh0dHAtcmVwb25zZVxuICBpZiAoIWNvbnRlbnRUeXBlICYmIHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XG4gICAgY29udGVudFR5cGUgPSB2YWx1ZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgfVxuXG4gIC8vIG9yIGd1ZXNzIGl0IGZyb20gdGhlIGZpbGVwYXRoIG9yIGZpbGVuYW1lXG4gIGlmICghY29udGVudFR5cGUgJiYgKG9wdGlvbnMuZmlsZXBhdGggfHwgb3B0aW9ucy5maWxlbmFtZSkpIHtcbiAgICBjb250ZW50VHlwZSA9IG1pbWUubG9va3VwKG9wdGlvbnMuZmlsZXBhdGggfHwgb3B0aW9ucy5maWxlbmFtZSk7XG4gIH1cblxuICAvLyBmYWxsYmFjayB0byB0aGUgZGVmYXVsdCBjb250ZW50IHR5cGUgaWYgYHZhbHVlYCBpcyBub3Qgc2ltcGxlIHZhbHVlXG4gIGlmICghY29udGVudFR5cGUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgY29udGVudFR5cGUgPSBGb3JtRGF0YS5ERUZBVUxUX0NPTlRFTlRfVFlQRTtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50VHlwZTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0Rm9vdGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihuZXh0KSB7XG4gICAgdmFyIGZvb3RlciA9IEZvcm1EYXRhLkxJTkVfQlJFQUs7XG5cbiAgICB2YXIgbGFzdFBhcnQgPSAodGhpcy5fc3RyZWFtcy5sZW5ndGggPT09IDApO1xuICAgIGlmIChsYXN0UGFydCkge1xuICAgICAgZm9vdGVyICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpO1xuICAgIH1cblxuICAgIG5leHQoZm9vdGVyKTtcbiAgfS5iaW5kKHRoaXMpO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9sYXN0Qm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyAnLS0nICsgRm9ybURhdGEuTElORV9CUkVBSztcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRIZWFkZXJzID0gZnVuY3Rpb24odXNlckhlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcjtcbiAgdmFyIGZvcm1IZWFkZXJzID0ge1xuICAgICdjb250ZW50LXR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JyArIHRoaXMuZ2V0Qm91bmRhcnkoKVxuICB9O1xuXG4gIGZvciAoaGVhZGVyIGluIHVzZXJIZWFkZXJzKSB7XG4gICAgaWYgKHVzZXJIZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgIGZvcm1IZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHVzZXJIZWFkZXJzW2hlYWRlcl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1IZWFkZXJzO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLnNldEJvdW5kYXJ5ID0gZnVuY3Rpb24oYm91bmRhcnkpIHtcbiAgdGhpcy5fYm91bmRhcnkgPSBib3VuZGFyeTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2JvdW5kYXJ5KSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVCb3VuZGFyeSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2JvdW5kYXJ5O1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YUJ1ZmZlciA9IG5ldyBCdWZmZXIuYWxsb2MoIDAgKTtcbiAgdmFyIGJvdW5kYXJ5ID0gdGhpcy5nZXRCb3VuZGFyeSgpO1xuXG4gIC8vIENyZWF0ZSB0aGUgZm9ybSBjb250ZW50LiBBZGQgTGluZSBicmVha3MgdG8gdGhlIGVuZCBvZiBkYXRhLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fc3RyZWFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fc3RyZWFtc1tpXSAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAvLyBBZGQgY29udGVudCB0byB0aGUgYnVmZmVyLlxuICAgICAgaWYoQnVmZmVyLmlzQnVmZmVyKHRoaXMuX3N0cmVhbXNbaV0pKSB7XG4gICAgICAgIGRhdGFCdWZmZXIgPSBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgdGhpcy5fc3RyZWFtc1tpXV0pO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKHRoaXMuX3N0cmVhbXNbaV0pXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBicmVhayBhZnRlciBjb250ZW50LlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zdHJlYW1zW2ldICE9PSAnc3RyaW5nJyB8fCB0aGlzLl9zdHJlYW1zW2ldLnN1YnN0cmluZyggMiwgYm91bmRhcnkubGVuZ3RoICsgMiApICE9PSBib3VuZGFyeSkge1xuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKEZvcm1EYXRhLkxJTkVfQlJFQUspXSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCB0aGUgZm9vdGVyIGFuZCByZXR1cm4gdGhlIEJ1ZmZlciBvYmplY3QuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgQnVmZmVyLmZyb20odGhpcy5fbGFzdEJvdW5kYXJ5KCkpXSApO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9nZW5lcmF0ZUJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRoaXMgZ2VuZXJhdGVzIGEgNTAgY2hhcmFjdGVyIGJvdW5kYXJ5IHNpbWlsYXIgdG8gdGhvc2UgdXNlZCBieSBGaXJlZm94LlxuICAvLyBUaGV5IGFyZSBvcHRpbWl6ZWQgZm9yIGJveWVyLW1vb3JlIHBhcnNpbmcuXG4gIHZhciBib3VuZGFyeSA9ICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgIGJvdW5kYXJ5ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKS50b1N0cmluZygxNik7XG4gIH1cblxuICB0aGlzLl9ib3VuZGFyeSA9IGJvdW5kYXJ5O1xufTtcblxuLy8gTm90ZTogZ2V0TGVuZ3RoU3luYyBET0VTTidUIGNhbGN1bGF0ZSBzdHJlYW1zIGxlbmd0aFxuLy8gQXMgd29ya2Fyb3VuZCBvbmUgY2FuIGNhbGN1bGF0ZSBmaWxlIHNpemUgbWFudWFsbHlcbi8vIGFuZCBhZGQgaXQgYXMga25vd25MZW5ndGggb3B0aW9uXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0TGVuZ3RoU3luYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIga25vd25MZW5ndGggPSB0aGlzLl9vdmVyaGVhZExlbmd0aCArIHRoaXMuX3ZhbHVlTGVuZ3RoO1xuXG4gIC8vIERvbid0IGdldCBjb25mdXNlZCwgdGhlcmUgYXJlIDMgXCJpbnRlcm5hbFwiIHN0cmVhbXMgZm9yIGVhY2gga2V5dmFsIHBhaXJcbiAgLy8gc28gaXQgYmFzaWNhbGx5IGNoZWNrcyBpZiB0aGVyZSBpcyBhbnkgdmFsdWUgYWRkZWQgdG8gdGhlIGZvcm1cbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzQwXG4gIGlmICghdGhpcy5oYXNLbm93bkxlbmd0aCgpKSB7XG4gICAgLy8gU29tZSBhc3luYyBsZW5ndGggcmV0cmlldmVycyBhcmUgcHJlc2VudFxuICAgIC8vIHRoZXJlZm9yZSBzeW5jaHJvbm91cyBsZW5ndGggY2FsY3VsYXRpb24gaXMgZmFsc2UuXG4gICAgLy8gUGxlYXNlIHVzZSBnZXRMZW5ndGgoY2FsbGJhY2spIHRvIGdldCBwcm9wZXIgbGVuZ3RoXG4gICAgdGhpcy5fZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHByb3BlciBsZW5ndGggaW4gc3luY2hyb25vdXMgd2F5LicpKTtcbiAgfVxuXG4gIHJldHVybiBrbm93bkxlbmd0aDtcbn07XG5cbi8vIFB1YmxpYyBBUEkgdG8gY2hlY2sgaWYgbGVuZ3RoIG9mIGFkZGVkIHZhbHVlcyBpcyBrbm93blxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzE5NlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzI2MlxuRm9ybURhdGEucHJvdG90eXBlLmhhc0tub3duTGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYXNLbm93bkxlbmd0aCA9IHRydWU7XG5cbiAgaWYgKHRoaXMuX3ZhbHVlc1RvTWVhc3VyZS5sZW5ndGgpIHtcbiAgICBoYXNLbm93bkxlbmd0aCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGhhc0tub3duTGVuZ3RoO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBrbm93bkxlbmd0aCA9IHRoaXMuX292ZXJoZWFkTGVuZ3RoICsgdGhpcy5fdmFsdWVMZW5ndGg7XG5cbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKCF0aGlzLl92YWx1ZXNUb01lYXN1cmUubGVuZ3RoKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKHRoaXMsIG51bGwsIGtub3duTGVuZ3RoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXN5bmNraXQucGFyYWxsZWwodGhpcy5fdmFsdWVzVG9NZWFzdXJlLCB0aGlzLl9sZW5ndGhSZXRyaWV2ZXIsIGZ1bmN0aW9uKGVyciwgdmFsdWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIGtub3duTGVuZ3RoICs9IGxlbmd0aDtcbiAgICB9KTtcblxuICAgIGNiKG51bGwsIGtub3duTGVuZ3RoKTtcbiAgfSk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYikge1xuICB2YXIgcmVxdWVzdFxuICAgICwgb3B0aW9uc1xuICAgICwgZGVmYXVsdHMgPSB7bWV0aG9kOiAncG9zdCd9XG4gICAgO1xuXG4gIC8vIHBhcnNlIHByb3ZpZGVkIHVybCBpZiBpdCdzIHN0cmluZ1xuICAvLyBvciB0cmVhdCBpdCBhcyBvcHRpb25zIG9iamVjdFxuICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnc3RyaW5nJykge1xuXG4gICAgcGFyYW1zID0gcGFyc2VVcmwocGFyYW1zKTtcbiAgICBvcHRpb25zID0gcG9wdWxhdGUoe1xuICAgICAgcG9ydDogcGFyYW1zLnBvcnQsXG4gICAgICBwYXRoOiBwYXJhbXMucGF0aG5hbWUsXG4gICAgICBob3N0OiBwYXJhbXMuaG9zdG5hbWUsXG4gICAgICBwcm90b2NvbDogcGFyYW1zLnByb3RvY29sXG4gICAgfSwgZGVmYXVsdHMpO1xuXG4gIC8vIHVzZSBjdXN0b20gcGFyYW1zXG4gIH0gZWxzZSB7XG5cbiAgICBvcHRpb25zID0gcG9wdWxhdGUocGFyYW1zLCBkZWZhdWx0cyk7XG4gICAgLy8gaWYgbm8gcG9ydCBwcm92aWRlZCB1c2UgZGVmYXVsdCBvbmVcbiAgICBpZiAoIW9wdGlvbnMucG9ydCkge1xuICAgICAgb3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wcm90b2NvbCA9PSAnaHR0cHM6JyA/IDQ0MyA6IDgwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHB1dCB0aGF0IGdvb2QgY29kZSBpbiBnZXRIZWFkZXJzIHRvIHNvbWUgdXNlXG4gIG9wdGlvbnMuaGVhZGVycyA9IHRoaXMuZ2V0SGVhZGVycyhwYXJhbXMuaGVhZGVycyk7XG5cbiAgLy8gaHR0cHMgaWYgc3BlY2lmaWVkLCBmYWxsYmFjayB0byBodHRwIGluIGFueSBvdGhlciBjYXNlXG4gIGlmIChvcHRpb25zLnByb3RvY29sID09ICdodHRwczonKSB7XG4gICAgcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IGh0dHAucmVxdWVzdChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGdldCBjb250ZW50IGxlbmd0aCBhbmQgZmlyZSBhd2F5XG4gIHRoaXMuZ2V0TGVuZ3RoKGZ1bmN0aW9uKGVyciwgbGVuZ3RoKSB7XG4gICAgaWYgKGVyciAmJiBlcnIgIT09ICdVbmtub3duIHN0cmVhbScpIHtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIGNvbnRlbnQgbGVuZ3RoXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBpcGUocmVxdWVzdCk7XG4gICAgaWYgKGNiKSB7XG4gICAgICB2YXIgb25SZXNwb25zZTtcblxuICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yLCByZXNwb25jZSkge1xuICAgICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcblxuICAgICAgICByZXR1cm4gY2IuY2FsbCh0aGlzLCBlcnJvciwgcmVzcG9uY2UpO1xuICAgICAgfTtcblxuICAgICAgb25SZXNwb25zZSA9IGNhbGxiYWNrLmJpbmQodGhpcywgbnVsbCk7XG5cbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICghdGhpcy5lcnJvcikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnI7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnW29iamVjdCBGb3JtRGF0YV0nO1xufTtcbiJdLCJuYW1lcyI6WyJDb21iaW5lZFN0cmVhbSIsInJlcXVpcmUiLCJ1dGlsIiwicGF0aCIsImh0dHAiLCJodHRwcyIsInBhcnNlVXJsIiwicGFyc2UiLCJmcyIsIlN0cmVhbSIsIm1pbWUiLCJhc3luY2tpdCIsInBvcHVsYXRlIiwibW9kdWxlIiwiZXhwb3J0cyIsIkZvcm1EYXRhIiwiaW5oZXJpdHMiLCJvcHRpb25zIiwiX292ZXJoZWFkTGVuZ3RoIiwiX3ZhbHVlTGVuZ3RoIiwiX3ZhbHVlc1RvTWVhc3VyZSIsImNhbGwiLCJvcHRpb24iLCJMSU5FX0JSRUFLIiwiREVGQVVMVF9DT05URU5UX1RZUEUiLCJwcm90b3R5cGUiLCJhcHBlbmQiLCJmaWVsZCIsInZhbHVlIiwiZmlsZW5hbWUiLCJiaW5kIiwiaXNBcnJheSIsIl9lcnJvciIsIkVycm9yIiwiaGVhZGVyIiwiX211bHRpUGFydEhlYWRlciIsImZvb3RlciIsIl9tdWx0aVBhcnRGb290ZXIiLCJfdHJhY2tMZW5ndGgiLCJ2YWx1ZUxlbmd0aCIsImtub3duTGVuZ3RoIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJsZW5ndGgiLCJieXRlTGVuZ3RoIiwicmVhZGFibGUiLCJoYXNPd25Qcm9wZXJ0eSIsInB1c2giLCJfbGVuZ3RoUmV0cmlldmVyIiwiY2FsbGJhY2siLCJlbmQiLCJ1bmRlZmluZWQiLCJJbmZpbml0eSIsInN0YXJ0Iiwic3RhdCIsImVyciIsImZpbGVTaXplIiwic2l6ZSIsImhlYWRlcnMiLCJvbiIsInJlc3BvbnNlIiwicGF1c2UiLCJyZXN1bWUiLCJjb250ZW50RGlzcG9zaXRpb24iLCJfZ2V0Q29udGVudERpc3Bvc2l0aW9uIiwiY29udGVudFR5cGUiLCJfZ2V0Q29udGVudFR5cGUiLCJjb250ZW50cyIsImNvbmNhdCIsInByb3AiLCJBcnJheSIsImpvaW4iLCJnZXRCb3VuZGFyeSIsImZpbGVwYXRoIiwibm9ybWFsaXplIiwicmVwbGFjZSIsIm5hbWUiLCJiYXNlbmFtZSIsImNsaWVudCIsIl9odHRwTWVzc2FnZSIsImxvb2t1cCIsIm5leHQiLCJsYXN0UGFydCIsIl9zdHJlYW1zIiwiX2xhc3RCb3VuZGFyeSIsImdldEhlYWRlcnMiLCJ1c2VySGVhZGVycyIsImZvcm1IZWFkZXJzIiwidG9Mb3dlckNhc2UiLCJzZXRCb3VuZGFyeSIsImJvdW5kYXJ5IiwiX2JvdW5kYXJ5IiwiX2dlbmVyYXRlQm91bmRhcnkiLCJnZXRCdWZmZXIiLCJkYXRhQnVmZmVyIiwiYWxsb2MiLCJpIiwibGVuIiwiZnJvbSIsInN1YnN0cmluZyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0TGVuZ3RoU3luYyIsImhhc0tub3duTGVuZ3RoIiwiZ2V0TGVuZ3RoIiwiY2IiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJwYXJhbGxlbCIsInZhbHVlcyIsImZvckVhY2giLCJzdWJtaXQiLCJwYXJhbXMiLCJyZXF1ZXN0IiwiZGVmYXVsdHMiLCJtZXRob2QiLCJwb3J0IiwicGF0aG5hbWUiLCJob3N0IiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInNldEhlYWRlciIsInBpcGUiLCJvblJlc3BvbnNlIiwiZXJyb3IiLCJyZXNwb25jZSIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/node_modules/form-data/lib/form_data.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/node_modules/form-data/lib/populate.js":
/*!***************************************************************************!*\
  !*** ./node_modules/node-appwrite/node_modules/form-data/lib/populate.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("// populates missing values\nmodule.exports = function(dst, src) {\n    Object.keys(src).forEach(function(prop) {\n        dst[prop] = dst[prop] || src[prop];\n    });\n    return dst;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL3BvcHVsYXRlLmpzPzM4MmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcG9wdWxhdGVzIG1pc3NpbmcgdmFsdWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRzdCwgc3JjKSB7XG5cbiAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApXG4gIHtcbiAgICBkc3RbcHJvcF0gPSBkc3RbcHJvcF0gfHwgc3JjW3Byb3BdO1xuICB9KTtcblxuICByZXR1cm4gZHN0O1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZHN0Iiwic3JjIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJwcm9wIl0sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkI7QUFDM0JBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxHQUFHLEVBQUVDLEdBQUc7SUFFaENDLE9BQU9DLElBQUksQ0FBQ0YsS0FBS0csT0FBTyxDQUFDLFNBQVNDLElBQUk7UUFFcENMLEdBQUcsQ0FBQ0ssS0FBSyxHQUFHTCxHQUFHLENBQUNLLEtBQUssSUFBSUosR0FBRyxDQUFDSSxLQUFLO0lBQ3BDO0lBRUEsT0FBT0w7QUFDVCIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL3BvcHVsYXRlLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/node_modules/form-data/lib/populate.js\n");

/***/ })

};
;